### apps\web\layout1.ts:
```
// import { Geist, Geist_Mono } from 'next/font/google';

// import '@workspace/ui/globals.css';
// import { Providers } from '@/components/providers';

// const fontSans = Geist({
// 	subsets: ['latin'],
// 	variable: '--font-sans',
// });

// const fontMono = Geist_Mono({
// 	subsets: ['latin'],
// 	variable: '--font-mono',
// });

// export default function RootLayout({
// 	children,
// }: Readonly<{
// 	children: React.ReactNode;
// }>) {
// 	return (
// 		<html lang="en" suppressHydrationWarning>
// 			<body className={`${fontSans.variable} ${fontMono.variable} font-sans antialiased `}>
// 				<Providers>{children}</Providers>
// 			</body>
// 		</html>
// 	);
// }

```

### apps\web\next-env.d.ts:
```
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

### apps\web\middleware.ts:
```
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Get token from cookie
  const token = request.cookies.get('token')?.value;

  // Protected routes pattern
  const isProtectedRoute =
    pathname.startsWith('/dashboard') || pathname.startsWith('/farmers') || pathname.startsWith('/staff');

  // Auth routes pattern
  const isAuthRoute = pathname === '/login';

  // Redirect to login if accessing protected route without token
  if (isProtectedRoute && !token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Redirect to dashboard if accessing auth route with token
  if (isAuthRoute && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
/**
     *  This middleware checks if the user is accessing a protected route without a token and redirects them to the login page. It also checks if the user is accessing an auth route with a token and redirects them to the dashboard. 
    To apply the middleware to all routes, update the  next.config.js  file:
     * 
     *  */

```

### apps\web\eslint.config.js:
```
import { defineConfig } from 'eslint-define-config';

export const nextJsConfig = defineConfig({
  extends: ['next/core-web-vitals', 'turbo', 'prettier'],
  plugins: ['prettier'],
  rules: {
    'prettier/prettier': 'error',
  },
});

```

### apps\web\components\providers.tsx:
```
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
      enableColorScheme
    >
      {children}
    </NextThemesProvider>
  );
}

```

### apps\web\hooks\use-mobile.ts:
```
import * as React from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);

  return !!isMobile;
}

```

### apps\web\hooks\use-permission.ts:
```
import { useAuth } from '@/app/providers/auth-provider';

export function usePermissions() {
  const { user } = useAuth();
  console.log('User in permissions hook: ', user);
  return {
    isAdmin: user?.role === 'ADMIN',
    canCreateFarmer: !!user, // Both admin and staff
    canUpdateFarmer: user?.role === 'ADMIN',
    canDeleteFarmer: user?.role === 'ADMIN',
    canExportData: user?.role === 'ADMIN',
    canManageStaff: user?.role === 'ADMIN',
    canViewDashboard: user?.role === 'ADMIN',
    canViewFarmers: !!user, // Both admin and staff
    canViewProcurement: !!user, // Both admin and staff
    canViewProcessing: !!user, // Both admin and staff
  };
}

```

### apps\web\app\page.tsx:
```
import { Button } from '@workspace/ui/components/button';
import Link from 'next/link';
export default function Home() {
  return (
    <div>
      Chaya Website
      <Link href="/login" passHref>
        <Button>Go to login</Button>
      </Link>
    </div>
  );
}

```

### apps\web\app\layout.tsx:
```
import type { Metadata } from 'next';
import '@workspace/ui/globals.css';
import { ThemeProvider } from './providers/theme-provider';
export const metadata: Metadata = {
  title: 'Chaya App',
  description: 'Agricultural Management Application',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body>
        <ThemeProvider attribute="class" defaultTheme="light" enableSystem disableTransitionOnChange>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

```

### apps\web\app\globals.css:
```
@import 'tailwindcss';

@plugin 'tailwindcss-animate';

@custom-variant dark (&:is(.dark *));
@tailwind utilities;

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

.imgDark {
  display: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }

  .imgLight {
    display: none;
  }
  .imgDark {
    display: unset;
  }
}

:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.145 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.145 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.985 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.269 0 0);
  --input: oklch(0.269 0 0);
  --ring: oklch(0.439 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(0.269 0 0);
  --sidebar-ring: oklch(0.439 0 0);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
  :root {
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}
@layer base {
}

```

### apps\web\app\page.module.css:
```
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-synthesis: none;
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  font-family: var(--font-geist-sans);
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

button.secondary {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  font-family: var(--font-geist-sans);
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
  background: transparent;
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  font-family: var(--font-geist-sans);
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

```

### apps\web\app\components\login-form.tsx:
```
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

import { useAuth } from '@/app/providers/auth-provider';
import { AlertCircle } from 'lucide-react';
import { Alert, AlertDescription } from '@workspace/ui/components/alert';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { cn } from '@workspace/ui/lib/utils';

export function LoginForm({ className, ...props }: React.ComponentPropsWithoutRef<'form'>) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { setUser } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    try {
      const response = await fetch('http://localhost:5000/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
        credentials: 'include',
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Invalid credentials');
      }

      const data = await response.json();
      setUser(data.user);
      router.push('/dashboard');
    } catch (err: unknown) {
      if (err instanceof Error) {
        setError(err.message || 'An error occurred during login');
      } else {
        setError('An error occurred during login');
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form
      className={cn('flex flex-col gap-6 p-4 md:p-6 bg-card rounded-lg shadow', className)}
      {...props}
      onSubmit={handleSubmit}
    >
      <div className="flex flex-col items-center gap-2 text-center">
        <h1 className="text-2xl font-bold text-primary">Login to your account</h1>
        <p className="text-sm text-muted-foreground">Enter your email below to login to your account</p>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-2">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid gap-6">
        <div className="grid gap-2">
          <Label htmlFor="email" className="text-sm font-medium">
            Email
          </Label>
          <Input
            id="email"
            type="email"
            placeholder="email@example.com"
            required
            className="border border-input focus:ring-primary focus:border-primary"
            value={email}
            onChange={e => setEmail(e.target.value)}
            disabled={isLoading}
          />
        </div>
        <div className="grid gap-2">
          <div className="flex items-center justify-between">
            <Label htmlFor="password" className="text-sm font-medium">
              Password
            </Label>
          </div>
          <Input
            id="password"
            type="password"
            required
            className="border border-input focus:ring-primary focus:border-primary"
            value={password}
            onChange={e => setPassword(e.target.value)}
            disabled={isLoading}
          />
        </div>
        <Button type="submit" className="w-full bg-primary text-primary-foreground" disabled={isLoading}>
          {isLoading ? 'Logging in...' : 'Login'}
        </Button>
      </div>
    </form>
  );
}

```

### apps\web\app\components\theme-toggle.tsx:
```
'use client';

import * as React from 'react';
import { Moon, Sun } from 'lucide-react';
import { useTheme } from 'next-themes';
import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
} from '@workspace/ui/components/dropdown-menu';

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\components\upload\document-uploaded-alt.tsx:
```
// components/upload/document-uploader-alt.tsx
'use client';

import { useState } from 'react';
import { UploadButton } from '@/utils/uploadthing';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Check, Loader2, Upload, X } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';

type UploadEndpoint = 'profilePicture' | 'aadharDocument' | 'bankDocument' | 'landDocument';

interface DocumentUploaderAltProps {
  endpoint: UploadEndpoint;
  value?: string;
  onChange: (url: string) => void;
  label: string;
  accept?: string;
}

export function DocumentUploaderAlt({ endpoint, value, onChange, label, accept }: DocumentUploaderAltProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleRemove = () => {
    onChange('');
  };

  return (
    <div className="space-y-2">
      <div className="text-sm font-medium">{label}</div>

      {value ? (
        <Card className="overflow-hidden">
          <CardContent className="p-0">
            <div className="flex items-center justify-between p-4">
              <div className="flex items-center gap-2">
                <Check className="h-5 w-5 text-green-500" />
                <span className="text-sm">Document uploaded</span>
              </div>
              <div className="flex gap-2">
                <Button variant="ghost" size="sm" onClick={handleRemove}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            <div className="flex flex-col items-center justify-center space-y-2">
              <div className="flex h-10 w-10 items-center justify-center rounded-full bg-muted">
                <Upload className="h-5 w-5" />
              </div>

              <div className="space-y-1 text-center">
                <p className="text-sm font-medium">Upload {label}</p>
                <p className="text-xs text-muted-foreground">Max file size: 500KB</p>
              </div>

              <UploadButton
                endpoint={endpoint}
                onClientUploadComplete={res => {
                  if (res && res[0]) {
                    onChange(res[0].url);
                  }
                  setIsUploading(false);
                }}
                onUploadError={err => {
                  setError(err.message);
                  setIsUploading(false);
                }}
                onUploadBegin={() => {
                  setIsUploading(true);
                  setError(null);
                }}
                className="w-full"
                appearance={{
                  button: 'w-full bg-muted hover:bg-muted/80 text-foreground',
                  allowedContent: 'hidden',
                }}
              />

              {isUploading && (
                <div className="flex flex-col items-center gap-2 mt-2">
                  <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
                  <p className="text-sm text-muted-foreground">Uploading...</p>
                </div>
              )}

              {error && <p className="text-sm text-red-500">{error}</p>}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

```

### apps\web\app\components\upload\document-uploader.tsx:
```
'use client';

import { useState, useCallback } from 'react';
import { UploadDropzone } from '@/utils/uploadthing';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Check, Loader2, X, AlertCircle } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';
import imageCompression from 'browser-image-compression';

type UploadEndpoint = 'profilePicture' | 'aadharDocument' | 'bankDocument' | 'landDocument';

interface DocumentUploaderProps {
  endpoint: UploadEndpoint;
  value?: string;
  onChange: (url: string) => void;
  label: string;
  accept?: string;
}

const MAX_PDF_SIZE_KB = 200;
const MAX_IMAGE_SIZE_KB = 300;

export function DocumentUploader({ endpoint, value, onChange, label }: DocumentUploaderProps) {
  const [error, setError] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [isCompressing, setIsCompressing] = useState(false);

  const handleRemove = () => {
    onChange('');
  };

  const compressFile = useCallback(async (file: File): Promise<File> => {
    const fileSizeKB = Math.round(file.size / 1024);

    if (file.type === 'application/pdf') {
      if (fileSizeKB > MAX_PDF_SIZE_KB) {
        throw new Error(
          `PDF file is too large (${fileSizeKB}KB). Please compress to under ${MAX_PDF_SIZE_KB}KB before uploading.`
        );
      }
      return file;
    }

    if (!file.type.startsWith('image/')) {
      return file;
    }

    setIsCompressing(true);

    try {
      const options = {
        maxSizeMB: MAX_IMAGE_SIZE_KB / 1024,
        maxWidthOrHeight: 1500,
        useWebWorker: true,
      };

      const compressedFile = await imageCompression(file, options);
      const compressedSizeKB = Math.round(compressedFile.size / 1024);

      if (compressedSizeKB > MAX_IMAGE_SIZE_KB) {
        throw new Error(
          `Image could not be compressed enough (${compressedSizeKB}KB). Please use an image editor to reduce to under ${MAX_IMAGE_SIZE_KB}KB.`
        );
      }

      return compressedFile;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to compress image. Please try a smaller image (under ${MAX_IMAGE_SIZE_KB}KB).`);
    } finally {
      setIsCompressing(false);
    }
  }, []);

  const validateAndProcessFiles = useCallback(
    async (files: File[]): Promise<File[]> => {
      try {
        const processedFiles = await Promise.all(
          files.map(async file => {
            try {
              return await compressFile(file);
            } catch (error) {
              if (error instanceof Error) {
                setError(error.message);
              } else {
                setError(`Unknown error processing file`);
              }
              throw error;
            }
          })
        );

        return processedFiles;
      } catch (error) {
        throw new Error('File processing failed');
      }
    },
    [compressFile]
  );

  return (
    <div className="space-y-2">
      <div className="text-sm font-medium">{label}</div>

      {value ? (
        <Card className="overflow-hidden">
          <CardContent className="p-0">
            <div className="flex items-center justify-between p-4">
              <div className="flex items-center gap-2">
                <Check className="h-5 w-5 text-green-500" />
                <span className="text-sm">Document uploaded</span>
              </div>
              <div className="flex gap-2">
                <Button variant="ghost" size="sm" onClick={handleRemove}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      ) : isUploading || isCompressing ? (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            <div className="flex flex-col items-center justify-center py-6">
              <Loader2 className="h-8 w-8 text-primary animate-spin mb-2" />
              <p className="text-sm text-muted-foreground">
                {isCompressing ? 'Compressing file...' : 'Uploading document...'}
              </p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            {error && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
                <div className="flex items-start gap-2 text-sm text-red-600">
                  <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="font-medium">Upload failed</p>
                    <p>{error}</p>
                  </div>
                </div>
              </div>
            )}

            <UploadDropzone
              endpoint={endpoint}
              onUploadBegin={() => {
                setIsUploading(true);
                setError(null);
              }}
              onClientUploadComplete={res => {
                setIsUploading(false);
                if (res && res[0]) {
                  onChange(res[0].url);
                }
              }}
              onUploadError={err => {
                setIsUploading(false);
                setError(err.message);
              }}
              onBeforeUploadBegin={validateAndProcessFiles}
              content={{
                label: `Upload ${label}`,
                allowedContent: `Images (${MAX_IMAGE_SIZE_KB}KB) or PDFs (${MAX_PDF_SIZE_KB}KB)`,
              }}
              config={{
                mode: 'auto',
              }}
            />

            <div className="mt-3 text-xs text-muted-foreground space-y-1">
              <p>• Images will be automatically compressed if possible</p>
              <p>• PDFs must be under {MAX_PDF_SIZE_KB}KB (typically 1 page)</p>
              <p>• For best results, ensure documents are clearly legible</p>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

```

### apps\web\app\components\layout\app-sidebar.tsx:
```
'use client';

import * as React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Home, Users, Package, BarChart, LogOut, Leaf, ChevronLeft, Menu } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { cn } from '@workspace/ui/lib/utils';
import { Button } from '@workspace/ui/components/button';

const baseNavItems = [
  { title: 'Dashboard', href: '/dashboard', icon: Home, adminOnly: true },
  { title: 'Farmer Details', href: '/farmers', icon: Leaf, adminOnly: false },
  { title: 'Procurement', href: '/procurements', icon: Package, adminOnly: false },
  { title: 'Processing Batches', href: '/processing-batches', icon: BarChart, adminOnly: false },
];

const adminNavItems = [{ title: 'Staff Management', href: '/staff', icon: Users, adminOnly: true }];

const MIN_WIDTH = 60;
const MAX_WIDTH = 280;
const DEFAULT_WIDTH = 200;

export function AppSidebar(props: React.HTMLAttributes<HTMLDivElement>) {
  const pathname = usePathname();
  const { user, signOut } = useAuth();
  const [isLoaded, setIsLoaded] = React.useState(false);
  const [collapsed, setCollapsed] = React.useState(true);
  const [sidebarWidth, setSidebarWidth] = React.useState(MIN_WIDTH);
  const [isResizing, setIsResizing] = React.useState(false);

  const isRouteActive = (href: string) => pathname === href || pathname.startsWith(`${href}/`);

  const navItems = React.useMemo(() => {
    let items = [...baseNavItems];
    if (user?.role === 'ADMIN') {
      items = items.concat(adminNavItems);
    }
    items = items.filter(item => !item.adminOnly || (item.adminOnly && user?.role === 'ADMIN'));
    return items;
  }, [user]);

  React.useEffect(() => {
    try {
      const storedCollapsed = localStorage.getItem('sidebar-collapsed');
      const storedWidth = localStorage.getItem('sidebar-width');

      setCollapsed(storedCollapsed ? JSON.parse(storedCollapsed) : false);
      setSidebarWidth(storedWidth ? Math.max(MIN_WIDTH, Math.min(JSON.parse(storedWidth), MAX_WIDTH)) : DEFAULT_WIDTH);
    } catch (error) {
      console.error('Error loading sidebar state:', error);
    } finally {
      setIsLoaded(true);
    }
  }, []);

  React.useEffect(() => {
    if (!isLoaded) return;
    localStorage.setItem('sidebar-collapsed', JSON.stringify(collapsed));
    localStorage.setItem('sidebar-width', JSON.stringify(sidebarWidth));
  }, [collapsed, sidebarWidth, isLoaded]);

  const toggleCollapse = () => {
    setCollapsed(!collapsed);
  };

  const startResize = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
  };

  React.useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isResizing) return;
      let newWidth = e.clientX;
      newWidth = Math.max(MIN_WIDTH, Math.min(newWidth, MAX_WIDTH));
      setSidebarWidth(newWidth);

      if (newWidth < MIN_WIDTH + 20 && !collapsed) {
        setCollapsed(true);
      } else if (newWidth > MIN_WIDTH + 50 && collapsed) {
        setCollapsed(false);
      }
    };

    const handleMouseUp = () => {
      setIsResizing(false);
      document.body.style.cursor = '';
    };

    if (isResizing) {
      document.body.style.cursor = 'col-resize';
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isResizing, collapsed]);

  if (!isLoaded || !user) {
    // Add !user check here to avoid rendering sidebar before user is loaded
    return (
      <div className="flex flex-col h-full bg-white border-r border-gray-200 shadow-md" style={{ width: MIN_WIDTH }}>
        <div className="flex items-center justify-center h-16 border-b">
          <div className="w-8 h-8 bg-gray-200 rounded animate-pulse" />
        </div>
        {/* ... rest of skeleton ... */}
      </div>
    );
  }

  return (
    <div
      className="flex flex-col h-full bg-white border-r  shadow-md relative group transition-all duration-300 ease-in-out"
      style={{ width: collapsed ? MIN_WIDTH : sidebarWidth }}
      {...props}
    >
      <div className="flex items-center justify-between h-16 border-b border-gray-200 px-4 bg-gray-100">
        {!collapsed && (
          <div className="text-xl font-bold text-green-600 whitespace-nowrap transition-opacity duration-200 ease-in-out">
            Chaya
          </div>
        )}
        <Button
          variant="outline"
          size="icon"
          onClick={toggleCollapse}
          className="h-8 w-8 ml-1 border border-gray-300 rounded-md shadow-sm hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-green-500 transition-all duration-200"
          aria-label={collapsed ? 'Expand sidebar' : 'Collapse sidebar'}
        >
          {collapsed ? <Menu className="h-4 w-4 text-gray-600" /> : <ChevronLeft className="h-4 w-4 text-gray-600" />}
        </Button>
      </div>

      <div className="flex flex-1 flex-col justify-between overflow-hidden">
        <nav className="p-2 space-y-1 overflow-y-auto">
          {navItems.map(item => {
            // Condition to render item:
            // Render if not adminOnly, OR if adminOnly and user is ADMIN
            if (!item.adminOnly || (item.adminOnly && user?.role === 'ADMIN')) {
              const active = isRouteActive(item.href);
              return (
                <Link
                  key={item.href}
                  href={item.href}
                  className={cn(
                    'flex items-center gap-2 px-3 py-2 rounded-md transition-all duration-200',
                    active
                      ? 'bg-green-100 text-green-800 border-l-4 border-green-600'
                      : 'text-gray-700 hover:bg-gray-100 border-l-4 border-transparent',
                    collapsed ? 'justify-center' : ''
                  )}
                  title={collapsed ? item.title : undefined}
                >
                  <item.icon className="w-5 h-5 flex-shrink-0" />
                  {!collapsed && (
                    <span className="whitespace-nowrap transition-opacity duration-200">{item.title}</span>
                  )}
                </Link>
              );
            }
            return null; // Don't render if adminOnly and user is not admin
          })}
        </nav>

        <div className="p-2  border-t border-gray-200 ">
          <button
            onClick={signOut}
            className={cn(
              'flex items-center gap-2 px-3 py-2 text-red-600 rounded-md hover:bg-red-50 w-full transition-all duration-200 border border-transparent hover:border-red-200',
              collapsed ? 'justify-center' : ''
            )}
            title={collapsed ? 'Log Out' : undefined}
          >
            <LogOut className="w-5 h-5 flex-shrink-0" />
            {!collapsed && <span className="whitespace-nowrap transition-opacity duration-200">Log Out</span>}
          </button>
        </div>
      </div>

      <div
        className="absolute right-0 top-0 bottom-0 w-1 cursor-col-resize bg-gray-300 hover:w-2 hover:bg-green-300 active:w-3 active:bg-green-400 transition-all duration-200"
        onMouseDown={startResize}
      />
    </div>
  );
}

```

### apps\web\app\components\farmer-form\address-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';

export function AddressSection() {
  const { control } = useFormContext();

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="farmer.state"
          render={({ field }) => (
            <FormItem>
              <FormLabel>State</FormLabel>
              <FormControl>
                <Input placeholder="Enter state" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.district"
          render={({ field }) => (
            <FormItem>
              <FormLabel>District</FormLabel>
              <FormControl>
                <Input placeholder="Enter district" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.mandal"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Mandal</FormLabel>
              <FormControl>
                <Input placeholder="Enter mandal" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.village"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Village</FormLabel>
              <FormControl>
                <Input placeholder="Enter village" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.panchayath"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Panchayath</FormLabel>
              <FormControl>
                <Input placeholder="Enter panchayath" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\LocationButton.tsx:
```
import { MapPin, Loader2 } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';
import { useState } from 'react';
import { toast } from 'sonner';

export interface LocationData {
  lat: number;
  lng: number;
  accuracy: number;
  altitude: number | null;
  altitudeAccuracy: number | null;
  timestamp: number;
}

interface LocationButtonProps {
  onLocationUpdate: (location: LocationData) => void;
  fieldIndex: number;
}

export function LocationButton({ onLocationUpdate }: LocationButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  const getCurrentLocation = () => {
    setIsLoading(true);
    if (!('geolocation' in navigator)) {
      toast.error('Geolocation is not supported by your browser');
      setIsLoading(false);
      return;
    }

    const options: PositionOptions = {
      enableHighAccuracy: true,
      timeout: 5000,
      maximumAge: 0,
    };

    navigator.geolocation.getCurrentPosition(
      position => {
        const locationData: LocationData = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          altitude: position.coords.altitude,
          altitudeAccuracy: position.coords.altitudeAccuracy,
          timestamp: position.timestamp,
        };
        onLocationUpdate(locationData);
        setIsLoading(false);
        toast.success('Location updated successfully');
      },
      error => {
        let errorMessage = 'Failed to get location';
        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'Location permission denied. Please enable location access.';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'Location information unavailable. Please check your device settings.';
            break;
          case error.TIMEOUT:
            errorMessage = 'Location request timed out. Please try again.';
            break;
        }
        toast.error(errorMessage);
        setIsLoading(false);
      },
      options
    );
  };

  return (
    <Button
      type="button"
      variant="outline"
      onClick={getCurrentLocation}
      disabled={isLoading}
      className="w-full flex items-center justify-center gap-2"
    >
      {isLoading ? <Loader2 className="h-4 w-4 animate-spin" /> : <MapPin className="h-4 w-4" />}
      {isLoading ? 'Getting Location...' : 'Get Current Location'}
    </Button>
  );
}

```

### apps\web\app\components\farmer-form\fields-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Button } from '@workspace/ui/components/button';
import { Card, CardContent, CardHeader, CardTitle } from '@workspace/ui/components/card';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { DocumentUploader } from '../upload/document-uploader';
import { Plus, Trash2 } from 'lucide-react';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { LocationButton, LocationData } from './LocationButton';

export function FieldsSection() {
  const { control, watch, setValue } = useFormContext();
  const fields = watch('fields') || [];
  const { addField, removeField } = useFarmerFormStore();

  const handleLocationUpdate = (index: number, locationData: LocationData) => {
    setValue(`fields.${index}.location`, locationData, {
      shouldValidate: true,
      shouldDirty: true,
    });
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">Farm Fields</h3>
        <Button type="button" onClick={() => addField()} size="sm" variant="outline">
          <Plus className="mr-2 h-4 w-4" />
          Add Field
        </Button>
      </div>

      <div className="space-y-4">
        {fields.map((_: any, index: number) => (
          <Card key={index}>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-base">Field {index + 1}</CardTitle>
              {fields.length > 1 && (
                <Button
                  type="button"
                  onClick={() => removeField(index)}
                  variant="ghost"
                  size="sm"
                  className="h-8 w-8 p-0"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                <FormField
                  control={control}
                  name={`fields.${index}.areaHa`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Area (Hectares)</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="Enter area"
                          {...field}
                          onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                          value={field.value || ''}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={control}
                  name={`fields.${index}.yieldEstimate`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Yield Estimate</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="Enter yield estimate"
                          {...field}
                          onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                          value={field.value || ''}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="sm:col-span-2 space-y-4">
                  <FormLabel>Location</FormLabel>
                  <LocationButton
                    onLocationUpdate={(locationData: any) => handleLocationUpdate(index, locationData)}
                    fieldIndex={index}
                  />

                  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 mt-4">
                    <FormField
                      control={control}
                      name={`fields.${index}.location.lat`}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Latitude</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              placeholder="Enter latitude"
                              {...field}
                              onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                              value={field.value || ''}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={control}
                      name={`fields.${index}.location.lng`}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Longitude</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              placeholder="Enter longitude"
                              {...field}
                              onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                              value={field.value || ''}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </div>

                <FormField
                  control={control}
                  name={`fields.${index}.landDocumentUrl`}
                  render={({ field }) => (
                    <FormItem className="sm:col-span-2">
                      <FormControl>
                        <DocumentUploader
                          endpoint="landDocument"
                          label="Land Document"
                          value={field.value}
                          onChange={field.onChange}
                          accept="image/*,.pdf"
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\index.ts:
```
export * from './farmer-form';
export * from './personal-info-section';
export * from './address-section';
export * from './bank-details-section';
export * from './documents-section';
export * from './fields-section';
export * from './review-section';

```

### apps\web\app\components\farmer-form\personal-info-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { CalendarIcon, ChevronLeft, ChevronRight } from 'lucide-react';
import { addYears, format, subYears } from 'date-fns';
import { Calendar } from '@workspace/ui/components/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Button } from '@workspace/ui/components/button';
import { useEffect, useState } from 'react';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { cn } from '@workspace/ui/lib/utils';

export function PersonalInfoSection() {
  const { control, watch } = useFormContext();
  const { calculateAge } = useFarmerFormStore();

  // Watch birth date to calculate age automatically
  const birthDate = watch('farmer.dateOfBirth');

  // State for the calendar to handle year navigation
  const [calendarDate, setCalendarDate] = useState<Date>(new Date());

  useEffect(() => {
    if (birthDate) {
      calculateAge(birthDate);
    }
  }, [birthDate, calculateAge]);

  // Navigate years quickly
  const goToPreviousYear = () => {
    setCalendarDate(prev => subYears(prev, 1));
  };

  const goToNextYear = () => {
    setCalendarDate(prev => addYears(prev, 1));
  };

  const goBackTenYears = () => {
    setCalendarDate(prev => subYears(prev, 10));
  };

  const goForwardTenYears = () => {
    setCalendarDate(prev => addYears(prev, 10));
  };

  // Array of common years for quick selection
  const quickYears = [
    new Date().getFullYear() - 18, // 18 years ago
    new Date().getFullYear() - 25, // 25 years ago
    new Date().getFullYear() - 35, // 35 years ago
    new Date().getFullYear() - 45, // 45 years ago
    new Date().getFullYear() - 55, // 55 years ago
    new Date().getFullYear() - 65, // 65 years ago
  ];

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="farmer.name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Full Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter full name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.relationship"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Relationship</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select relationship" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="SELF">SELF</SelectItem>
                  <SelectItem value="SPOUSE">SPOUSE</SelectItem>
                  <SelectItem value="CHILD">CHILD</SelectItem>
                  <SelectItem value="OTHER">OTHER</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.gender"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Gender</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select gender" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="MALE">MALE</SelectItem>
                  <SelectItem value="FEMALE">FEMALE</SelectItem>
                  <SelectItem value="OTHER">OTHER</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.community"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Community</FormLabel>
              <FormControl>
                <Input placeholder="Enter community" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.aadharNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Aadhar Number</FormLabel>
              <FormControl>
                <Input placeholder="12-digit Aadhar number" {...field} maxLength={12} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.dateOfBirth"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Date of Birth</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={'outline'}
                      className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                    >
                      {field.value ? format(new Date(field.value), 'PPP') : <span>Pick a date</span>}
                      <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <div className="p-2 border-b flex items-center justify-between">
                    <div className="flex gap-1">
                      <Button variant="outline" size="sm" onClick={goBackTenYears} title="Back 10 years">
                        <ChevronLeft className="h-4 w-4" />
                        <ChevronLeft className="h-4 w-4 -ml-2" />
                      </Button>
                      <Button variant="outline" size="sm" onClick={goToPreviousYear} title="Previous year">
                        <ChevronLeft className="h-4 w-4" />
                      </Button>
                    </div>
                    <div className="text-sm font-medium">{format(calendarDate, 'yyyy')}</div>
                    <div className="flex gap-1">
                      <Button variant="outline" size="sm" onClick={goToNextYear} title="Next year">
                        <ChevronRight className="h-4 w-4" />
                      </Button>
                      <Button variant="outline" size="sm" onClick={goForwardTenYears} title="Forward 10 years">
                        <ChevronRight className="h-4 w-4" />
                        <ChevronRight className="h-4 w-4 -ml-2" />
                      </Button>
                    </div>
                  </div>

                  <div className="p-2 border-b">
                    <div className="text-sm font-medium mb-2">Quick Select Year</div>
                    <div className="grid grid-cols-3 gap-1">
                      {quickYears.map(year => (
                        <Button
                          key={year}
                          variant="outline"
                          size="sm"
                          onClick={() => {
                            const newDate = new Date(calendarDate);
                            newDate.setFullYear(year);
                            setCalendarDate(newDate);
                          }}
                        >
                          {year}
                        </Button>
                      ))}
                    </div>
                  </div>

                  <Calendar
                    mode="single"
                    selected={field.value ? new Date(field.value) : undefined}
                    onSelect={date => field.onChange(date?.toISOString().split('T')[0] || '')}
                    disabled={date => date > new Date() || date < new Date('1900-01-01')}
                    month={calendarDate}
                    onMonthChange={setCalendarDate}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.age"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Age</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  placeholder="Auto-calculated from birth date"
                  {...field}
                  value={field.value || ''}
                  disabled
                  className="bg-muted"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.contactNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Contact Number</FormLabel>
              <FormControl>
                <Input placeholder="10-digit contact number" {...field} maxLength={10} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\documents-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { DocumentUploader } from '../upload/document-uploader';

export function DocumentsSection() {
  const { control } = useFormContext();

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-6">
        <FormField
          control={control}
          name="documents.profilePicUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="profilePicture"
                  label="Profile Picture"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="documents.aadharDocUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="aadharDocument"
                  label="Aadhar Document"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*,.pdf"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="documents.bankDocUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="bankDocument"
                  label="Bank Document"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*,.pdf"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\review-section.tsx:
```
// components/farmer-form/review-section.tsx
'use client';

import { useFormContext } from 'react-hook-form';
import { Card, CardContent, CardHeader, CardTitle } from '@workspace/ui/components/card';
import { format } from 'date-fns';

export function ReviewSection() {
  const { watch } = useFormContext();
  const formValues = watch();
  const { farmer, bankDetails, documents, fields } = formValues;

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Personal Information</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Name</dt>
              <dd className="text-sm">{farmer.name || 'N/A'}</dd>
            </div>
            {/* <div>
							<dt className="text-sm font-medium text-muted-foreground">Survey Number</dt>
							<dd className="text-sm">{farmer.surveyNumber || 'N/A'}</dd>
						</div> */}
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Relationship</dt>
              <dd className="text-sm">{farmer.relationship || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Gender</dt>
              <dd className="text-sm">{farmer.gender || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Community</dt>
              <dd className="text-sm">{farmer.community || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Aadhar Number</dt>
              <dd className="text-sm">{farmer.aadharNumber || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Date of Birth</dt>
              <dd className="text-sm">{farmer.dateOfBirth ? format(new Date(farmer.dateOfBirth), 'PPP') : 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Age</dt>
              <dd className="text-sm">{farmer.age || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Contact Number</dt>
              <dd className="text-sm">{farmer.contactNumber || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Address Information</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">State</dt>
              <dd className="text-sm">{farmer.state || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">District</dt>
              <dd className="text-sm">{farmer.district || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Mandal</dt>
              <dd className="text-sm">{farmer.mandal || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Village</dt>
              <dd className="text-sm">{farmer.village || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Panchayath</dt>
              <dd className="text-sm">{farmer.panchayath || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Bank Details</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">IFSC Code</dt>
              <dd className="text-sm">{bankDetails?.ifscCode || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Name</dt>
              <dd className="text-sm">{bankDetails?.bankName || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Branch Name</dt>
              <dd className="text-sm">{bankDetails?.branchName || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Account Number</dt>
              <dd className="text-sm">{bankDetails?.accountNumber || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Code</dt>
              <dd className="text-sm">{bankDetails?.bankCode || 'N/A'}</dd>
            </div>
            <div className="sm:col-span-2">
              <dt className="text-sm font-medium text-muted-foreground">Bank Address</dt>
              <dd className="text-sm">{bankDetails?.address || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Documents</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Profile Picture</dt>
              <dd className="text-sm">{documents?.profilePicUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Aadhar Document</dt>
              <dd className="text-sm">{documents?.aadharDocUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Document</dt>
              <dd className="text-sm">{documents?.bankDocUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Fields</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {fields?.map((field: any, index: number) => (
              <Card key={index}>
                <CardHeader>
                  <CardTitle className="text-base">Field {index + 1}</CardTitle>
                </CardHeader>
                <CardContent>
                  <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Area (Hectares)</dt>
                      <dd className="text-sm">{field.areaHa || 'N/A'}</dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Yield Estimate</dt>
                      <dd className="text-sm">{field.yieldEstimate || 'N/A'}</dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Location</dt>
                      <dd className="text-sm">
                        {field.location
                          ? `Lat: ${field.location.lat?.toFixed(6)}, Lng: ${field.location.lng?.toFixed(6)}`
                          : 'N/A'}
                      </dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Land Document</dt>
                      <dd className="text-sm">{field.landDocumentUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
                    </div>
                  </dl>
                </CardContent>
              </Card>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\farmer-form.tsx:
```
'use client';

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { Button } from '@workspace/ui/components/button';
import { PersonalInfoSection } from './personal-info-section';
import { AddressSection } from './address-section';
import { BankDetailsSection } from './bank-details-section';
import { DocumentsSection } from './documents-section';
import { FieldsSection } from './fields-section';
import { ReviewSection } from './review-section';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import axios from 'axios';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { FieldValues } from 'react-hook-form';
import { toast } from 'sonner';

interface FarmerFormProps {
  mode: 'add' | 'edit';
  open: boolean;
  onOpenChange: (open: boolean) => void;
  farmerId?: number;
}

export function FarmerForm({ mode, open, onOpenChange, farmerId }: FarmerFormProps) {
  const { activeTab, setActiveTab, goToNextTab, goToPreviousTab, form, isSubmitting, setIsSubmitting } =
    useFarmerFormStore();
  const title = mode === 'add' ? 'Add New Farmer' : 'Edit Farmer';

  const handleSubmit = async (data: FieldValues) => {
    setIsSubmitting(true);
    console.log('Submitting data:', JSON.stringify(data, null, 2));

    try {
      const axiosConfig = {
        withCredentials: true,
        headers: {
          'Content-Type': 'application/json',
        },
      };

      const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

      if (mode === 'add') {
        console.log('Doing a POST request to add a new farmer');
        const response = await axios.post(`${apiBaseUrl}/api/farmers`, data, axiosConfig);
        console.log('POST response:', response.data);
        toast.success('Farmer added successfully');
      } else {
        console.log('Doing a PUT request to update farmer', farmerId);
        const response = await axios.put(`${apiBaseUrl}/api/farmers/${farmerId}`, data, axiosConfig);
        console.log('PUT response:', response.data);
        toast.success('Farmer updated successfully');
      }

      const dataChangedEvent = new CustomEvent('farmerDataChanged');
      document.dispatchEvent(dataChangedEvent);
      console.log('Data changed event dispatched after successful form submission');

      onOpenChange(false);
    } catch (error: any) {
      console.error('Error submitting form:', error);
      console.error('Error response:', error.response?.data);

      if (error.response?.status === 401) {
        toast.error('Your session has expired. Please log in again.');
      } else {
        toast.error(`Error: ${error.response?.data?.error || error.message || 'Something went wrong'}`);
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        <Tabs value={activeTab} onValueChange={setActiveTab} className="mt-4">
          <TabsList className="grid w-full grid-cols-6">
            <TabsTrigger value="personal">Personal</TabsTrigger>
            <TabsTrigger value="address">Address</TabsTrigger>
            <TabsTrigger value="bank">Bank</TabsTrigger>
            <TabsTrigger value="documents">Documents</TabsTrigger>
            <TabsTrigger value="fields">Fields</TabsTrigger>
            <TabsTrigger value="review">Review</TabsTrigger>
          </TabsList>
          <TabsContent value="personal" className="space-y-4">
            <PersonalInfoSection />
          </TabsContent>
          <TabsContent value="address" className="space-y-4">
            <AddressSection />
          </TabsContent>
          <TabsContent value="bank" className="space-y-4">
            <BankDetailsSection />
          </TabsContent>
          <TabsContent value="documents" className="space-y-4">
            <DocumentsSection />
          </TabsContent>
          <TabsContent value="fields" className="space-y-4">
            <FieldsSection />
          </TabsContent>
          <TabsContent value="review" className="space-y-4">
            <ReviewSection />
          </TabsContent>
        </Tabs>
        <DialogFooter className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Button variant="outline" onClick={goToPreviousTab} disabled={activeTab === 'personal'}>
              Previous
            </Button>
            <Button variant="outline" onClick={goToNextTab} disabled={activeTab === 'review'}>
              Next
            </Button>
          </div>
          <div className="flex items-center gap-2">
            <Button variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            {activeTab === 'review' && (
              <Button
                type="button"
                onClick={async () => {
                  console.log('Submit button clicked, form exists:', !!form);
                  if (form) {
                    const values = form.getValues();
                    console.log('Current form values:', values);

                    const isValid = await form.trigger();
                    console.log('Form validation result:', isValid);

                    setTimeout(() => {
                      const errors = form.formState.errors;
                      console.log('Detailed errors:', JSON.stringify(errors, null, 2));

                      if (errors.farmer) console.log('Farmer field errors:', errors.farmer);
                      if (errors.bankDetails) console.log('Bank details errors:', errors.bankDetails);
                      if (errors.fields) console.log('Fields errors:', errors.fields);
                    }, 100);

                    if (isValid) {
                      handleSubmit(values);
                    } else {
                      toast.error('Form validation failed. Please check all tabs for errors.');
                    }
                  } else {
                    toast.error('Form data is not available. Please try again.');
                  }
                }}
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Saving...' : 'Save Farmer'}
              </Button>
            )}
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\components\farmer-form\bank-details-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Textarea } from '@workspace/ui/components/textarea';
import { useState } from 'react';
import { Loader2 } from 'lucide-react';
import { toast } from 'sonner';

export function BankDetailsSection() {
  const { control, setValue, setError, clearErrors } = useFormContext();
  const [loadingIFSC, setLoadingIFSC] = useState(false);

  const handleIFSCChange = async (ifscCode: string) => {
    if (!ifscCode || ifscCode.length !== 11) {
      return;
    }

    setLoadingIFSC(true);
    clearErrors('bankDetails.ifscCode');

    try {
      const response = await fetch(`https://ifsc.razorpay.com/${ifscCode}`);
      if (!response.ok) {
        setError('bankDetails.ifscCode', {
          type: 'manual',
          message: 'Failed to fetch IFSC details. Please check the code.',
        });
        toast.error('Failed to fetch IFSC details. Please verify the code.');
        return;
      }

      const data = await response.json();
      setValue('bankDetails.branchName', data.BRANCH || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.address', data.ADDRESS || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.bankName', data.BANK || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.bankCode', data.BANKCODE || '', {
        shouldValidate: true,
      });
      toast.success('IFSC details fetched successfully.');
    } catch (error) {
      console.error('Error fetching IFSC details:', error);
      setError('bankDetails.ifscCode', {
        type: 'manual',
        message: 'Failed to fetch IFSC details due to a network error.',
      });
      toast.error('Network error while fetching IFSC details. Please try again later.');
    } finally {
      setLoadingIFSC(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="bankDetails.ifscCode"
          render={({ field }) => (
            <FormItem>
              <FormLabel>IFSC Code</FormLabel>
              <div className="relative">
                <FormControl>
                  <Input
                    placeholder="Enter IFSC code"
                    {...field}
                    onChange={e => {
                      const value = e.target.value.toUpperCase();
                      field.onChange(value);
                      if (value.length === 11) {
                        handleIFSCChange(value);
                      }
                    }}
                    maxLength={11}
                    className={loadingIFSC ? 'pr-10' : ''}
                  />
                </FormControl>
                {loadingIFSC && (
                  <div className="absolute right-3 top-1/2 -translate-y-1/2">
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  </div>
                )}
              </div>
              <FormMessage />
              <p className="text-xs text-muted-foreground mt-1">Enter a valid IFSC code to auto-fill bank details</p>
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.bankName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Bank Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter bank name" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.branchName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Branch Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter branch name" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.accountNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Account Number</FormLabel>
              <FormControl>
                <Input placeholder="Enter account number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.bankCode"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Bank Code</FormLabel>
              <FormControl>
                <Input placeholder="Enter bank code" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.address"
          render={({ field }) => (
            <FormItem className="sm:col-span-2">
              <FormLabel>Bank Address</FormLabel>
              <FormControl>
                <Textarea placeholder="Enter bank address" className="resize-none" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\procurement-form\basic-info-section.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import { useFormContext, Controller, useWatch } from 'react-hook-form'; // Use useFormContext
import { z } from 'zod';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Combobox } from '@workspace/ui/components/combobox';
import axios from 'axios';
import { toast } from 'sonner';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form'; // Import the full form type

interface Farmer {
  id: number;
  name: string;
  village: string;
  mandal: string;
}

const CROP_OPTIONS = ['Turmeric', 'Coffee', 'Ginger', 'Pepper'] as const;
type CropType = (typeof CROP_OPTIONS)[number];

const PROCURED_FORMS_BY_CROP: Record<CropType, string[]> = {
  Turmeric: ['Fresh Finger', 'Fresh Bulb', 'Dried Finger', 'Dried Bulb'],
  Coffee: ['Fruit', 'Dry Cherry', 'Parchment'],
  Ginger: ['Fresh', 'Dried'],
  Pepper: ['Green Pepper', 'Black Pepper'],
};

export function BasicInfoSection() {
  const {
    control,
    formState: { errors },
    setValue,
    watch,
  } = useFormContext<ProcurementFullFormValues>(); // Use context

  const [farmers, setFarmers] = useState<Farmer[]>([]);
  const [isLoadingFarmers, setIsLoadingFarmers] = useState(false);

  const watchedCrop = watch('crop'); // Watch from the shared form context

  useEffect(() => {
    if (watchedCrop) {
      const currentProcuredFormsForNewCrop = PROCURED_FORMS_BY_CROP[watchedCrop as CropType] || [];
      const currentProcuredFormValue = control._formValues.procuredForm; // Access current value directly

      if (currentProcuredFormValue && !currentProcuredFormsForNewCrop.includes(currentProcuredFormValue)) {
        setValue('procuredForm', '', { shouldValidate: true });
      } else if (!currentProcuredFormValue && currentProcuredFormsForNewCrop.length > 0) {
        // If crop changes and procuredForm was empty, keep it empty unless logic dictates a default.
      }
    }
  }, [watchedCrop, setValue, control._formValues.procuredForm]);

  useEffect(() => {
    const fetchFarmers = async () => {
      setIsLoadingFarmers(true);
      try {
        const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';
        const response = await axios.get(`${apiBaseUrl}/api/farmers`, {
          params: { limit: 1000, isActive: true },
          withCredentials: true,
        });
        setFarmers(response.data.farmers);
      } catch (error) {
        console.error('Error fetching farmers:', error);
        toast.error('Failed to load farmers. Please try again.');
      } finally {
        setIsLoadingFarmers(false);
      }
    };
    fetchFarmers();
  }, []);

  const currentProcuredForms = watchedCrop ? PROCURED_FORMS_BY_CROP[watchedCrop as CropType] || [] : [];

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="farmerId">Farmer</Label>
            <Controller
              control={control}
              name="farmerId"
              render={({ field }) => (
                <Combobox
                  items={farmers.map(farmer => ({
                    label: `${farmer.name} (${farmer.village}, ${farmer.mandal})`,
                    value: farmer.id.toString(),
                  }))}
                  value={field.value ? field.value.toString() : ''}
                  onChange={val => field.onChange(val ? parseInt(val, 10) : undefined)}
                  placeholder="Select a farmer"
                  isLoading={isLoadingFarmers}
                />
              )}
            />
            {errors.farmerId && <p className="text-sm text-red-500 mt-1">{errors.farmerId.message}</p>}
          </div>
          <div>
            <Label htmlFor="crop">Crop</Label>
            <Controller
              control={control}
              name="crop"
              render={({ field }) => (
                <Select
                  onValueChange={field.onChange}
                  value={field.value || ''} // Ensure value is passed for controlled Select
                  // defaultValue={field.value} // Not needed if value is passed
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select crop" />
                  </SelectTrigger>
                  <SelectContent>
                    {CROP_OPTIONS.map(cropName => (
                      <SelectItem key={cropName} value={cropName}>
                        {cropName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.crop && <p className="text-sm text-red-500 mt-1">{errors.crop.message}</p>}
          </div>
          <div>
            <Label htmlFor="procuredForm">Procured Form</Label>
            <Controller
              control={control}
              name="procuredForm"
              render={({ field }) => (
                <Select
                  onValueChange={field.onChange}
                  value={field.value || ''} // Ensure value is passed
                  disabled={!watchedCrop || currentProcuredForms.length === 0}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select form (after choosing crop)" />
                  </SelectTrigger>
                  <SelectContent>
                    {currentProcuredForms.map(formName => (
                      <SelectItem key={formName} value={formName}>
                        {formName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.procuredForm && <p className="text-sm text-red-500 mt-1">{errors.procuredForm.message}</p>}
          </div>
          <div>
            <Label htmlFor="speciality">Speciality</Label>
            <Controller
              control={control}
              name="speciality"
              render={({ field }) => (
                <Select onValueChange={field.onChange} value={field.value || ''}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select speciality" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="Organic">Organic</SelectItem>
                    <SelectItem value="Non-GMO">Non-GMO</SelectItem>
                    <SelectItem value="Fair Trade">Fair Trade</SelectItem>
                    <SelectItem value="Standard">Standard</SelectItem>
                  </SelectContent>
                </Select>
              )}
            />
            {errors.speciality && <p className="text-sm text-red-500 mt-1">{errors.speciality.message}</p>}
          </div>
          <div>
            <Label htmlFor="quantity">Quantity (kg)</Label>
            <Controller
              control={control}
              name="quantity"
              render={({ field }) => (
                <Input
                  type="number"
                  step="0.01"
                  min="0"
                  {...field}
                  value={field.value === undefined ? '' : field.value}
                  onChange={e => field.onChange(e.target.value === '' ? undefined : parseFloat(e.target.value))}
                />
              )}
            />
            {errors.quantity && <p className="text-sm text-red-500 mt-1">{errors.quantity.message}</p>}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\details-section.tsx:
```
'use client';

import { useFormContext, Controller } from 'react-hook-form';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Button } from '@workspace/ui/components/button';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { format } from 'date-fns';
import { Calendar } from '@workspace/ui/components/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { CalendarIcon, Clock } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form';

export function DetailsSection() {
  const {
    control,
    register: formRegister,
    formState: { errors },
  } = useFormContext<ProcurementFullFormValues>();

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="date">Date</Label>
            <Controller
              control={control}
              name="date"
              render={({ field }) => (
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      className={cn(
                        'w-full justify-start text-left font-normal',
                        !field.value && 'text-muted-foreground'
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <Calendar
                      mode="single"
                      selected={field.value instanceof Date ? field.value : undefined}
                      onSelect={field.onChange}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              )}
            />
            {errors.date && <p className="text-sm text-red-500 mt-1">{errors.date.message}</p>}
          </div>

          <div>
            <Label htmlFor="time">Time</Label>
            <Controller
              control={control}
              name="time"
              render={({ field }) => (
                <div className="flex items-center">
                  <Input
                    type="time"
                    step="1"
                    className="flex-1"
                    {...field}
                    value={field.value ? field.value.substring(0, 8) : format(new Date(), 'HH:mm:ss')}
                    onChange={e => {
                      let timeValue = e.target.value;
                      if (timeValue.match(/^\d{2}:\d{2}$/)) {
                        timeValue += ':00';
                      } else if (!timeValue.match(/^\d{2}:\d{2}:\d{2}$/)) {
                        timeValue = field.value || format(new Date(), 'HH:mm:ss');
                      }
                      field.onChange(timeValue);
                    }}
                  />
                  <Clock className="ml-2 h-4 w-4 text-muted-foreground" />
                </div>
              )}
            />
            {errors.time && <p className="text-sm text-red-500 mt-1">{errors.time.message}</p>}
          </div>

          <div>
            <Label htmlFor="lotNo">Lot Number</Label>
            <Controller
              control={control}
              name="lotNo"
              render={({ field }) => (
                <Select onValueChange={value => field.onChange(Number.parseInt(value))} value={field.value?.toString()}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select lot number" />
                  </SelectTrigger>
                  <SelectContent>
                    {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(num => (
                      <SelectItem key={num} value={num.toString()}>
                        {num}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.lotNo && <p className="text-sm text-red-500 mt-1">{errors.lotNo.message}</p>}
          </div>

          <div>
            <Label htmlFor="procuredBy">Procured By</Label>
            <Input id="procuredBy" {...formRegister('procuredBy')} />
            {errors.procuredBy && <p className="text-sm text-red-500 mt-1">{errors.procuredBy.message}</p>}
          </div>

          <div>
            <Label htmlFor="vehicleNo">Vehicle Number (Optional)</Label>
            <Input id="vehicleNo" {...formRegister('vehicleNo')} />
            {errors.vehicleNo && <p className="text-sm text-red-500 mt-1">{errors.vehicleNo.message}</p>}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\review-section.tsx:
```
'use client';
import { useFormContext } from 'react-hook-form';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Separator } from '@workspace/ui/components/separator';
import { format } from 'date-fns';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form';

export function ReviewSection() {
  const { getValues } = useFormContext<ProcurementFullFormValues>();
  const formValues = getValues();

  if (!formValues) {
    return (
      <Card>
        <CardContent className="pt-6">
          <p className="text-center text-muted-foreground">Form data not available for review.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold">Basic Information</h3>
            <Separator className="my-2" />
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <p className="text-sm font-medium">Farmer ID:</p>
                <p className="text-sm">{formValues.farmerId || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Crop:</p>
                <p className="text-sm">{formValues.crop || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Procured Form:</p>
                <p className="text-sm">{formValues.procuredForm || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Speciality:</p>
                <p className="text-sm">{formValues.speciality || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Quantity:</p>
                <p className="text-sm">{formValues.quantity !== undefined ? `${formValues.quantity} kg` : 'N/A'}</p>
              </div>
            </div>
          </div>

          <div>
            <h3 className="text-lg font-semibold">Procurement Details</h3>
            <Separator className="my-2" />
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <p className="text-sm font-medium">Date:</p>
                <p className="text-sm">
                  {formValues.date ? format(new Date(formValues.date), 'dd/MM/yyyy') : 'Not set'}
                </p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Time:</p>
                <p className="text-sm">{formValues.time || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Lot Number:</p>
                <p className="text-sm">{formValues.lotNo || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Procured By:</p>
                <p className="text-sm">{formValues.procuredBy || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Vehicle Number:</p>
                <p className="text-sm">{formValues.vehicleNo || 'N/A'}</p>
              </div>
            </div>
          </div>

          <div className="rounded-md bg-muted p-4">
            <p className="text-sm text-muted-foreground">
              Please review the information above before submitting. A procurement number will be automatically
              generated.
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\procurement-form.tsx:
```
'use client';

import { useEffect } from 'react';
import { useForm, FormProvider, type FieldValues } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { Button } from '@workspace/ui/components/button';
import { BasicInfoSection } from './basic-info-section';
import { DetailsSection } from './details-section';
import { ReviewSection } from './review-section';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import axios from 'axios';
import {
  useProcurementFormStore,
  procurementFullFormSchema,
  type ProcurementFullFormValues,
  type TabType,
} from '@/app/stores/procurement-form';
import { toast } from 'sonner';
import { format } from 'date-fns';

interface ProcurementFormProps {
  mode: 'add' | 'edit';
  open: boolean;
  onOpenChange: (open: boolean) => void;
  procurementId?: number;
}

export function ProcurementForm({ mode, open, onOpenChange, procurementId }: ProcurementFormProps) {
  const {
    activeTab,
    setActiveTab,
    goToNextTab,
    goToPreviousTab,
    setForm: setZustandForm,
    isSubmitting,
    setIsSubmitting,
    initialData,
  } = useProcurementFormStore();

  const title = mode === 'add' ? 'Add New Procurement' : 'Edit Procurement';

  const methods = useForm<ProcurementFullFormValues>({
    resolver: zodResolver(procurementFullFormSchema),
    defaultValues:
      mode === 'edit' && initialData
        ? {
            farmerId: initialData.farmerId,
            crop: initialData.crop,
            procuredForm: initialData.procuredForm,
            speciality: initialData.speciality,
            quantity: initialData.quantity,
            date: initialData.date ? new Date(initialData.date) : new Date(),
            time: initialData.time ? format(new Date(initialData.time), 'HH:mm:ss') : format(new Date(), 'HH:mm:ss'),
            lotNo: initialData.lotNo,
            procuredBy: initialData.procuredBy,
            vehicleNo: initialData.vehicleNo || '',
          }
        : {
            farmerId: undefined,
            crop: '',
            procuredForm: '',
            speciality: '',
            quantity: undefined,
            date: new Date(),
            time: format(new Date(), 'HH:mm:ss'),
            lotNo: 1,
            procuredBy: '',
            vehicleNo: '',
          },
  });

  useEffect(() => {
    setZustandForm(methods);
    if (mode === 'edit' && initialData) {
      methods.reset({
        farmerId: initialData.farmerId,
        crop: initialData.crop,
        procuredForm: initialData.procuredForm,
        speciality: initialData.speciality,
        quantity: initialData.quantity,
        date: new Date(initialData.date),
        time: format(new Date(initialData.time), 'HH:mm:ss'),
        lotNo: initialData.lotNo,
        procuredBy: initialData.procuredBy,
        vehicleNo: initialData.vehicleNo || '',
      });
    } else if (mode === 'add') {
      methods.reset({
        farmerId: undefined,
        crop: '',
        procuredForm: '',
        speciality: '',
        quantity: undefined,
        date: new Date(),
        time: format(new Date(), 'HH:mm:ss'),
        lotNo: 1,
        procuredBy: '',
        vehicleNo: '',
      });
    }
  }, [setZustandForm, mode, initialData]);

  const processAndSubmitData = async (data: ProcurementFullFormValues) => {
    setIsSubmitting(true);

    const payload = {
      ...data,
      date: data.date instanceof Date ? data.date.toISOString().split('T')[0] : data.date,
    };

    console.log('Submitting data to backend:', JSON.stringify(payload, null, 2));

    try {
      const axiosConfig = {
        withCredentials: true,
        headers: {
          'Content-Type': 'application/json',
        },
      };
      const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

      if (mode === 'add') {
        await axios.post(`${apiBaseUrl}/api/procurements`, payload, axiosConfig);
        toast.success('Procurement added successfully');
      } else {
        await axios.put(`${apiBaseUrl}/api/procurements/${procurementId}`, payload, axiosConfig);
        toast.success('Procurement updated successfully');
      }

      document.dispatchEvent(new CustomEvent('procurementDataChanged'));
      onOpenChange(false);
      methods.reset();
      useProcurementFormStore.getState().initializeForm(null, 'add');
    } catch (error: any) {
      console.error('Error submitting form:', error.response?.data || error.message);
      const errorDetails = error.response?.data?.details;
      let errorMessage = error.response?.data?.error || error.message || 'Something went wrong';
      if (errorDetails && Array.isArray(errorDetails)) {
        errorMessage = errorDetails.map((detail: any) => `${detail.path.join('.')}: ${detail.message}`).join('; ');
      }
      toast.error(`Error: ${errorMessage}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog
      open={open}
      onOpenChange={isOpen => {
        onOpenChange(isOpen);
        if (!isOpen) {
          methods.reset();
          useProcurementFormStore.getState().initializeForm(null, 'add');
        }
      }}
    >
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        <FormProvider {...methods}>
          <form onSubmit={methods.handleSubmit(processAndSubmitData)}>
            <Tabs value={activeTab} onValueChange={value => setActiveTab(value as TabType)} className="mt-4">
              <TabsList className="grid w-full grid-cols-3">
                <TabsTrigger value="basic">Basic Info</TabsTrigger>
                <TabsTrigger value="details">Details</TabsTrigger>
                <TabsTrigger value="review">Review</TabsTrigger>
              </TabsList>
              <TabsContent value="basic" className="space-y-4">
                <BasicInfoSection />
              </TabsContent>
              <TabsContent value="details" className="space-y-4">
                <DetailsSection />
              </TabsContent>
              <TabsContent value="review" className="space-y-4">
                <ReviewSection />
              </TabsContent>
            </Tabs>
            <DialogFooter className="flex items-center justify-between pt-4">
              <div className="flex items-center gap-4">
                <Button type="button" variant="outline" onClick={goToPreviousTab} disabled={activeTab === 'basic'}>
                  Previous
                </Button>
                <Button type="button" variant="outline" onClick={goToNextTab} disabled={activeTab === 'review'}>
                  Next
                </Button>
              </div>
              <div className="flex items-center gap-2">
                <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                  Cancel
                </Button>
                {activeTab === 'review' && (
                  <Button type="submit" disabled={isSubmitting || (!methods.formState.isDirty && mode === 'edit')}>
                    {isSubmitting ? 'Saving...' : 'Save Procurement'}
                  </Button>
                )}
              </div>
            </DialogFooter>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\providers\auth-provider.tsx:
```
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { clearSidebarCache } from '../(dashboard)/farmers/lib/sidebar-cache';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  setUser: (user: User) => void;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  setUser: () => {},
  signOut: async () => {},
});

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const API_BASE_URL = 'http://localhost:5000';

  useEffect(() => {
    async function loadUserFromServer() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Data from server of user: ', data);
          setUser(data.user);
        } else {
          console.error('Failed to fetch user: ', response.statusText);
          if (response.status === 401) {
            router.push('/login');
          }
        }
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    }

    loadUserFromServer();
  }, [router]);

  const signOut = async () => {
    try {
      await fetch(`${API_BASE_URL}/api/auth/logout`, {
        method: 'POST',
        credentials: 'include',
      });

      setUser(null);

      clearSidebarCache();

      router.push('/login');
    } catch (error) {
      console.error('Failed to sign out:', error);
    }
  };

  return <AuthContext.Provider value={{ user, loading, setUser, signOut }}>{children}</AuthContext.Provider>;
}

export const useAuth = () => useContext(AuthContext);

```

### apps\web\app\providers\theme-provider.tsx:
```
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';

export function ThemeProvider({ children, ...props }: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

```

### apps\web\app\providers\farmer-form-provider.tsx:
```
'use client';

import { useEffect } from 'react';
import { useForm, FormProvider } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FarmerWithRelations } from '../(dashboard)/farmers/lib/types';
import { createFarmerSchema } from '@chaya/shared';
import { useFarmerFormStore } from '../stores/farmer-form';

interface FarmerFormProviderProps {
  children: React.ReactNode;
  initialData?: FarmerWithRelations;
  mode?: 'add' | 'edit';
}

export function FarmerFormProvider({ children, initialData, mode = 'add' }: FarmerFormProviderProps) {
  const defaultValues = initialData
    ? {
        farmer: {
          name: initialData.name,
          relationship: initialData.relationship,
          gender: initialData.gender,
          community: initialData.community,
          aadharNumber: initialData.aadharNumber,
          dateOfBirth: initialData.dateOfBirth.toISOString().split('T')[0],
          age: initialData.age,
          contactNumber: initialData.contactNumber,
          state: initialData.state,
          district: initialData.district,
          mandal: initialData.mandal,
          village: initialData.village,
          panchayath: initialData.panchayath,
          isActive: initialData.isActive,
        },
        bankDetails: initialData.bankDetails || {
          ifscCode: '',
          bankName: '',
          branchName: '',
          accountNumber: '',
          address: '',
          bankCode: '',
        },
        documents: initialData.documents
          ? {
              profilePicUrl: initialData.documents.profilePicUrl,
              aadharDocUrl: initialData.documents.aadharDocUrl,
              bankDocUrl: initialData.documents.bankDocUrl,
            }
          : {
              profilePicUrl: '',
              aadharDocUrl: '',
              bankDocUrl: '',
            },
        fields:
          initialData.fields && initialData.fields.length > 0
            ? initialData.fields.map(
                (field: { areaHa: any; yieldEstimate: any; location: any; landDocumentUrl: any }) => ({
                  areaHa: field.areaHa,
                  yieldEstimate: field.yieldEstimate,
                  location: field.location,
                  landDocumentUrl: field.landDocumentUrl,
                })
              )
            : [
                {
                  areaHa: 0,
                  yieldEstimate: 0,
                  location: {
                    lat: 0,
                    lng: 0,
                    accuracy: 0,
                    altitude: null,
                    altitudeAccuracy: null,
                    timestamp: Date.now(),
                  },
                  landDocumentUrl: '',
                },
              ],
      }
    : {
        farmer: {
          name: '',
          relationship: 'SELF' as const,
          gender: 'MALE' as const,
          community: '',
          aadharNumber: '',
          dateOfBirth: '',
          age: 0,
          contactNumber: '',
          state: '',
          district: '',
          mandal: '',
          village: '',
          panchayath: '',
          isActive: true,
        },
        bankDetails: {
          ifscCode: '',
          bankName: '',
          branchName: '',
          accountNumber: '',
          address: '',
          bankCode: '',
        },
        documents: {
          profilePicUrl: '',
          aadharDocUrl: '',
          bankDocUrl: '',
        },
        fields: [
          {
            areaHa: 0,
            yieldEstimate: 0,
            location: {
              lat: 0,
              lng: 0,
              accuracy: 0,
              altitude: null,
              altitudeAccuracy: null,
              timestamp: Date.now(),
            },
            landDocumentUrl: '',
          },
        ],
      };

  const form = useForm({
    resolver: zodResolver(createFarmerSchema) as any,
    defaultValues: defaultValues as any,
    mode: 'onChange',
  });

  const setForm = useFarmerFormStore((state: { setForm: any }) => state.setForm);

  useEffect(() => {
    setForm(form);

    return () => {
      setForm(null);
    };
  }, [form, setForm]);

  return <FormProvider {...form}>{children}</FormProvider>;
}

```

### apps\web\app\providers\procurement-form-provider.tsx:
```
'use client';

import React, { createContext, useContext, useEffect, type ReactNode } from 'react';
import { useProcurementFormStore } from '../stores/procurement-form';
import type { ProcurementWithRelations } from '@/app/(dashboard)/procurements/lib/types';

interface ProcurementFormContextType {
  mode: 'add' | 'edit';
  initialData?: ProcurementWithRelations | null;
}

const ProcurementFormContext = createContext<ProcurementFormContextType | undefined>(undefined);

interface ProcurementFormProviderProps {
  children: ReactNode;
  initialData?: ProcurementWithRelations | null;
  mode: 'add' | 'edit';
}

export function ProcurementFormProvider({ children, initialData, mode }: ProcurementFormProviderProps) {
  const { initializeForm } = useProcurementFormStore();

  useEffect(() => {
    initializeForm(initialData, mode);
  }, [initialData, mode, initializeForm]);

  return <ProcurementFormContext.Provider value={{ mode, initialData }}>{children}</ProcurementFormContext.Provider>;
}

export function useProcurementFormContext() {
  const context = useContext(ProcurementFormContext);
  if (context === undefined) {
    throw new Error('useProcurementFormContext must be used within a ProcurementFormProvider');
  }
  return context;
}

```

### apps\web\app\api\sales\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// For creating a new Sale
export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/sales`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/sales:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

// For fetching sales (e.g., for a batch or stage, for admins)
export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const response = await fetch(`${BACKEND_URL}/api/sales?${searchParams.toString()}`, {
      method: 'GET',
      headers: { Cookie: `token=${token}` },
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/sales:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// For creating a new Processing Stage (P-next)
export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages`, {
      // Matches backend route for creating stages
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/processing-stages:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\[stageId]\drying\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// POST for adding a new drying entry
export async function POST(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/drying`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js POST /api/processing-stages/${stageId}/drying:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

// GET for fetching drying entries for a stage
export async function GET(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/drying`, {
      method: 'GET',
      headers: { Cookie: `token=${token}` },
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js GET /api/processing-stages/${stageId}/drying:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\[stageId]\finalize\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function PUT(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/finalize`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js PUT /api/processing-stages/${stageId}/finalize:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-batches\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();

    const response = await fetch(`${BACKEND_URL}/api/processing-batches`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to create processing batch on backend', details: data.details }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/processing-batches route:', error);
    if (error instanceof Response) {
      return error;
    }
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);

    const response = await fetch(`${BACKEND_URL}/api/processing-batches?${searchParams.toString()}`, {
      method: 'GET',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to fetch processing batches from backend' }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/processing-batches route:', error);
    if (error instanceof Response) {
      return error;
    }
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

```

### apps\web\app\api\procurements\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to create procurement',
        }),
        { status: response.status }
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement POST route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get('query') || '';
    const page = searchParams.get('page') || '1';
    const limit = searchParams.get('limit') || '10';

    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';
    const response = await fetch(`${backendUrl}/api/procurements?search=${query}&page=${page}&limit=${limit}`, {
      headers: {
        Cookie: `token=${token}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch procurement data');
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement API route:', error);
    return new NextResponse(JSON.stringify({ error: 'Failed to fetch procurement data' }), { status: 500 });
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements/${params.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to update procurement',
        }),
        { status: response.status }
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement PUT route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements/${params.id}`, {
      method: 'DELETE',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to delete procurement',
        }),
        { status: response.status }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error in procurement DELETE route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\procurements\unbatched\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    // crop and lotNo are expected query parameters by the backend
    // searchParams will already contain them from the frontend request.

    const response = await fetch(`${BACKEND_URL}/api/procurements/unbatched?${searchParams.toString()}`, {
      method: 'GET',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to fetch unbatched procurements from backend' }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/procurements/unbatched route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

```

### apps\web\app\api\uploadthing\route.ts:
```
import { createRouteHandler } from 'uploadthing/next';
import { ourFileRouter } from './core';

export const { GET, POST } = createRouteHandler({
  router: ourFileRouter,
  config: {
    logLevel: 'Info',
  },
});

```

### apps\web\app\api\uploadthing\core.ts:
```
import { createUploadthing, type FileRouter } from 'uploadthing/next';
import imageCompression from 'browser-image-compression';

async function compressFile(file: File): Promise<File> {
  if (file.type.startsWith('image/')) {
    const options = {
      maxSizeMB: 0.15,
      maxWidthOrHeight: 1200,
      useWebWorker: true,
    };

    try {
      return await imageCompression(file, options);
    } catch (error) {
      console.error('Error compressing image:', error);
      return file;
    }
  } else if (file.type === 'application/pdf') {
    if (file.size <= 150 * 1024) {
      return file;
    }

    console.warn('PDF compression not supported directly. PDF exceeds 150KB limit:', file.name);
    return file;
  }

  return file;
}

const f = createUploadthing({
  errorFormatter: err => {
    console.log('Error uploading file', err.message);
    console.log('- Above error caused this: ', err.cause);
    return {
      message: err.message,
    };
  },
});

export const ourFileRouter: FileRouter = {
  profilePicture: f({ image: { maxFileSize: '1024KB', maxFileCount: 1 } })
    .middleware(async ({ req, files }) => {
      console.log('Middleware running for profilePicture');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Profile picture upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  aadharDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for aadharDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Aadhar document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  bankDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for bankDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Bank document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  landDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for landDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Land document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;

```

### apps\web\app\hooks\use-debounce.ts:
```
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

```

### apps\web\app\hooks\use-local-storage.ts:
```
import * as React from 'react';

export function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = React.useState<T>(() => {
    try {
      if (typeof window === 'undefined') return initialValue;

      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Error reading localStorage key:', error);
      return initialValue;
    }
  });

  const setValue = (value: T) => {
    try {
      setStoredValue(value);
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(value));
      }
    } catch (error) {
      console.error('Error setting localStorage key:', error);
    }
  };

  return [storedValue, setValue];
}

```

### apps\web\app\(auth)\layout.tsx:
```
import type React from 'react';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { ThemeProvider } from '../providers/theme-provider';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Login - Acme Inc.',
  description: 'Login to your Acme Inc. account',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

```

### apps\web\app\(auth)\login\page.tsx:
```
import { LoginForm } from '@/app/components/login-form';

export default function LoginPage() {
  return (
    <div className="grid min-h-screen lg:grid-cols-2">
      <div className="flex flex-col gap-6 p-6 md:p-10 bg-background">
        <div className="flex justify-center gap-2 md:justify-start">
          <a href="#" className="flex items-center gap-2 font-medium text-primary hover:underline">
            <span className="text-lg font-semibold">Chaya Inc</span>
          </a>
        </div>

        <div className="flex flex-1 items-center justify-center">
          <div className="w-full max-w-sm">
            <LoginForm />
          </div>
        </div>
      </div>

      <div className="relative hidden lg:block bg-muted">
        {/* Add any background image or content here if needed */}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\layout.tsx:
```
'use client';

import React, { useEffect } from 'react';
import { ThemeProvider } from '@/app/providers/theme-provider';
import { AuthProvider, useAuth } from '@/app/providers/auth-provider';
import { SidebarProvider } from '@workspace/ui/components/sidebar';
import { AppSidebar } from '../components/layout/app-sidebar';
import { FarmersCacheProvider } from './farmers/context/farmer-cache-context';
import { useRouter, usePathname } from 'next/navigation'; // Import usePathname
import { motion } from 'framer-motion';
import { Toaster } from 'sonner';

// Content that requires authentication and role checks
function AuthenticatedContent({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    if (!loading && !user) {
      // This case should ideally be handled by middleware redirecting to /login
      // but as a fallback.
      router.push('/login');
      return;
    }

    if (!loading && user) {
      // Staff-specific redirections
      if (user.role === 'STAFF') {
        if (pathname.startsWith('/staff') || pathname.startsWith('/dashboard')) {
          router.push('/farmers'); // Default page for staff
        }
      }
      // Admin specific: can access anything in dashboard layout.
    }
  }, [user, loading, router, pathname]);

  // Render null or a loading indicator if still loading or if user is null and redirecting
  if (loading || (!user && pathname !== '/login')) {
    return <div className="flex h-screen w-screen items-center justify-center">Loading application...</div>;
  }

  // If user is STAFF and tries to access restricted pages, they would have been redirected.
  // So, if we reach here, they are allowed (or an Admin).
  if (user?.role === 'STAFF' && (pathname.startsWith('/staff') || pathname.startsWith('/dashboard'))) {
    return null; // Or a specific "Access Denied" component for staff
  }

  return (
    <div className="flex h-screen overflow-hidden bg-gray-100">
      <SidebarProvider>
        <AppSidebar className="h-screen" />
        <motion.div
          className="flex flex-col flex-1 overflow-hidden"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <div className="flex flex-1 flex-col p-4 overflow-auto">{children}</div>
        </motion.div>
      </SidebarProvider>
    </div>
  );
}

export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem disableTransitionOnChange>
      <AuthProvider>
        <FarmersCacheProvider>
          <AuthenticatedContent>{children}</AuthenticatedContent>
        </FarmersCacheProvider>
      </AuthProvider>
      <Toaster richColors closeButton />
    </ThemeProvider>
  );
}

```

### apps\web\app\(dashboard)\farmers\page.tsx:
```
import { Suspense } from 'react';
import FarmersHeader from './components/farmers-header';
import Search from './components/search';
import FarmersTable from './components/farmers-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { FarmersCacheProvider } from './context/farmer-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
  }>;
}

export default async function FarmersPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;

  return (
    <FarmersCacheProvider>
      <div className="space-y-6 p-4">
        <FarmersHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Enter farmer name, batch code, village" />
        </div>

        <Suspense key={query + currentPage.toString()} fallback={<Loading />}>
          <FarmersTableWithCache query={query} currentPage={currentPage} />
        </Suspense>
      </div>
    </FarmersCacheProvider>
  );
}

async function FarmersTableWithCache({ query, currentPage }: { query: string; currentPage: number }) {
  return (
    <>
      <FarmersTable query={query} currentPage={currentPage} />
      <PaginationWithCache query={query} />
    </>
  );
}

async function PaginationWithCache({ query }: { query: string }) {
  return <Pagination query={query} />;
}

```

### apps\web\app\(dashboard)\farmers\loading.tsx:
```
import { Skeleton } from '@workspace/ui/components/skeleton';

export default function Loading() {
  return (
    <div className="w-full">
      {/* Header skeleton */}
      <div className="flex items-center justify-between">
        <Skeleton className="h-8 w-64" />
        <div className="flex gap-2">
          <Skeleton className="h-9 w-32" />
          <Skeleton className="h-9 w-32" />
        </div>
      </div>

      {/* Search skeleton */}
      <div className="mt-6 flex items-center justify-between gap-2">
        <Skeleton className="h-10 w-96" />
        <Skeleton className="h-9 w-28" />
      </div>

      {/* Table skeleton */}
      <div className="mt-6 space-y-4">
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4">
            <div className="flex h-full items-center">
              {Array.from({ length: 6 }).map((_, i) => (
                <Skeleton key={i} className="h-4 w-40 mx-4" />
              ))}
            </div>
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4">
              <div className="flex items-center">
                {Array.from({ length: 6 }).map((_, j) => (
                  <Skeleton key={j} className="h-4 w-40 mx-4" />
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Pagination skeleton */}
      <div className="mt-8 flex items-center justify-center gap-1">
        <Skeleton className="h-9 w-9" />
        {Array.from({ length: 5 }).map((_, i) => (
          <Skeleton key={i} className="h-9 w-9 mx-1" />
        ))}
        <Skeleton className="h-9 w-9" />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-details-dialog.tsx:
```
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@workspace/ui/components/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { formatDate } from '../lib/utils';
import { ExternalLink } from 'lucide-react';
import { FarmerWithRelations } from '../lib/types';

interface FarmerDetailsDialogProps {
  farmer: FarmerWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function FarmerDetailsDialog({ farmer, open, onOpenChange }: FarmerDetailsDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>Farmer Details: {farmer.name}</DialogTitle>
        </DialogHeader>

        <Tabs defaultValue="personal" className="mt-4">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="personal">Personal Info</TabsTrigger>
            <TabsTrigger value="bank">Bank Details</TabsTrigger>
            <TabsTrigger value="documents">Documents</TabsTrigger>
          </TabsList>

          {/* Personal Information Tab */}
          <TabsContent value="personal" className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <InfoItem label="Survey Number" value={farmer.surveyNumber} />
              <InfoItem label="Name" value={farmer.name} />
              <InfoItem label="Gender" value={farmer.gender} />
              <InfoItem label="Relationship" value={farmer.relationship} />
              <InfoItem label="Community" value={farmer.community} />
              <InfoItem label="Aadhar Number" value={farmer.aadharNumber} />
              <InfoItem label="Date of Birth" value={formatDate(farmer.dateOfBirth)} />
              <InfoItem label="Age" value={farmer.age.toString()} />
              <InfoItem label="Contact Number" value={farmer.contactNumber} />
              <InfoItem label="State" value={farmer.state} />
              <InfoItem label="District" value={farmer.district} />
              <InfoItem label="Mandal" value={farmer.mandal} />
              <InfoItem label="Village" value={farmer.village} />
              <InfoItem label="Panchayath" value={farmer.panchayath} />
            </div>
          </TabsContent>

          {/* Bank Details Tab */}
          <TabsContent value="bank" className="space-y-4">
            {farmer.bankDetails ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <InfoItem label="Bank Name" value={farmer.bankDetails.bankName} />
                <InfoItem label="Branch Name" value={farmer.bankDetails.branchName} />
                <InfoItem label="IFSC Code" value={farmer.bankDetails.ifscCode} />
                <InfoItem label="Account Number" value={farmer.bankDetails.accountNumber} />
                <InfoItem label="Bank Code" value={farmer.bankDetails.bankCode} />
                <InfoItem label="Address" value={farmer.bankDetails.address} />
              </div>
            ) : (
              <p className="text-muted-foreground text-center py-4">No bank details available</p>
            )}
          </TabsContent>

          {/* Documents Tab */}
          <TabsContent value="documents" className="space-y-4">
            {farmer.documents ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <DocumentLink label="Profile Picture" url={farmer.documents.profilePicUrl} />
                <DocumentLink label="Aadhar Document" url={farmer.documents.aadharDocUrl} />
                <DocumentLink label="Bank Document" url={farmer.documents.bankDocUrl} />

                {farmer.fields && farmer.fields.length > 0 && (
                  <div className="col-span-2 mt-4">
                    <h3 className="text-lg font-medium mb-2">Field Documents</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {farmer.fields.map((field, index) => (
                        <DocumentLink
                          key={field.id}
                          label={`Field ${index + 1} Document`}
                          url={field.landDocumentUrl}
                        />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <p className="text-muted-foreground text-center py-4">No documents available</p>
            )}
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}

// Helper component for info items
function InfoItem({ label, value }: { label: string; value: string }) {
  return (
    <div className="space-y-1">
      <p className="text-sm font-medium text-muted-foreground">{label}</p>
      <p className="text-sm">{value || 'N/A'}</p>
    </div>
  );
}

// Helper component for document links
function DocumentLink({ label, url }: { label: string; url: string }) {
  if (!url) return null;

  return (
    <div className="space-y-1">
      <p className="text-sm font-medium text-muted-foreground">{label}</p>
      <a
        href={url}
        target="_blank"
        rel="noopener noreferrer"
        className="text-sm text-blue-600 hover:underline flex items-center gap-1"
      >
        View Document <ExternalLink className="h-3 w-3" />
      </a>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\search.tsx:
```
'use client';

import { useSearchParams, usePathname, useRouter } from 'next/navigation';
import { useDebouncedCallback } from 'use-debounce';
import { Input } from '@workspace/ui/components/input';
import { Search as SearchIcon } from 'lucide-react';

export default function Search({ placeholder = 'Search farmers...' }: { placeholder?: string }) {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  const handleSearch = useDebouncedCallback((term: string) => {
    const params = new URLSearchParams(searchParams);

    params.set('page', '1');

    if (term) {
      params.set('query', term);
    } else {
      params.delete('query');
    }

    replace(`${pathname}?${params.toString()}`);
  }, 300);

  return (
    <div className="relative w-full">
      <SearchIcon className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
      <Input
        type="text"
        placeholder={placeholder}
        onChange={e => handleSearch(e.target.value)}
        defaultValue={searchParams.get('query')?.toString()}
        className="pl-9"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmers-table.tsx:
```
'use client';

import {
  flexRender,
  getCoreRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getPaginationRowModel,
  useReactTable,
} from '@tanstack/react-table';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { columns, defaultVisibleColumns } from '../lib/columns';
import { ColumnFilter } from './column-filter';
import { useState, useEffect } from 'react';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { useAuth } from '@/app/providers/auth-provider';
import { FarmerContextMenu } from './farmer-context-menu';
import { FarmerDetailsDialog } from './farmer-details-dialog';
import { FarmerFormDialog } from './farmer-form-dialog';
import { bulkDeleteFarmers } from '../lib/actions';
import { Button } from '@workspace/ui/components/button';
import { RefreshCw, TrashIcon } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { toast } from 'sonner';
import { useFarmersCache } from '../context/farmer-cache-context';
import { FarmerWithRelations } from '../lib/types';

interface FarmersTableProps {
  query: string;
  currentPage: number;
}

export default function FarmersTable({ query, currentPage }: FarmersTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchFarmers, prefetchPages, refreshCurrentPage } = useFarmersCache();

  const [farmers, setFarmers] = useState<FarmerWithRelations[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [viewingFarmer, setViewingFarmer] = useState<FarmerWithRelations | null>(null);
  const [editingFarmer, setEditingFarmer] = useState<FarmerWithRelations | null>(null);
  const [showViewDialog, setShowViewDialog] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showBulkDeleteDialog, setShowBulkDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const [rowSelection, setRowSelection] = useState({});

  const [columnVisibility, setColumnVisibility] = useState(() => {
    const initialVisibility: Record<string, boolean> = {};
    defaultVisibleColumns.forEach(col => {
      initialVisibility[col] = true;
    });
    return initialVisibility;
  });

  const loadData = async () => {
    setLoading(true);
    try {
      const data = await fetchFarmers(currentPage, query);
      setFarmers(data);

      const pagesToPrefetch = [];
      if (currentPage > 1) pagesToPrefetch.push(currentPage - 1);
      if (currentPage < 100) pagesToPrefetch.push(currentPage + 1);
      if (pagesToPrefetch.length > 0) {
        prefetchPages(Math.min(...pagesToPrefetch), Math.max(...pagesToPrefetch), query);
      }
    } catch (error) {
      toast.error("Failed to fetch farmers' data. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    if (refreshing) return;

    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPage(currentPage, query);
      setFarmers(freshData);
      toast.success('Data refreshed successfully');
      setRowSelection({});
    } catch (error) {
      toast.error('Failed to refresh data. Please try again.');
    } finally {
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadData();
  }, [fetchFarmers, prefetchPages, currentPage, query]);

  const table = useReactTable({
    data: farmers,
    columns,
    state: {
      columnVisibility,
      rowSelection,
    },
    enableRowSelection: isAdmin,
    onRowSelectionChange: setRowSelection,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  const handleViewDetails = (farmer: FarmerWithRelations) => {
    setViewingFarmer(farmer);
    setShowViewDialog(true);
  };

  const handleEditFarmer = (farmer: FarmerWithRelations) => {
    if (isAdmin) {
      setEditingFarmer(farmer);
      setShowEditDialog(true);
    } else {
      toast.error('You do not have permission to edit farmers.');
    }
  };

  const handleBulkDelete = async () => {
    setIsDeleting(true);
    try {
      const selectedFarmerIds = Object.keys(rowSelection)
        .map(index => {
          const idx = parseInt(index);
          return idx >= 0 && idx < farmers.length && farmers[idx] ? farmers[idx].id : null;
        })
        .filter((id): id is number => id !== null);

      if (selectedFarmerIds.length === 0) {
        toast.error('No farmers selected for deletion.');
        setShowBulkDeleteDialog(false);
        return;
      }

      const result = await bulkDeleteFarmers(selectedFarmerIds);

      if (result.success) {
        toast.success('Farmers deleted successfully.');
        await handleRefresh();
      } else {
        toast.error('Failed to delete farmers. Please try again.');
      }

      setShowBulkDeleteDialog(false);
    } catch (error) {
      toast.error('Failed to delete farmers. An unexpected error occurred.');
    } finally {
      setIsDeleting(false);
    }
  };

  useEffect(() => {
    const handleViewFarmerEvent = (e: CustomEvent<{ farmer: FarmerWithRelations }>) => {
      handleViewDetails(e.detail.farmer);
    };
    const handleDataChangeEvent = () => {
      handleRefresh();
    };

    document.addEventListener('viewFarmer', handleViewFarmerEvent as EventListener);
    document.addEventListener('farmerDataChanged', handleDataChangeEvent as EventListener);

    return () => {
      document.removeEventListener('viewFarmer', handleViewFarmerEvent as EventListener);
      document.removeEventListener('farmerDataChanged', handleDataChangeEvent as EventListener);
    };
  }, [currentPage, query]);

  const selectedCount = Object.keys(rowSelection).length;

  if (loading && farmers.length === 0) {
    return (
      <div className="mt-6 space-y-4">
        <div className="flex justify-between items-center">
          <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
          <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4 flex items-center">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4 flex items-center">
              {Array.from({ length: 6 }).map((_, j) => (
                <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
              ))}
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-2">
          {isAdmin && selectedCount > 0 && (
            <div className="flex items-center gap-2">
              <span className="text-sm text-muted-foreground">{selectedCount} selected</span>
              <Button variant="destructive" size="sm" onClick={() => setShowBulkDeleteDialog(true)} className="h-8">
                <TrashIcon className="mr-2 h-4 w-4" />
                Delete Selected
              </Button>
            </div>
          )}

          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={refreshing || loading}
            className="h-8 ml-2"
          >
            <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
            {refreshing ? 'Refreshing...' : 'Refresh'}
          </Button>
        </div>
        <ColumnFilter table={table} />
      </div>
      <div className="rounded-md border overflow-x-auto">
        <ScrollArea className="h-[calc(100vh-350px)] w-full">
          <Table className="min-w-max">
            <TableHeader className="sticky top-0 bg-secondary">
              {table.getHeaderGroups().map(headerGroup => (
                <TableRow key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <TableHead key={header.id}>
                      {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                    </TableHead>
                  ))}
                </TableRow>
              ))}
            </TableHeader>
            <TableBody>
              {table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map(row => (
                  <FarmerContextMenu
                    key={row.id}
                    farmer={row.original}
                    onEdit={() => handleEditFarmer(row.original)}
                    isAdmin={isAdmin}
                  >
                    <TableRow
                      data-state={row.getIsSelected() && 'selected'}
                      onDoubleClick={() => handleViewDetails(row.original)}
                      className="cursor-pointer hover:bg-muted/50"
                    >
                      {row.getVisibleCells().map(cell => (
                        <TableCell key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</TableCell>
                      ))}
                    </TableRow>
                  </FarmerContextMenu>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={columns.length} className="h-24 text-center">
                    {loading || refreshing ? 'Loading...' : 'No farmers found.'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </ScrollArea>
      </div>

      {viewingFarmer && (
        <FarmerDetailsDialog farmer={viewingFarmer} open={showViewDialog} onOpenChange={setShowViewDialog} />
      )}

      {isAdmin && editingFarmer && (
        <FarmerFormDialog mode="edit" farmer={editingFarmer} open={showEditDialog} onOpenChange={setShowEditDialog} />
      )}

      <AlertDialog open={showBulkDeleteDialog} onOpenChange={setShowBulkDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete these farmers?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete {selectedCount} farmer records and all their
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-form-dialog.tsx:
```
'use client';

import { FarmerFormProvider } from '@/app/providers/farmer-form-provider';
import { FarmerWithRelations } from '../lib/types';
import { FarmerForm } from '@/app/components/farmer-form/farmer-form';
import { useEffect } from 'react';

interface FarmerFormDialogProps {
  mode: 'add' | 'edit';
  farmer?: FarmerWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function FarmerFormDialog({ mode, farmer, open, onOpenChange }: FarmerFormDialogProps) {
  const handleFormSuccess = () => {
    const dataChangedEvent = new CustomEvent('farmerDataChanged');
    document.dispatchEvent(dataChangedEvent);
  };

  useEffect(() => {
    const handleFormSubmitSuccess = () => {
      handleFormSuccess();
    };
    document.addEventListener('farmerFormSubmitSuccess', handleFormSubmitSuccess);
    return () => {
      document.removeEventListener('farmerFormSubmitSuccess', handleFormSubmitSuccess);
    };
  }, []);

  return (
    <FarmerFormProvider initialData={farmer} mode={mode}>
      <FarmerForm mode={mode} open={open} onOpenChange={onOpenChange} farmerId={farmer?.id} />
    </FarmerFormProvider>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\pagination.tsx:
```
'use client';

import Link from 'next/link';
import { usePathname, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { generatePagination } from '../lib/utils';
import clsx from 'clsx';
import { useEffect, useState } from 'react';
import { useFarmersCache } from '../context/farmer-cache-context';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
}

export default function Pagination({ query }: PaginationProps) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const currentPage = Number(searchParams.get('page') || 1);
  const { fetchTotalPages } = useFarmersCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query]);

  const allPages = generatePagination(currentPage, totalPages);

  const createPageURL = (pageNumber: string | number) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `${pathname}?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-center gap-1 mt-8">
      <Button
        variant="outline"
        size="icon"
        className={clsx(currentPage <= 1 && 'opacity-50 cursor-not-allowed')}
        disabled={currentPage <= 1}
        asChild={currentPage > 1}
      >
        {currentPage > 1 ? (
          <Link href={createPageURL(currentPage - 1)}>
            <ChevronLeft className="h-4 w-4" />
          </Link>
        ) : (
          <span>
            <ChevronLeft className="h-4 w-4" />
          </span>
        )}
      </Button>

      <div className="flex gap-1">
        {allPages.map((page, index) => {
          if (page === '...') {
            return (
              <Button key={`ellipsis-${index}`} variant="outline" size="icon" disabled className="cursor-default">
                ...
              </Button>
            );
          }

          const isCurrentPage = page === currentPage;

          return (
            <Button
              key={`page-${page}`}
              variant={isCurrentPage ? 'default' : 'outline'}
              size="icon"
              asChild={!isCurrentPage}
              className={clsx('h-9 w-9')}
            >
              {isCurrentPage ? <span>{page}</span> : <Link href={createPageURL(page)}>{page}</Link>}
            </Button>
          );
        })}
      </div>

      <Button
        variant="outline"
        size="icon"
        className={clsx(currentPage >= totalPages && 'opacity-50 cursor-not-allowed')}
        disabled={currentPage >= totalPages}
        asChild={currentPage < totalPages}
      >
        {currentPage < totalPages ? (
          <Link href={createPageURL(currentPage + 1)}>
            <ChevronRight className="h-4 w-4" />
          </Link>
        ) : (
          <span>
            <ChevronRight className="h-4 w-4" />
          </span>
        )}
      </Button>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\column-filter.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { SlidersHorizontal } from 'lucide-react';
import { Table } from '@tanstack/react-table';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-9">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          Columns
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[200px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => column.getCanHide() && column.id !== 'select')
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id.replace(/([A-Z])/g, ' $1').toLowerCase()}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-context-menu.tsx:
```
'use client';

import React, { useState } from 'react';
import { Farmer } from '@chaya/shared';
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuSeparator,
  ContextMenuTrigger,
} from '@workspace/ui/components/context-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Eye, Pencil, Trash2 } from 'lucide-react';
import { deleteFarmer } from '../lib/actions';
import { toast } from 'sonner';

interface FarmerContextMenuProps {
  children: React.ReactNode;
  farmer: Farmer;
  onEdit: () => void;
  isAdmin: boolean;
}

export function FarmerContextMenu({ children, farmer, onEdit, isAdmin }: FarmerContextMenuProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    try {
      setIsDeleting(true);
      const result = await deleteFarmer(farmer.id);

      if (result.success) {
        toast.success('Farmer deleted', {
          description: `${farmer.name} has been successfully deleted.`,
        });

        const dataChangedEvent = new CustomEvent('farmerDataChanged');
        document.dispatchEvent(dataChangedEvent);
      } else {
        toast.error('Error', {
          description: result.error || 'Failed to delete farmer.',
        });
      }

      setShowDeleteDialog(false);
    } catch (error) {
      toast.error('Error', {
        description: 'An unexpected error occurred while deleting the farmer.',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <ContextMenu>
        <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>
        <ContextMenuContent className="w-48">
          <ContextMenuItem onClick={() => window.open(`/dashboard/farmers/${farmer.id}`, '_blank')}>
            <Eye className="mr-2 h-4 w-4" />
            View Details
          </ContextMenuItem>

          {isAdmin && (
            <>
              <ContextMenuSeparator />
              <ContextMenuItem onClick={onEdit}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit Farmer
              </ContextMenuItem>
              <ContextMenuItem
                onClick={() => setShowDeleteDialog(true)}
                className="text-destructive focus:text-destructive"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete Farmer
              </ContextMenuItem>
            </>
          )}
        </ContextMenuContent>
      </ContextMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete this farmer?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the farmer record and all associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmers-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useState } from 'react';
import { FarmerFormDialog } from './farmer-form-dialog';
import { useAuth } from '@/app/providers/auth-provider';

export default function FarmersHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';

  const [showAddDialog, setShowAddDialog] = useState(false);

  const handleExport = () => {
    console.log('Export data clicked');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Farmer Dashboard</h1>
        <p className="text-gray-600">Manage and track farmer information</p>
      </div>

      <div className="flex items-center gap-2">
        {/* {isAdmin && (
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            className="h-9 bg-purple-500 text-white hover:bg-purple-600 hover:text-white"
          >
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )} */}

        <Button
          size="sm"
          onClick={() => setShowAddDialog(true)}
          className="h-9 bg-green-500 text-white hover:bg-green-600"
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Farmer
        </Button>

        <FarmerFormDialog mode="add" open={showAddDialog} onOpenChange={setShowAddDialog} />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\lib\actions.ts:
```
'use server';

import { revalidatePath } from 'next/cache';
import { Gender, Relationship, prisma } from '@chaya/shared';
import { ITEMS_PER_PAGE } from './constants';

interface FarmerFormData {
  surveyNumber: string;
  name: string;
  relationship: Relationship;
  gender: Gender;
  community: string;
  aadharNumber: string;
  state: string;
  district: string;
  mandal: string;
  village: string;
  panchayath: string;
  dateOfBirth: string;
  age: number;
  contactNumber: string;
  bankDetails?: {
    ifscCode: string;
    bankName: string;
    branchName: string;
    accountNumber: string;
    address: string;
    bankCode: string;
  };
  documents?: {
    profilePicUrl: string;
    aadharDocUrl: string;
    bankDocUrl: string;
  };
  fields?: {
    areaHa: number;
    yieldEstimate: number;
    location: Record<string, any>;
    landDocumentUrl: string;
  }[];
}

export async function createFarmer(userId: number, formData: FarmerFormData) {
  try {
    const { bankDetails, documents, fields, ...farmerData } = formData;
    const dateOfBirth = new Date(farmerData.dateOfBirth);

    await prisma.farmer.create({
      data: {
        ...farmerData,
        dateOfBirth,
        createdById: userId,
        updatedById: userId,
        ...(bankDetails && {
          bankDetails: {
            create: bankDetails,
          },
        }),
        ...(documents && {
          documents: {
            create: documents,
          },
        }),
        ...(fields && {
          fields: {
            create: fields,
          },
        }),
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to create farmer:', error);
    return { error: 'Failed to create farmer. Please try again.' };
  }
}

export async function updateFarmer(userId: number, farmerId: number, formData: Partial<FarmerFormData>) {
  try {
    const { bankDetails, documents, fields, ...farmerData } = formData;
    const dateOfBirth = farmerData.dateOfBirth ? new Date(farmerData.dateOfBirth) : undefined;

    await prisma.farmer.update({
      where: { id: farmerId },
      data: {
        ...farmerData,
        ...(dateOfBirth && { dateOfBirth }),
        updatedById: userId,
        ...(bankDetails && {
          bankDetails: {
            upsert: {
              create: bankDetails,
              update: bankDetails,
            },
          },
        }),
        ...(documents && {
          documents: {
            upsert: {
              create: documents,
              update: documents,
            },
          },
        }),
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to update farmer:', error);
    return { error: 'Failed to update farmer. Please try again.' };
  }
}

export async function deleteFarmer(farmerId: number) {
  try {
    await prisma.farmer.delete({
      where: { id: farmerId },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to delete farmer:', error);
    return { error: 'Failed to delete farmer. Please try again.' };
  }
}

export async function bulkDeleteFarmers(farmerIds: number[]) {
  try {
    await prisma.farmer.deleteMany({
      where: {
        id: { in: farmerIds },
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to delete farmers:', error);
    return { error: 'Failed to delete farmers. Please try again.' };
  }
}

export async function exportFarmersData(query?: string) {
  try {
    const farmers = await prisma.farmer.findMany({
      where: query
        ? {
            OR: [
              { name: { contains: query, mode: 'insensitive' } },
              { aadharNumber: { contains: query, mode: 'insensitive' } },
              { surveyNumber: { contains: query, mode: 'insensitive' } },
            ],
          }
        : undefined,
      include: {
        bankDetails: true,
        fields: true,
      },
    });

    return {
      success: true,
      count: farmers.length,
      downloadUrl: `/api/export/farmers?timestamp=${Date.now()}`,
    };
  } catch (error) {
    console.error('Failed to export farmers data:', error);
    return { error: 'Failed to export farmers data. Please try again.' };
  }
}
//SelectedColumns is not used in the function, but it's included in the function signature for future use just adding for reference
export async function getFarmers({
  query = '',
  page = 1,
}: {
  query?: string;
  page?: number;
  selectedColumns?: string[];
}) {
  const offset = (page - 1) * ITEMS_PER_PAGE;

  try {
    const farmers = await prisma.farmer.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
      include: {
        bankDetails: true,
        documents: true,
        fields: true,
        createdBy: {
          select: {
            name: true,
          },
        },
      },
      take: ITEMS_PER_PAGE,
      skip: offset,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return farmers;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch farmers.');
  }
}

export async function getFarmerPages(query: string) {
  try {
    const count = await prisma.farmer.count({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
    });

    const totalPages = Math.ceil(count / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch total number of farmers.');
  }
}

```

### apps\web\app\(dashboard)\farmers\lib\data.ts:
```
import { prisma } from '@chaya/shared';

export const ITEMS_PER_PAGE = 10;

import { FarmerWithRelations } from './types';
//selectedColumns is not used in the function, but it is included in the function signature for future use
export async function getFarmers({
  query = '',
  page = 1,
}: {
  query?: string;
  page?: number;
  selectedColumns?: string[];
}): Promise<FarmerWithRelations[]> {
  const offset = (page - 1) * ITEMS_PER_PAGE;

  try {
    const farmers = await prisma.farmer.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
      include: {
        bankDetails: true,
        documents: true,
        fields: true,
        createdBy: {
          select: {
            name: true,
          },
        },
      },
      take: ITEMS_PER_PAGE,
      skip: offset,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return farmers as FarmerWithRelations[];
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch farmers.');
  }
}
// Count total farmers matching the query

export async function getFarmerPages(query: string) {
  try {
    const count = await prisma.farmer.count({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
    });

    const totalPages = Math.ceil(count / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch total number of farmers.');
  }
}

```

### apps\web\app\(dashboard)\farmers\lib\types.ts:
```
import { Farmer, BankDetails, FarmerDocuments, Field, User } from '@chaya/shared';

export interface FarmerWithRelations extends Farmer {
  bankDetails?: BankDetails | null;
  documents?: FarmerDocuments | null;
  fields?: Field[];
  createdBy?: Pick<User, 'name'>;
}

```

### apps\web\app\(dashboard)\farmers\lib\columns.tsx:
```
import { ColumnDef } from '@tanstack/react-table';
import { Checkbox } from '@workspace/ui/components/checkbox';
import { Button } from '@workspace/ui/components/button';
import { formatDate } from './utils';
import { Farmer } from '@chaya/shared';
import { Eye, FileUser } from 'lucide-react';

export const columns: ColumnDef<Farmer>[] = [
  {
    id: 'select',
    header: ({ table }) => {
      return (
        <Checkbox
          checked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && 'indeterminate')}
          onCheckedChange={value => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
        />
      );
    },
    cell: ({ row }) => {
      return (
        <Checkbox
          checked={row.getIsSelected()}
          onCheckedChange={value => row.toggleSelected(!!value)}
          aria-label="Select row"
        />
      );
    },
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: 'surveyNumber',
    header: 'Survey Number',
    cell: ({ row }) => <div>{row.getValue('surveyNumber')}</div>,
  },
  {
    accessorKey: 'name',
    header: 'Name',
    cell: ({ row }) => <div>{row.getValue('name')}</div>,
  },
  {
    accessorKey: 'gender',
    header: 'Gender',
    cell: ({ row }) => <div>{row.getValue('gender')}</div>,
  },
  {
    accessorKey: 'age',
    header: 'Age',
    cell: ({ row }) => <div>{row.getValue('age')}</div>,
  },
  {
    accessorKey: 'contactNumber',
    header: 'Contact',
    cell: ({ row }) => <div>{row.getValue('contactNumber')}</div>,
  },
  {
    accessorKey: 'aadharNumber',
    header: 'Aadhar Number',
    cell: ({ row }) => <div>{row.getValue('aadharNumber')}</div>,
  },
  {
    accessorKey: 'village',
    header: 'Village',
    cell: ({ row }) => <div>{row.getValue('village')}</div>,
  },
  {
    accessorKey: 'district',
    header: 'District',
    cell: ({ row }) => <div>{row.getValue('district')}</div>,
  },
  {
    accessorKey: 'state',
    header: 'State',
    cell: ({ row }) => <div>{row.getValue('state')}</div>,
  },
  {
    accessorKey: 'createdAt',
    header: 'Created At',
    cell: ({ row }) => <div>{formatDate(row.getValue('createdAt'))}</div>,
  },
  {
    id: 'actions',
    header: 'Documents',
    cell: ({ row }) => {
      const farmer = row.original;
      return (
        <div className="flex items-center justify-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0"
            onClick={e => {
              e.stopPropagation();
              const viewFarmerEvent = new CustomEvent('viewFarmer', {
                detail: { farmer },
              });
              document.dispatchEvent(viewFarmerEvent);
            }}
          >
            <span className="sr-only">View details</span>
            <FileUser className="h-4 w-4" />
          </Button>
        </div>
      );
    },
  },
];

export const defaultVisibleColumns = [
  'select',
  'surveyNumber',
  'name',
  'aadharNumber',
  'village',
  'district',
  'actions',
];

```

### apps\web\app\(dashboard)\farmers\lib\utils.ts:
```
import { Gender, Relationship } from '@prisma/client';

/**
 * Format a date object or string to a localized date string
 */
export function formatDate(date: Date | string): string {
  if (!date) return '';

  const d = typeof date === 'string' ? new Date(date) : date;

  return d.toLocaleDateString('en-IN', {
    day: 'numeric',
    month: 'short',
    year: 'numeric',
  });
}

/**
 * Generate pagination array for rendering page numbers
 */
export const generatePagination = (currentPage: number, totalPages: number) => {
  // If the total number of pages is 7 or less,
  // display all pages without any ellipsis
  if (totalPages <= 7) {
    return Array.from({ length: totalPages }, (_, i) => i + 1);
  }

  // If the current page is among the first 3 pages,
  // show the first 3, an ellipsis, and the last 2 pages
  if (currentPage <= 3) {
    return [1, 2, 3, '...', totalPages - 1, totalPages];
  }

  // If the current page is among the last 3 pages,
  // show the first 2, an ellipsis, and the last 3 pages
  if (currentPage >= totalPages - 2) {
    return [1, 2, '...', totalPages - 2, totalPages - 1, totalPages];
  }

  // If the current page is somewhere in the middle,
  // show the first page, an ellipsis, the current page and its neighbors,
  // another ellipsis, and the last page
  return [1, '...', currentPage - 1, currentPage, currentPage + 1, '...', totalPages];
};
export interface FarmerFormData {
  surveyNumber: string;
  name: string;
  relationship: Relationship;
  gender: Gender;
  community: string;
  aadharNumber: string;
  state: string;
  district: string;
  mandal: string;
  village: string;
  panchayath: string;
  dateOfBirth: string;
  age: number;
  contactNumber: string;
  bankDetails?: {
    ifscCode: string;
    bankName: string;
    branchName: string;
    accountNumber: string;
    address: string;
    bankCode: string;
  };
  documents?: {
    profilePicUrl: string;
    aadharDocUrl: string;
    bankDocUrl: string;
  };
  fields?: {
    areaHa: number;
    yieldEstimate: number;
    location: Record<string, object>;
    landDocumentUrl: string;
  }[];
}

```

### apps\web\app\(dashboard)\farmers\lib\constants.ts:
```
export const ITEMS_PER_PAGE = 10;

```

### apps\web\app\(dashboard)\farmers\lib\sidebar-cache.ts:
```
'use client';

import React from 'react';

const SIDEBAR_DATA_KEY = 'app_sidebar_data';
const SIDEBAR_TIMESTAMP_KEY = 'app_sidebar_timestamp';
const CACHE_TTL = 3600000; // 1 hour in milliseconds

export interface SidebarCacheItem {
  data: object;
  timestamp: number;
}

// Helper to check if we're in the browser
const isBrowser = typeof window !== 'undefined';

// Get sidebar data from cache
export function getSidebarCache<T>(): T | null {
  if (!isBrowser) return null;

  try {
    const cachedData = localStorage.getItem(SIDEBAR_DATA_KEY);
    const timestamp = localStorage.getItem(SIDEBAR_TIMESTAMP_KEY);

    if (!cachedData || !timestamp) return null;

    const parsedTimestamp = parseInt(timestamp);
    const now = Date.now();

    // Check if cache is still valid
    if (now - parsedTimestamp > CACHE_TTL) {
      clearSidebarCache();
      return null;
    }

    return JSON.parse(cachedData) as T;
  } catch (error) {
    console.error('Error reading sidebar cache:', error);
    return null;
  }
}

// Set sidebar data to cache
export function setSidebarCache<T>(data: T): void {
  if (!isBrowser) return;

  try {
    localStorage.setItem(SIDEBAR_DATA_KEY, JSON.stringify(data));
    localStorage.setItem(SIDEBAR_TIMESTAMP_KEY, Date.now().toString());
  } catch (error) {
    console.error('Error setting sidebar cache:', error);
  }
}

// Clear sidebar cache (used on logout)
export function clearSidebarCache(): void {
  if (!isBrowser) return;

  try {
    localStorage.removeItem(SIDEBAR_DATA_KEY);
    localStorage.removeItem(SIDEBAR_TIMESTAMP_KEY);
  } catch (error) {
    console.error('Error clearing sidebar cache:', error);
  }
}

// Custom hook for sidebar cache
export function useSidebarCache<T>(fetchFn: () => Promise<T>) {
  const [data, setData] = React.useState<T | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<Error | null>(null);

  React.useEffect(() => {
    async function loadData() {
      setLoading(true);

      try {
        // Try to get data from cache first
        const cachedData = getSidebarCache<T>();

        if (cachedData) {
          setData(cachedData);
          setLoading(false);
          return;
        }

        // If no cache, fetch fresh data
        const freshData = await fetchFn();
        setData(freshData);

        // Cache the new data
        setSidebarCache(freshData);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('An error occurred'));
      } finally {
        setLoading(false);
      }
    }

    loadData();
  }, [fetchFn]);

  return { data, loading, error };
}

```

### apps\web\app\(dashboard)\farmers\context\farmer-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import { getFarmers, getFarmerPages } from '../lib/actions';
import { FarmerWithRelations } from '../lib/types';
import { toast } from 'sonner';

interface FarmersCacheContextType {
  farmers: Record<string, FarmerWithRelations[]>;
  totalPages: Record<string, number>;
  fetchFarmers: (page: number, query: string) => Promise<FarmerWithRelations[]>;
  fetchTotalPages: (query: string) => Promise<number>;
  clearCache: () => void;
  prefetchPages: (startPage: number, endPage: number, query: string) => Promise<void>;
  refreshCurrentPage: (page: number, query: string) => Promise<FarmerWithRelations[]>;
}

const FarmersCacheContext = createContext<FarmersCacheContextType | undefined>(undefined);

export function FarmersCacheProvider({ children }: { children: React.ReactNode }) {
  const [farmers, setFarmers] = useState<Record<string, FarmerWithRelations[]>>({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});

  const createKey = useCallback((page: number, query: string) => `${query}:${page}`, []);

  const fetchFarmers = useCallback(
    async (page: number, query: string): Promise<FarmerWithRelations[]> => {
      const key = createKey(page, query);

      if (farmers[key]) {
        console.log(`Using cached data for page ${page}, query "${query}"`);
        return farmers[key];
      }

      console.log(`Fetching page ${page}, query "${query}" from server`);
      try {
        const data = (await getFarmers({ page, query })) as FarmerWithRelations[];
        setFarmers(prev => ({
          ...prev,
          [key]: data,
        }));
        return data;
      } catch (error) {
        toast.error('Failed to fetch farmers data from server.');
        throw error;
      }
    },
    [farmers, createKey]
  );

  const fetchTotalPages = useCallback(
    async (query: string): Promise<number> => {
      if (totalPages[query] !== undefined) {
        return totalPages[query];
      }

      try {
        const pages = await getFarmerPages(query);
        setTotalPages(prev => ({
          ...prev,
          [query]: pages,
        }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        throw error;
      }
    },
    [totalPages]
  );

  const prefetchPages = useCallback(
    async (startPage: number, endPage: number, query: string) => {
      console.log(`Prefetching pages ${startPage}-${endPage} for query "${query}"`);

      for (let page = startPage; page <= endPage; page++) {
        const key = createKey(page, query);

        if (farmers[key]) continue;

        try {
          const data = (await getFarmers({
            page,
            query,
          })) as FarmerWithRelations[];
          setFarmers(prev => ({
            ...prev,
            [key]: data,
          }));
        } catch (error) {
          console.error(`Error prefetching page ${page}:`, error);
          toast.error(`Failed to prefetch data for page ${page}.`);
        }
      }
    },
    [farmers, createKey]
  );

  const refreshCurrentPage = useCallback(
    async (page: number, query: string): Promise<FarmerWithRelations[]> => {
      const key = createKey(page, query);

      console.log(`Force refreshing page ${page}, query "${query}" from server`);
      try {
        const data = (await getFarmers({
          page,
          query,
        })) as FarmerWithRelations[];
        setFarmers(prev => ({
          ...prev,
          [key]: data,
        }));
        fetchTotalPages(query);
        return data;
      } catch (error) {
        console.error(`Error refreshing page ${page}:`, error);
        toast.error(`Failed to refresh data for page ${page}.`);
        throw error;
      }
    },
    [createKey, fetchTotalPages]
  );

  const clearCache = useCallback(() => {
    setFarmers({});
    setTotalPages({});
    toast.success('Cache cleared successfully.');
  }, []);

  const value = {
    farmers,
    totalPages,
    fetchFarmers,
    fetchTotalPages,
    clearCache,
    prefetchPages,
    refreshCurrentPage,
  };

  return <FarmersCacheContext.Provider value={value}>{children}</FarmersCacheContext.Provider>;
}

export function useFarmersCache() {
  const context = useContext(FarmersCacheContext);

  if (context === undefined) {
    throw new Error('useFarmersCache must be used within a FarmersCacheProvider');
  }

  return context;
}

```

### apps\web\app\(dashboard)\dashboard\page.tsx:
```
'use client';

import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell, Legend } from 'recharts';

const lineGraphData = [
  { name: 'Sep', value: 80 },
  { name: 'Oct', value: 100 },
  { name: 'Nov', value: 108 },
  { name: 'Dec', value: 95 },
  { name: 'Jan', value: 90 },
  { name: 'Feb', value: 92 },
];

const pieChartData = [
  { name: 'Ginger', value: 15 },
  { name: 'Coffee', value: 30 },
  { name: 'Turmeric', value: 25 },
  { name: 'Your Files', value: 63 },
];

const COLORS = ['#FFB703', '#FB8500', '#219EBC', '#8ECAE6'];

export default function DashboardPage() {
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="space-y-2">
        <h1 className="text-2xl font-semibold">Farmer Details</h1>
        <p className="text-gray-600">Manage and track crop procurement information</p>
      </div>

      {/* Analytics Section */}
      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        {/* Procurement Section */}
        <div className="p-4 bg-white rounded shadow">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-bold">Procurement</h2>
            <button className="text-sm text-gray-500 hover:underline">Month</button>
          </div>
          <p className="text-2xl font-bold text-green-600">2000.00 kg</p>
          <div className="mt-4">
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={lineGraphData}>
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="value" stroke="#4CAF50" strokeWidth={2} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Crop Section */}
        <div className="p-4 bg-white rounded shadow">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-bold">Crop</h2>
            <button className="text-sm text-gray-500 hover:underline">Month</button>
          </div>
          <div className="mt-4">
            <ResponsiveContainer width="100%" height={200}>
              <PieChart>
                <Pie
                  data={pieChartData}
                  dataKey="value"
                  nameKey="name"
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#8884d8"
                >
                  {pieChartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Legend />
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Top Performing Staff Section */}
      <div className="p-4 bg-white rounded shadow">
        <h2 className="text-lg font-bold">Top Performing Staff</h2>
        {/* Table remains unchanged */}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\page.tsx:
```
import { Suspense } from 'react';
import ProcessingBatchesHeader from './components/processing-batches-header';
import Search from './components/search';
import ProcessingBatchesTable from './components/processing-batches-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { ProcessingBatchCacheProvider } from './context/processing-batch-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
    status?: string; // For filtering by latest stage status
  }>;
}

export default async function ProcessingBatchesPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;
  const status = params?.status || '';

  return (
    <ProcessingBatchCacheProvider>
      <div className="space-y-6 p-4">
        <ProcessingBatchesHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Search by Batch Code, Crop..." />
        </div>
        <Suspense key={query + currentPage.toString() + status} fallback={<Loading />}>
          <ProcessingBatchesTable query={query} currentPage={currentPage} statusFilter={status} />
          <Pagination query={query} statusFilter={status} />
        </Suspense>
      </div>
    </ProcessingBatchCacheProvider>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\loading.tsx:
```
export default function Loading() {
  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
        <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
      </div>
      <div className="rounded-md border">
        <div className="h-12 border-b bg-secondary px-4 flex items-center">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
          ))}
        </div>
        {Array.from({ length: 10 }).map((_, i) => (
          <div key={i} className="border-b px-4 py-4 flex items-center">
            {Array.from({ length: 6 }).map((_, j) => (
              <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\search.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Input } from '@workspace/ui/components/input';
import { useEffect, useState } from 'react';
import { useDebounce } from '@/app/hooks/use-debounce';

interface SearchProps {
  placeholder?: string;
}

export default function Search({ placeholder }: SearchProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [searchTerm, setSearchTerm] = useState(searchParams.get('query') || '');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    const params = new URLSearchParams(searchParams);

    if (debouncedSearchTerm) {
      params.set('query', debouncedSearchTerm);
    } else {
      params.delete('query');
    }

    params.set('page', '1');
    router.push(`?${params.toString()}`);
  }, [debouncedSearchTerm, router, searchParams]);

  return (
    <div className="relative w-full md:w-80">
      <Input
        placeholder={placeholder || 'Search...'}
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        className="w-full"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\processing-batches-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';

export default function ProcessingBatchesHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const router = useRouter();

  const handleExport = () => {
    // TODO: Implement export functionality for processing batches
    console.log('Export processing batches data clicked');
    toast.info('Export functionality for processing batches is not yet implemented.');
  };

  const handleAddBatch = () => {
    router.push('/processing-batches/add');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Processing Batches</h1>
        <p className="text-gray-600">Manage and track multi-stage crop processing batches.</p>
      </div>

      <div className="flex items-center gap-2">
        {isAdmin && (
          <Button variant="outline" size="sm" onClick={handleExport} className="h-9">
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )}
        <Button size="sm" onClick={handleAddBatch} className="h-9 bg-green-500 text-white hover:bg-green-600">
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Processing Batch
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\pagination.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { useProcessingBatchCache } from '../context/processing-batch-cache-context';
import { useEffect, useState } from 'react';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
  statusFilter: string;
}

export default function Pagination({ query, statusFilter }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { fetchTotalPages } = useProcessingBatchCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  const currentPage = Number(searchParams.get('page') || '1');

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query, statusFilter);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query, statusFilter]);

  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-between px-2 mt-4">
      <div className="text-sm text-muted-foreground">
        Page {currentPage} of {totalPages}
      </div>
      <div className="flex items-center space-x-2">
        <Button variant="outline" size="icon" onClick={() => router.push(createPageURL(1))} disabled={currentPage <= 1}>
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage - 1))}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage + 1))}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(totalPages))}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\column-filter.tsx:
```
'use client';

import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { Button } from '@workspace/ui/components/button';
import { SlidersHorizontal } from 'lucide-react';
import type { Table } from '@tanstack/react-table';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-8">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          View
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[180px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => typeof column.accessorFn !== 'undefined' && column.getCanHide())
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\processing-batches-table.tsx:
```
'use client';

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  ColumnFiltersState,
  getFilteredRowModel,
  SortingState,
  getSortedRowModel,
} from '@tanstack/react-table';
import { batchColumns } from '../lib/columns-batch';
import type { ProcessingBatchWithSummary, ProcessingStageWithDrying } from '../lib/types';
import { useProcessingBatchCache } from '../context/processing-batch-cache-context';

import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Button } from '@workspace/ui/components/button';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { toast } from 'sonner';
import { RefreshCw, Eye, Wind, CheckSquare, ShoppingCart, Layers, Trash2, ArrowUpDown } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { ColumnFilter } from '@/app/(dashboard)/procurements/components/column-filter'; // Reusable
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import axios from 'axios'; // For delete operations if not using server actions

// Import Dialogs
import { BatchDetailsDialog } from './dialogs/batch-details-dialog';
import { AddDryingDialog } from './dialogs/add-drying-dialog';
import { FinalizeStageDialog } from './dialogs/finalize-stage-dialog';
import { StartNextStageDialog } from './dialogs/start-next-stage-dialog';
import { RecordSaleDialog } from './dialogs/record-sale-dialog';

interface ProcessingBatchesTableProps {
  query: string;
  currentPage: number;
  statusFilter: string;
}

export default function ProcessingBatchesTable({ query, currentPage, statusFilter }: ProcessingBatchesTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchProcessingBatchesSummary, refreshCurrentPageSummary, clearBatchDetailCache } = useProcessingBatchCache();

  const [records, setRecords] = useState<ProcessingBatchWithSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [sorting, setSorting] = React.useState<SortingState>([{ id: 'createdAt', desc: true }]); // Default sort
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);
  const [columnVisibility, setColumnVisibility] = useState({});

  const [selectedBatchForAction, setSelectedBatchForAction] = useState<ProcessingBatchWithSummary | null>(null);
  const [showDetailsDialog, setShowDetailsDialog] = useState(false);
  const [showAddDryingDialog, setShowAddDryingDialog] = useState(false);
  const [showFinalizeStageDialog, setShowFinalizeStageDialog] = useState(false);
  const [showStartNextStageDialog, setShowStartNextStageDialog] = useState(false);
  const [showRecordSaleDialog, setShowRecordSaleDialog] = useState(false);
  const [showDeleteBatchDialog, setShowDeleteBatchDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const fetchData = useCallback(
    async (page: number, q: string, status: string) => {
      setLoading(true);
      try {
        const data = await fetchProcessingBatchesSummary(page, q, status);
        setRecords(data);
      } catch (error) {
        toast.error('Failed to load processing batches.');
      } finally {
        setLoading(false);
      }
    },
    [fetchProcessingBatchesSummary]
  );

  const handleRefresh = useCallback(async () => {
    if (refreshing) return;
    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPageSummary(currentPage, query, statusFilter);
      setRecords(freshData);
      toast.success('Data refreshed successfully');
      // Clear specific detail cache if a modified batch was in it
      if (selectedBatchForAction) clearBatchDetailCache(selectedBatchForAction.id);
    } catch (error) {
      toast.error('Failed to refresh data.');
    } finally {
      setRefreshing(false);
    }
  }, [
    refreshing,
    currentPage,
    query,
    statusFilter,
    refreshCurrentPageSummary,
    selectedBatchForAction,
    clearBatchDetailCache,
  ]);

  useEffect(() => {
    fetchData(currentPage, query, statusFilter);
  }, [fetchData, currentPage, query, statusFilter]);

  useEffect(() => {
    const handleDataChange = () => handleRefresh();
    document.addEventListener('processingBatchDataChanged', handleDataChange);
    return () => document.removeEventListener('processingBatchDataChanged', handleDataChange);
  }, [handleRefresh]);

  const table = useReactTable({
    data: records,
    columns: batchColumns,
    state: { sorting, columnFilters, columnVisibility },
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    manualPagination: true, // Since pagination is handled by URL params & cache context
  });

  const openDialog = (
    dialogSetter: React.Dispatch<React.SetStateAction<boolean>>,
    batch: ProcessingBatchWithSummary
  ) => {
    setSelectedBatchForAction(batch);
    dialogSetter(true);
  };

  const confirmDeleteBatch = async () => {
    if (!selectedBatchForAction) return;
    setIsDeleting(true);
    try {
      await axios.delete(`/api/processing-batches/${selectedBatchForAction.id}`, { withCredentials: true });
      toast.success(`Batch ${selectedBatchForAction.batchCode} deleted.`);
      setShowDeleteBatchDialog(false);
      handleRefresh(); // Refresh list
    } catch (error: any) {
      toast.error(error.response?.data?.error || 'Failed to delete batch.');
    } finally {
      setIsDeleting(false);
    }
  };

  // Calculate available for sale from the specific stage's yield (quantityAfterProcess)
  // This needs the full batch details to accurately determine prior sales *from that specific stage*.
  // For simplicity in table actions, we pass what the LATEST stage could offer.
  // A more precise calculation needs the detail dialog logic.
  const getAvailableForSaleFromLatestFinishedStage = (batch: ProcessingBatchWithSummary): number => {
    if (batch.latestStageSummary?.status === 'FINISHED') {
      // This is a simplification. Backend sales check is more robust.
      // This `quantityAfterProcess` is the *yield of that stage*. Sales reduce the overall batch quantity.
      return batch.latestStageSummary.quantityAfterProcess || 0;
    }
    return 0;
  };

  if (loading && records.length === 0) {
    return <div className="p-4 text-center">Loading processing batches...</div>; // Simplified loading state
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <Button variant="outline" size="sm" onClick={handleRefresh} disabled={refreshing || loading} className="h-8">
          <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
          {refreshing ? 'Refreshing...' : 'Refresh'}
        </Button>
        <ColumnFilter table={table} />
      </div>
      <ScrollArea className="rounded-md border h-[calc(100vh-350px)] w-full">
        {' '}
        {/* Adjust height as needed */}
        <Table>
          <TableHeader className="sticky top-0 bg-secondary z-10">
            {table.getHeaderGroups().map(headerGroup => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map(header => (
                  <TableHead key={header.id} className="whitespace-nowrap">
                    {header.isPlaceholder ? null : (
                      <div
                        className={header.column.getCanSort() ? 'cursor-pointer select-none flex items-center' : ''}
                        onClick={header.column.getToggleSortingHandler()}
                      >
                        {flexRender(header.column.columnDef.header, header.getContext())}
                        {header.column.getCanSort() && <ArrowUpDown className="ml-2 h-4 w-4 opacity-50" />}
                      </div>
                    )}
                  </TableHead>
                ))}
                <TableHead className="sticky right-0 bg-secondary z-10">Actions</TableHead>
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map(row => (
                <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'}>
                  {row.getVisibleCells().map(cell => (
                    <TableCell key={cell.id} className="whitespace-nowrap">
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                  <TableCell className="sticky right-0 bg-background z-0 flex items-center gap-1 py-1.5">
                    {' '}
                    {/* bg-background for row scroll */}
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => openDialog(setShowDetailsDialog, row.original)}
                      title="View Details"
                    >
                      <Eye className="h-4 w-4" />
                    </Button>
                    {row.original.latestStageSummary?.status === 'IN_PROGRESS' && (
                      <>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => openDialog(setShowAddDryingDialog, row.original)}
                          title="Add Drying Data"
                        >
                          <Wind className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => openDialog(setShowFinalizeStageDialog, row.original)}
                          title="Finalize Stage"
                        >
                          <CheckSquare className="h-4 w-4" />
                        </Button>
                      </>
                    )}
                    {row.original.latestStageSummary?.status === 'FINISHED' && (
                      <>
                        {(row.original.latestStageSummary.quantityAfterProcess || 0) >
                          0 /* Can only start next stage if there is yield */ && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => openDialog(setShowStartNextStageDialog, row.original)}
                            title="Start Next Stage"
                          >
                            <Layers className="h-4 w-4" />
                          </Button>
                        )}
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => openDialog(setShowRecordSaleDialog, row.original)}
                          title="Record Sale"
                          disabled={getAvailableForSaleFromLatestFinishedStage(row.original) <= 0}
                        >
                          <ShoppingCart className="h-4 w-4" />
                        </Button>
                      </>
                    )}
                    {isAdmin && (
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={() => openDialog(setShowDeleteBatchDialog, row.original)}
                        title="Delete Batch"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={batchColumns.length + 1} className="h-24 text-center">
                  No batches found.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </ScrollArea>

      {/* Dialogs */}
      {selectedBatchForAction && (
        <>
          <BatchDetailsDialog
            batchId={selectedBatchForAction.id}
            open={showDetailsDialog}
            onOpenChange={setShowDetailsDialog}
          />

          {selectedBatchForAction.latestStageSummary && showAddDryingDialog && (
            <AddDryingDialog
              processingStageId={selectedBatchForAction.latestStageSummary.id}
              batchCode={selectedBatchForAction.batchCode}
              processingCount={selectedBatchForAction.latestStageSummary.processingCount}
              open={showAddDryingDialog}
              onOpenChange={setShowAddDryingDialog}
              onSuccess={handleRefresh}
            />
          )}
          {selectedBatchForAction.latestStageSummary && showFinalizeStageDialog && (
            <FinalizeStageDialog
              processingStageId={selectedBatchForAction.latestStageSummary.id}
              batchCode={selectedBatchForAction.batchCode}
              processingCount={selectedBatchForAction.latestStageSummary.processingCount}
              currentInitialQuantity={selectedBatchForAction.latestStageSummary.initialQuantity}
              open={showFinalizeStageDialog}
              onOpenChange={setShowFinalizeStageDialog}
              onSuccess={handleRefresh}
            />
          )}
          {selectedBatchForAction.latestStageSummary &&
            showStartNextStageDialog &&
            selectedBatchForAction.latestStageSummary.status === 'FINISHED' && (
              <StartNextStageDialog
                processingBatchId={selectedBatchForAction.id}
                batchCode={selectedBatchForAction.batchCode}
                previousStageId={selectedBatchForAction.latestStageSummary.id}
                previousProcessingCount={selectedBatchForAction.latestStageSummary.processingCount}
                previousStageYield={selectedBatchForAction.latestStageSummary.quantityAfterProcess || 0}
                open={showStartNextStageDialog}
                onOpenChange={setShowStartNextStageDialog}
                onSuccess={handleRefresh}
              />
            )}
          {selectedBatchForAction.latestStageSummary &&
            showRecordSaleDialog &&
            selectedBatchForAction.latestStageSummary.status === 'FINISHED' && (
              <RecordSaleDialog
                processingBatchId={selectedBatchForAction.id}
                processingStage={selectedBatchForAction.latestStageSummary as any} // Casting needed if types don't fully align for dialog props
                batchCode={selectedBatchForAction.batchCode}
                availableForSaleFromStage={getAvailableForSaleFromLatestFinishedStage(selectedBatchForAction)}
                open={showRecordSaleDialog}
                onOpenChange={setShowRecordSaleDialog}
                onSuccess={handleRefresh}
              />
            )}
        </>
      )}

      <AlertDialog open={showDeleteBatchDialog} onOpenChange={setShowDeleteBatchDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Batch: {selectedBatchForAction?.batchCode}?</AlertDialogTitle>
            <AlertDialogDescription>
              This action is irreversible. All stages, drying data, and sales for this batch will be deleted.
              Procurements will be unlinked.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              className="bg-destructive hover:bg-destructive/90"
              onClick={confirmDeleteBatch}
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete Batch'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\add-drying-dialog.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { createDryingEntrySchema, type CreateDryingEntryInput, type Drying } from '@chaya/shared';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';
import axios from 'axios';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';

interface AddDryingDialogProps {
  processingStageId: number;
  batchCode: string;
  processingCount: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function AddDryingDialog({
  processingStageId,
  batchCode,
  processingCount,
  open,
  onOpenChange,
  onSuccess,
}: AddDryingDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [existingDryingEntries, setExistingDryingEntries] = useState<Drying[]>([]);
  const [isLoadingEntries, setIsLoadingEntries] = useState(false);

  const form = useForm<CreateDryingEntryInput>({
    resolver: zodResolver(createDryingEntrySchema),
    defaultValues: {
      processingStageId: processingStageId,
      day: 1,
      temperature: 25,
      humidity: 60,
      pH: 7,
      moisturePercentage: 15,
      currentQuantity: 0,
    },
  });

  useEffect(() => {
    if (open && processingStageId) {
      form.setValue('processingStageId', processingStageId);
      const fetchExistingEntries = async () => {
        setIsLoadingEntries(true);
        try {
          const response = await axios.get<{ dryingEntries: Drying[] }>(
            `/api/processing-stages/${processingStageId}/drying`,
            { withCredentials: true }
          );
          setExistingDryingEntries(response.data.dryingEntries);
          const nextDay =
            response.data.dryingEntries.length > 0 ? Math.max(...response.data.dryingEntries.map(d => d.day)) + 1 : 1;
          form.setValue('day', nextDay);
          const lastEntry = response.data.dryingEntries.sort((a, b) => b.day - a.day)[0];
          form.setValue('currentQuantity', lastEntry ? lastEntry.currentQuantity : 0);
        } catch (error) {
          toast.error('Failed to load existing drying entries.');
        } finally {
          setIsLoadingEntries(false);
        }
      };
      fetchExistingEntries();
    }
  }, [open, processingStageId, form]);

  const onSubmit = async (data: CreateDryingEntryInput) => {
    setIsSubmitting(true);
    try {
      await axios.post(`/api/processing-stages/${processingStageId}/drying`, data, { withCredentials: true });
      toast.success(`Drying data for Day ${data.day} added successfully.`);
      onSuccess();
      onOpenChange(false);
      const nextDay = data.day + 1;
      form.reset({
        ...form.formState.defaultValues,
        day: nextDay,
        processingStageId,
        currentQuantity: data.currentQuantity,
      });
    } catch (error: any) {
      console.error('Error adding drying data:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to add drying data'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-2xl">
        <DialogHeader>
          <DialogTitle>
            Add Drying Data for Batch {batchCode} - P{processingCount}
          </DialogTitle>
          <DialogDescription>Enter the drying parameters for the specified day.</DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="day"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Day Number</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        {...field}
                        onChange={e => field.onChange(parseInt(e.target.value, 10) || 0)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="temperature"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Temperature (°C)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="humidity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Humidity (%)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="pH"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>pH Level</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="moisturePercentage"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Moisture (%)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="currentQuantity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Current Quantity (kg)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.5"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting || isLoadingEntries}>
                {isSubmitting ? 'Adding...' : 'Add Entry'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
        {isLoadingEntries && <p className="text-sm text-center py-4">Loading existing entries...</p>}
        {!isLoadingEntries && existingDryingEntries.length > 0 && (
          <div className="mt-6">
            <h4 className="text-md font-semibold mb-2">Previous Drying Entries (P{processingCount})</h4>
            <ScrollArea className="h-[200px] border rounded-md">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Day</TableHead>
                    <TableHead>Temp</TableHead>
                    <TableHead>Hum</TableHead>
                    <TableHead>pH</TableHead>
                    <TableHead>Moist%</TableHead>
                    <TableHead>Qty(kg)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {existingDryingEntries.map(entry => (
                    <TableRow key={entry.id}>
                      <TableCell>{entry.day}</TableCell>
                      <TableCell>{entry.temperature}°C</TableCell>
                      <TableCell>{entry.humidity}%</TableCell>
                      <TableCell>{entry.pH}</TableCell>
                      <TableCell>{entry.moisturePercentage}%</TableCell>
                      <TableCell>{entry.currentQuantity}kg</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\finalize-stage-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  type FinalizeProcessingStageInput as BackendFinalizeProcessingStageInputType,
  type Drying,
} from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { toast } from 'sonner';
import axios from 'axios';

const finalizeStageFormSchema = z.object({
  dateOfCompletion: z.date({
    required_error: 'Date of Completion is required',
    invalid_type_error: "That's not a valid date!",
  }),
  quantityAfterProcess: z.coerce
    .number({
      required_error: 'Final quantity is required',
      invalid_type_error: 'Final quantity must be a number',
    })
    .positive('Final quantity must be a positive number'),
});

type FinalizeStageFormValues = z.infer<typeof finalizeStageFormSchema>;

interface FinalizeStageDialogProps {
  processingStageId: number;
  batchCode: string;
  processingCount: number;
  currentInitialQuantity: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function FinalizeStageDialog({
  processingStageId,
  batchCode,
  processingCount,
  currentInitialQuantity,
  open,
  onOpenChange,
  onSuccess,
}: FinalizeStageDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoadingDrying, setIsLoadingDrying] = useState(false);

  const form = useForm<FinalizeStageFormValues>({
    resolver: zodResolver(finalizeStageFormSchema),
    defaultValues: {
      dateOfCompletion: new Date(),
      quantityAfterProcess: undefined,
    },
  });

  useEffect(() => {
    if (open && processingStageId) {
      setIsLoadingDrying(true);
      axios
        .get<{ dryingEntries: Drying[] }>(`/api/processing-stages/${processingStageId}/drying`, {
          withCredentials: true,
        })
        .then(response => {
          const dryingEntries = response.data.dryingEntries;
          const latestDryingEntry = dryingEntries?.sort((a, b) => b.day - a.day)[0];
          const autoFillQuantity = latestDryingEntry?.currentQuantity ?? currentInitialQuantity;

          form.reset({
            dateOfCompletion: new Date(),
            quantityAfterProcess: parseFloat(autoFillQuantity.toFixed(2)) || undefined,
          });
        })
        .catch(err => {
          toast.error('Could not load latest drying quantity for autofill.');
          console.error('Error fetching drying entries for autofill:', err);
          form.reset({
            dateOfCompletion: new Date(),
            quantityAfterProcess: parseFloat(currentInitialQuantity.toFixed(2)) || undefined,
          });
        })
        .finally(() => {
          setIsLoadingDrying(false);
        });
    }
  }, [open, processingStageId, form, currentInitialQuantity]);

  const onSubmit = async (data: FinalizeStageFormValues) => {
    setIsSubmitting(true);
    try {
      const payload: BackendFinalizeProcessingStageInputType = {
        dateOfCompletion: data.dateOfCompletion,
        quantityAfterProcess: data.quantityAfterProcess,
      };
      await axios.put(`/api/processing-stages/${processingStageId}/finalize`, payload, { withCredentials: true });
      toast.success(`Stage P${processingCount} for Batch ${batchCode} finalized successfully.`);
      onSuccess();
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error finalizing stage:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to finalize stage'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            Finalize Stage P{processingCount} for Batch {batchCode}
          </DialogTitle>
          <DialogDescription>
            Enter the completion details. Initial quantity for this stage was {currentInitialQuantity.toFixed(2)}kg.
            {isLoadingDrying && ' Fetching latest drying quantity...'}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="dateOfCompletion"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Date of Completion</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="quantityAfterProcess"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Quantity After Process (kg)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      step="0.01"
                      placeholder="Enter final yield for this stage"
                      {...field}
                      disabled={isLoadingDrying}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
                disabled={isSubmitting || isLoadingDrying}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting || isLoadingDrying}>
                {isSubmitting ? 'Finalizing...' : 'Finalize Stage'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\record-sale-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { createSaleFormSchema, type CreateSaleInput as BackendCreateSaleInputType } from '@chaya/shared';
import type { ProcessingStage } from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon, Clock } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format, parse } from 'date-fns';
import { toast } from 'sonner';
import axios from 'axios';
import { z } from 'zod';

type SaleFormDialogValues = z.infer<typeof createSaleFormSchema>;

interface RecordSaleDialogProps {
  processingBatchId: number;
  processingStage: Pick<ProcessingStage, 'id' | 'processingCount' | 'quantityAfterProcess' | 'status'>;
  batchCode: string;
  availableForSaleFromStage: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function RecordSaleDialog({
  processingBatchId,
  processingStage,
  batchCode,
  availableForSaleFromStage,
  open,
  onOpenChange,
  onSuccess,
}: RecordSaleDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<SaleFormDialogValues>({
    resolver: zodResolver(createSaleFormSchema),
    defaultValues: {
      quantitySold: undefined,
      dateOfSaleInput: new Date(),
      timeOfSaleInput: format(new Date(), 'HH:mm:ss'),
    },
  });

  useEffect(() => {
    if (open) {
      form.reset({
        quantitySold: undefined,
        dateOfSaleInput: new Date(),
        timeOfSaleInput: format(new Date(), 'HH:mm:ss'),
      });
    }
  }, [open, form]);

  const onSubmit = async (data: SaleFormDialogValues) => {
    setIsSubmitting(true);
    if (data.quantitySold > availableForSaleFromStage) {
      toast.error(
        `Cannot sell ${data.quantitySold}kg. Only ${availableForSaleFromStage.toFixed(2)}kg available from P${processingStage.processingCount}.`
      );
      setIsSubmitting(false);
      return;
    }

    const datePartStr = format(data.dateOfSaleInput, 'yyyy-MM-dd');
    const timePartStr = data.timeOfSaleInput;
    const combinedDateTime = new Date(`${datePartStr}T${timePartStr}`);
    if (isNaN(combinedDateTime.getTime())) {
      toast.error('Invalid date or time for sale.');
      setIsSubmitting(false);
      return;
    }

    const payload: BackendCreateSaleInputType = {
      quantitySold: data.quantitySold,
      dateOfSale: combinedDateTime,
      processingBatchId,
      processingStageId: processingStage.id,
    };
    try {
      await axios.post(`/api/sales`, payload, { withCredentials: true });
      toast.success(
        `Sale of ${data.quantitySold}kg for Batch ${batchCode} (from P${processingStage.processingCount}) recorded.`
      );
      onSuccess();
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error recording sale:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to record sale'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>
            Record Sale from Batch {batchCode} - Stage P{processingStage.processingCount}
          </DialogTitle>
          <DialogDescription>
            Available from P{processingStage.processingCount}: {availableForSaleFromStage.toFixed(2)}kg.
            {processingStage.status !== 'FINISHED' && " Note: This stage is not marked 'FINISHED'."}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 pt-4">
            <FormField
              control={form.control}
              name="quantitySold"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Quantity Sold (kg)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      step="0.01"
                      placeholder={`Max ${availableForSaleFromStage.toFixed(2)}`}
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="dateOfSaleInput"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Date of Sale</FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant="outline"
                            className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                          >
                            {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="timeOfSaleInput"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Time of Sale</FormLabel>
                    <div className="flex items-center">
                      <FormControl>
                        <Input
                          type="time"
                          step="1"
                          className="flex-1"
                          {...field}
                          value={field.value || format(new Date(), 'HH:mm:ss')}
                          onChange={e => {
                            let timeValue = e.target.value;
                            if (timeValue.match(/^\d{2}:\d{2}$/)) timeValue += ':00';
                            else if (!timeValue.match(/^\d{2}:\d{2}:\d{2}$/))
                              timeValue = field.value || format(new Date(), 'HH:mm:ss');
                            field.onChange(timeValue);
                          }}
                        />
                      </FormControl>
                      <Clock className="ml-2 h-4 w-4 text-muted-foreground" />
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting || availableForSaleFromStage <= 0}>
                {isSubmitting ? 'Recording...' : 'Record Sale'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\start-next-stage-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { type CreateProcessingStageInput as BackendCreateProcessingStageInputType } from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { toast } from 'sonner';
import axios from 'axios';

const nextStageFormStepSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z.date({
    required_error: 'Date of Processing is required',
    invalid_type_error: "That's not a valid date!",
  }),
  doneBy: z.string().min(1, 'Person responsible is required'),
});

type NextStageFormValues = z.infer<typeof nextStageFormStepSchema>;

interface StartNextStageDialogProps {
  processingBatchId: number;
  batchCode: string;
  previousStageId: number;
  previousProcessingCount: number;
  previousStageYield: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function StartNextStageDialog({
  processingBatchId,
  batchCode,
  previousStageId,
  previousProcessingCount,
  previousStageYield,
  open,
  onOpenChange,
  onSuccess,
}: StartNextStageDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const nextProcessingCount = previousProcessingCount + 1;

  const form = useForm<NextStageFormValues>({
    resolver: zodResolver(nextStageFormStepSchema),
    defaultValues: {
      processMethod: 'wet',
      dateOfProcessing: new Date(),
      doneBy: '',
    },
  });

  useEffect(() => {
    if (open) {
      form.reset({
        processMethod: 'wet',
        dateOfProcessing: new Date(),
        doneBy: '',
      });
    }
  }, [open, form]);

  const onSubmit = async (data: NextStageFormValues) => {
    setIsSubmitting(true);
    try {
      const payload: BackendCreateProcessingStageInputType = {
        processMethod: data.processMethod,
        dateOfProcessing: data.dateOfProcessing,
        doneBy: data.doneBy,
        processingBatchId,
        previousStageId,
      };
      await axios.post(`/api/processing-stages`, payload, { withCredentials: true });
      toast.success(`Stage P${nextProcessingCount} for Batch ${batchCode} started successfully.`);
      onSuccess();
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error starting next stage:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to start next stage'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>
            Start Next Stage (P{nextProcessingCount}) for Batch {batchCode}
          </DialogTitle>
          <DialogDescription>
            Stage P{previousProcessingCount} finished with a yield of {previousStageYield.toFixed(2)}kg. The new stage P
            {nextProcessingCount} will start with the quantity remaining after any sales from P{previousProcessingCount}
            .
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 pt-4">
            <FormField
              control={form.control}
              name="processMethod"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Process Method (P{nextProcessingCount})</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select method" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="wet">Wet</SelectItem>
                      <SelectItem value="dry">Dry</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="dateOfProcessing"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Date of Processing (P{nextProcessingCount})</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="doneBy"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Done By (P{nextProcessingCount})</FormLabel>
                  <FormControl>
                    <Input placeholder="Responsible person/team" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Starting Stage...' : `Start P${nextProcessingCount}`}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\batch-details-dialog.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@workspace/ui/components/dialog';
import type { ProcessingBatchWithDetails, ExtendedProcessingStageStatus } from '../../lib/types';
import { useProcessingBatchCache } from '../../context/processing-batch-cache-context';
import { Separator } from '@workspace/ui/components/separator';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Badge } from '@workspace/ui/components/badge';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { format } from 'date-fns';
import { Button } from '@workspace/ui/components/button'; // If adding a close button in footer
import { DialogFooter } from '@workspace/ui/components/dialog'; // If adding a footer

interface BatchDetailsDialogProps {
  batchId: number | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function BatchDetailsDialog({ batchId, open, onOpenChange }: BatchDetailsDialogProps) {
  const { getBatchDetails } = useProcessingBatchCache();
  const [batch, setBatch] = useState<ProcessingBatchWithDetails | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (open && batchId) {
      setIsLoading(true);
      getBatchDetails(batchId)
        .then(data => setBatch(data))
        .finally(() => setIsLoading(false));
    } else if (!open) {
      setBatch(null);
    }
  }, [open, batchId, getBatchDetails]);

  const getStatusBadgeVariant = (
    status: ExtendedProcessingStageStatus | undefined
  ): 'default' | 'secondary' | 'destructive' | 'outline' => {
    if (!status) return 'outline';
    switch (status) {
      case 'IN_PROGRESS':
        return 'secondary';
      case 'FINISHED':
        return 'default';
      case 'CANCELLED':
        return 'destructive';
      case 'SOLD_OUT':
        return 'default';
      case 'NO_STAGES':
        return 'outline';
      default:
        return 'outline';
    }
  };

  if (isLoading || !batch) {
    return (
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent className="max-w-4xl max-h-[90vh]">
          <DialogHeader>
            <DialogTitle>Loading Batch Details...</DialogTitle>
          </DialogHeader>
          <div className="p-6 text-center">Loading...</div>
        </DialogContent>
      </Dialog>
    );
  }

  const displayedStatus = batch.latestStageSummary?.status || 'NO_STAGES';

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] flex flex-col">
        {' '}
        {/* Ensure flex-col */}
        <DialogHeader>
          <DialogTitle>Batch Details: {batch.batchCode}</DialogTitle>
          <DialogDescription className="flex items-center flex-wrap">
            {' '}
            {/* Added flex-wrap */}
            Crop: {batch.crop} | Lot No: {batch.lotNo} | Created By: {batch.createdBy.name} on{' '}
            {format(new Date(batch.createdAt), 'PP')}
            <span className="mx-2">|</span>
            Status:
            <Badge variant={getStatusBadgeVariant(displayedStatus)} className="ml-1">
              {displayedStatus.toString().replace(/_/g, ' ')}
            </Badge>
          </DialogDescription>
        </DialogHeader>
        <ScrollArea className="flex-grow mt-2 pr-6">
          <div className="space-y-6 py-4">
            <div>
              <h3 className="text-lg font-semibold mb-2">Key Figures</h3>
              <Separator />
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-2 text-sm p-2 border rounded-md">
                <div>
                  <span className="font-medium">Initial Batch Qty:</span> {batch.initialBatchQuantity.toFixed(2)} kg
                </div>
                <div>
                  <span className="font-medium">Total Sold:</span> {batch.totalQuantitySoldFromBatch.toFixed(2)} kg
                </div>
                <div>
                  <span className="font-medium text-green-600">Net Remaining:</span>{' '}
                  <span className="font-bold">{batch.netAvailableQuantity.toFixed(2)} kg</span>
                </div>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Procurements Included ({batch.procurements.length})</h3>
              <Separator />
              <ScrollArea className="h-40 border rounded-md mt-2">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Proc. No.</TableHead>
                      <TableHead>Farmer</TableHead>
                      <TableHead>Village</TableHead>
                      <TableHead>Qty (kg)</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {batch.procurements.map(p => (
                      <TableRow key={p.id}>
                        <TableCell>{p.procurementNumber}</TableCell>
                        <TableCell>{p.farmer.name}</TableCell>
                        <TableCell>{p.farmer.village || 'N/A'}</TableCell>
                        <TableCell className="text-right">{p.quantity.toFixed(2)}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </ScrollArea>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Processing Stages ({batch.processingStages.length})</h3>
              <Separator />
              {batch.processingStages.map(stage => (
                <div key={stage.id} className="mt-3 border p-3 rounded-md">
                  <div className="flex justify-between items-center mb-2">
                    <h4 className="font-semibold">
                      Stage P{stage.processingCount}{' '}
                      <Badge variant={getStatusBadgeVariant(stage.status as ExtendedProcessingStageStatus)}>
                        {stage.status.replace('_', ' ')}
                      </Badge>
                    </h4>
                    <span className="text-xs text-muted-foreground">
                      Method: {stage.processMethod.toUpperCase()} | By: {stage.doneBy}
                    </span>
                  </div>
                  <p className="text-xs">
                    Started: {format(new Date(stage.dateOfProcessing), 'PPp')}
                    {stage.dateOfCompletion ? ` | Completed: ${format(new Date(stage.dateOfCompletion), 'PPp')}` : ''}
                  </p>
                  <p className="text-xs">
                    Initial Qty: {stage.initialQuantity.toFixed(2)}kg{' '}
                    {stage.quantityAfterProcess !== null ? `| Yield: ${stage.quantityAfterProcess.toFixed(2)}kg` : ''}
                  </p>
                  {stage.dryingEntries.length > 0 && (
                    <div className="mt-2">
                      <p className="text-xs font-medium mb-1">Drying Entries ({stage.dryingEntries.length}):</p>
                      <ScrollArea className="h-28 border rounded-md">
                        <Table>
                          <TableHeader>
                            <TableRow>
                              <TableHead>Day</TableHead>
                              <TableHead>Temp</TableHead>
                              <TableHead>Humid</TableHead>
                              <TableHead>pH</TableHead>
                              <TableHead>Moist%</TableHead>
                              <TableHead>Qty</TableHead>
                            </TableRow>
                          </TableHeader>
                          <TableBody>
                            {stage.dryingEntries.map(d => (
                              <TableRow key={d.id}>
                                <TableCell>{d.day}</TableCell>
                                <TableCell>{d.temperature}°C</TableCell>
                                <TableCell>{d.humidity}%</TableCell>
                                <TableCell>{d.pH}</TableCell>
                                <TableCell>{d.moisturePercentage}%</TableCell>
                                <TableCell>{d.currentQuantity.toFixed(2)}kg</TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </ScrollArea>
                    </div>
                  )}
                  {stage.dryingEntries.length === 0 && (
                    <p className="text-xs text-muted-foreground mt-1">No drying entries for this stage.</p>
                  )}
                </div>
              ))}
              {batch.processingStages.length === 0 && (
                <p className="text-sm text-muted-foreground mt-2">No processing stages recorded yet.</p>
              )}
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Sales Recorded ({batch.sales.length})</h3>
              <Separator />
              {batch.sales.length > 0 ? (
                <ScrollArea className="h-32 border rounded-md mt-2">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Date</TableHead>
                        <TableHead>From P#</TableHead>
                        <TableHead>Qty Sold (kg)</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {batch.sales.map(s => (
                        <TableRow key={s.id}>
                          <TableCell>{format(new Date(s.dateOfSale), 'PP')}</TableCell>
                          <TableCell>P{s.processingStage.processingCount}</TableCell>
                          <TableCell className="text-right">{s.quantitySold.toFixed(2)}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </ScrollArea>
              ) : (
                <p className="text-sm text-muted-foreground mt-2">No sales recorded for this batch yet.</p>
              )}
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Key Figures</h3>
              <Separator />
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-2 text-sm p-2 border rounded-md">
                <div>
                  <span className="font-medium">Initial Batch Qty:</span> {batch.initialBatchQuantity.toFixed(2)} kg
                </div>
                <div>
                  <span className="font-medium">Total Sold:</span> {batch.totalQuantitySoldFromBatch.toFixed(2)} kg
                </div>
                <div>
                  <span className="font-medium text-green-600">Net Remaining:</span>{' '}
                  <span className="font-bold">{batch.netAvailableQuantity.toFixed(2)} kg</span>
                </div>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Procurements Included ({batch.procurements.length})</h3>
              <Separator />
              <ScrollArea className="h-40 border rounded-md mt-2">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Proc. No.</TableHead>
                      <TableHead>Farmer</TableHead>
                      <TableHead>Village</TableHead>
                      <TableHead>Qty (kg)</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {batch.procurements.map(p => (
                      <TableRow key={p.id}>
                        <TableCell>{p.procurementNumber}</TableCell>
                        <TableCell>{p.farmer.name}</TableCell>
                        <TableCell>{p.farmer.village || 'N/A'}</TableCell>
                        <TableCell className="text-right">{p.quantity.toFixed(2)}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </ScrollArea>
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Processing Stages ({batch.processingStages.length})</h3>
              <Separator />
              {batch.processingStages.map(stage => (
                <div key={stage.id} className="mt-3 border p-3 rounded-md">
                  <div className="flex justify-between items-center mb-2">
                    <h4 className="font-semibold">
                      Stage P{stage.processingCount}{' '}
                      <Badge variant={getStatusBadgeVariant(stage.status as ExtendedProcessingStageStatus)}>
                        {stage.status.replace('_', ' ')}
                      </Badge>
                    </h4>
                    <span className="text-xs text-muted-foreground">
                      Method: {stage.processMethod.toUpperCase()} | By: {stage.doneBy}
                    </span>
                  </div>
                  <p className="text-xs">
                    Started: {format(new Date(stage.dateOfProcessing), 'PPp')}
                    {stage.dateOfCompletion ? ` | Completed: ${format(new Date(stage.dateOfCompletion), 'PPp')}` : ''}
                  </p>
                  <p className="text-xs">
                    Initial Qty: {stage.initialQuantity.toFixed(2)}kg{' '}
                    {stage.quantityAfterProcess !== null ? `| Yield: ${stage.quantityAfterProcess.toFixed(2)}kg` : ''}
                  </p>
                  {stage.dryingEntries.length > 0 && (
                    <div className="mt-2">
                      <p className="text-xs font-medium mb-1">Drying Entries ({stage.dryingEntries.length}):</p>
                      <ScrollArea className="h-28 border rounded-md">
                        <Table>
                          <TableHeader>
                            <TableRow>
                              <TableHead>Day</TableHead>
                              <TableHead>Temp</TableHead>
                              <TableHead>Humid</TableHead>
                              <TableHead>pH</TableHead>
                              <TableHead>Moist%</TableHead>
                              <TableHead>Qty</TableHead>
                            </TableRow>
                          </TableHeader>
                          <TableBody>
                            {stage.dryingEntries.map(d => (
                              <TableRow key={d.id}>
                                <TableCell>{d.day}</TableCell>
                                <TableCell>{d.temperature}°C</TableCell>
                                <TableCell>{d.humidity}%</TableCell>
                                <TableCell>{d.pH}</TableCell>
                                <TableCell>{d.moisturePercentage}%</TableCell>
                                <TableCell>{d.currentQuantity.toFixed(2)}kg</TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </ScrollArea>
                    </div>
                  )}
                  {stage.dryingEntries.length === 0 && (
                    <p className="text-xs text-muted-foreground mt-1">No drying entries for this stage.</p>
                  )}
                </div>
              ))}
              {batch.processingStages.length === 0 && (
                <p className="text-sm text-muted-foreground mt-2">No processing stages recorded yet.</p>
              )}
            </div>

            <div>
              <h3 className="text-lg font-semibold mb-2">Sales Recorded ({batch.sales.length})</h3>
              <Separator />
              {batch.sales.length > 0 ? (
                <ScrollArea className="h-32 border rounded-md mt-2">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Date</TableHead>
                        <TableHead>From P#</TableHead>
                        <TableHead>Qty Sold (kg)</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {batch.sales.map(s => (
                        <TableRow key={s.id}>
                          <TableCell>{format(new Date(s.dateOfSale), 'PP')}</TableCell>
                          <TableCell>P{s.processingStage.processingCount}</TableCell>
                          <TableCell className="text-right">{s.quantitySold.toFixed(2)}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </ScrollArea>
              ) : (
                <p className="text-sm text-muted-foreground mt-2">No sales recorded for this batch yet.</p>
              )}
            </div>
          </div>
        </ScrollArea>
        <DialogFooter className="mt-auto pt-4 sticky bottom-0 bg-background pb-4 px-6">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\lib\columns-batch.tsx:
```
'use client';

import type { ColumnDef } from '@tanstack/react-table';
import type { ProcessingBatchWithSummary, ExtendedProcessingStageStatus } from './types';
import { Badge } from '@workspace/ui/components/badge';
import { format } from 'date-fns';

export const defaultVisibleBatchColumns = [
  'batchCode',
  'crop',
  'lotNo',
  'latestStageStatus',
  'latestStageCount',
  'netAvailableQuantity',
  'totalQuantitySoldFromBatch',
  'createdAt',
];

export const batchColumns: ColumnDef<ProcessingBatchWithSummary>[] = [
  {
    accessorKey: 'batchCode',
    header: 'Batch Code',
    cell: ({ row }) => <div className="font-medium">{row.original.batchCode}</div>,
  },
  {
    accessorKey: 'crop',
    header: 'Crop',
    cell: ({ row }) => row.original.crop,
  },
  {
    accessorKey: 'lotNo',
    header: 'Lot No.',
    cell: ({ row }) => row.original.lotNo,
  },
  {
    accessorKey: 'latestStageCount',
    header: 'Stage (P#)',
    cell: ({ row }) =>
      row.original.latestStageSummary ? `P${row.original.latestStageSummary.processingCount}` : 'N/A',
  },
  {
    accessorKey: 'latestStageStatus',
    header: 'Current Status',
    cell: ({ row }) => {
      const status: ExtendedProcessingStageStatus | undefined = row.original.latestStageSummary?.status;
      if (!status) return <Badge variant="outline">No Stages</Badge>;

      let displayStatus = status.toString().replace('_', ' ');
      let variant: 'default' | 'secondary' | 'destructive' | 'outline' = 'outline';

      switch (status) {
        case 'IN_PROGRESS':
          variant = 'secondary';
          displayStatus = 'In Progress';
          break;
        case 'FINISHED':
          variant = 'default';
          break;
        case 'CANCELLED':
          variant = 'destructive';
          break;
        case 'SOLD_OUT':
          variant = 'default';
          displayStatus = 'Sold Out';
          break;
        case 'NO_STAGES':
          variant = 'outline';
          displayStatus = 'No Stages';
          break;
        default:
          variant = 'outline';
      }
      return <Badge variant={variant}>{displayStatus}</Badge>;
    },
  },
  {
    accessorKey: 'netAvailableQuantity',
    header: 'Remaining Qty (kg)',
    cell: ({ row }) => <div className="text-right">{row.original.netAvailableQuantity.toFixed(2)}</div>,
  },
  {
    accessorKey: 'totalQuantitySoldFromBatch',
    header: 'Total Sold (kg)',
    cell: ({ row }) => <div className="text-right">{row.original.totalQuantitySoldFromBatch.toFixed(2)}</div>,
  },
  {
    accessorKey: 'initialBatchQuantity',
    header: 'Initial Batch (kg)',
    cell: ({ row }) => <div className="text-right">{row.original.initialBatchQuantity.toFixed(2)}</div>,
  },
  {
    accessorKey: 'createdAt',
    header: 'Created On',
    cell: ({ row }) => format(new Date(row.original.createdAt), 'dd/MM/yyyy'),
  },
];

```

### apps\web\app\(dashboard)\processing-batches\lib\types.ts:
```
import type {
  ProcessingBatch,
  Procurement,
  ProcessingStage,
  Drying,
  Sale,
  User,
  ProcessingStageStatus as PrismaProcessingStageStatus,
} from '@chaya/shared';

export type ExtendedProcessingStageStatus = PrismaProcessingStageStatus | 'SOLD_OUT' | 'NO_STAGES';

export interface ProcessingBatchWithSummary
  extends Omit<ProcessingBatch, 'processingStages' | 'procurements' | 'sales'> {
  latestStageSummary: {
    id: number;
    processingCount: number;
    status: ExtendedProcessingStageStatus;
    processMethod: string;
    dateOfProcessing: Date;
    doneBy: string;
    initialQuantity: number;
    quantityAfterProcess: number | null;
    lastDryingQuantity: number | null;
  } | null;
  totalQuantitySoldFromBatch: number;
  netAvailableQuantity: number;
}

export interface ProcessingStageWithDrying extends ProcessingStage {
  dryingEntries: Drying[];
}
export interface SaleWithStageInfo extends Sale {
  processingStage: Pick<ProcessingStage, 'processingCount'>;
}

export interface ProcessingBatchWithDetails extends ProcessingBatch {
  procurements: (Procurement & { farmer: Pick<User, 'name'> & { village?: string } })[];
  processingStages: ProcessingStageWithDrying[];
  sales: SaleWithStageInfo[];
  createdBy: Pick<User, 'id' | 'name'>;
  totalQuantitySoldFromBatch: number;
  netAvailableQuantity: number;
  latestStageSummary?: {
    id: number;
    processingCount: number;
    status: ExtendedProcessingStageStatus;
    processMethod: string;
    dateOfProcessing: Date;
    doneBy: string;
    initialQuantity: number;
    quantityAfterProcess: number | null;
    lastDryingQuantity: number | null;
  } | null;
}

```

### apps\web\app\(dashboard)\processing-batches\context\processing-batch-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import type { ProcessingBatchWithSummary, ProcessingBatchWithDetails } from '../lib/types';
import { toast } from 'sonner';
import axios from 'axios';

interface ProcessingBatchCacheContextType {
  processingBatchesSummary: Record<string, ProcessingBatchWithSummary[]>;
  totalPages: Record<string, number>;
  fetchProcessingBatchesSummary: (
    page: number,
    query: string,
    statusFilter: string
  ) => Promise<ProcessingBatchWithSummary[]>;
  fetchTotalPages: (query: string, statusFilter: string) => Promise<number>;
  clearCache: () => void;
  refreshCurrentPageSummary: (
    page: number,
    query: string,
    statusFilter: string
  ) => Promise<ProcessingBatchWithSummary[]>;
  getBatchDetails: (batchId: number) => Promise<ProcessingBatchWithDetails | null>;
  clearBatchDetailCache: (batchId: number) => void;
}

const ProcessingBatchCacheContext = createContext<ProcessingBatchCacheContextType | undefined>(undefined);

export function ProcessingBatchCacheProvider({ children }: { children: React.ReactNode }) {
  const [processingBatchesSummary, setProcessingBatchesSummary] = useState<
    Record<string, ProcessingBatchWithSummary[]>
  >({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});
  const [batchDetailsCache, setBatchDetailsCache] = useState<Record<number, ProcessingBatchWithDetails>>({});

  const createListKey = useCallback((page: number, query: string, status: string) => `${query}:${status}:${page}`, []);

  const fetchProcessingBatchesSummary = useCallback(
    async (page: number, query: string, statusFilter: string): Promise<ProcessingBatchWithSummary[]> => {
      const key = createListKey(page, query, statusFilter);
      if (processingBatchesSummary[key]) {
        return processingBatchesSummary[key];
      }
      try {
        const params = new URLSearchParams({ page: page.toString(), limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const data = response.data;

        setProcessingBatchesSummary(prev => ({ ...prev, [key]: data.processingBatches }));
        setTotalPages(prev => ({ ...prev, [`${query}:${statusFilter}`]: data.pagination.totalPages }));
        return data.processingBatches;
      } catch (error) {
        toast.error('Failed to fetch processing batches summary.');
        throw error;
      }
    },
    [processingBatchesSummary]
  );

  const fetchTotalPages = useCallback(
    async (query: string, statusFilter: string): Promise<number> => {
      const key = `${query}:${statusFilter}`;
      if (totalPages[key] !== undefined) {
        return totalPages[key];
      }
      try {
        const params = new URLSearchParams({ page: '1', limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const pages = response.data.pagination.totalPages;
        setTotalPages(prev => ({ ...prev, [key]: pages }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        return 1; // Default to 1 page on error
      }
    },
    [totalPages]
  );

  const refreshCurrentPageSummary = useCallback(
    async (page: number, query: string, statusFilter: string): Promise<ProcessingBatchWithSummary[]> => {
      const key = createListKey(page, query, statusFilter);
      try {
        const params = new URLSearchParams({ page: page.toString(), limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const data = response.data;

        setProcessingBatchesSummary(prev => ({ ...prev, [key]: data.processingBatches }));
        setTotalPages(prev => ({ ...prev, [`${query}:${statusFilter}`]: data.pagination.totalPages })); // refresh total pages too
        return data.processingBatches;
      } catch (error) {
        toast.error(`Failed to refresh batches data for page ${page}.`);
        throw error;
      }
    },
    []
  );

  const getBatchDetails = useCallback(
    async (batchId: number): Promise<ProcessingBatchWithDetails | null> => {
      if (batchDetailsCache[batchId]) {
        return batchDetailsCache[batchId];
      }
      try {
        const response = await axios.get<ProcessingBatchWithDetails>(`/api/processing-batches/${batchId}`, {
          withCredentials: true,
        });
        setBatchDetailsCache(prev => ({ ...prev, [batchId]: response.data }));
        return response.data;
      } catch (error) {
        toast.error(`Failed to fetch details for batch ID ${batchId}.`);
        return null;
      }
    },
    [batchDetailsCache]
  );

  const clearBatchDetailCache = useCallback((batchId: number) => {
    setBatchDetailsCache(prev => {
      const newState = { ...prev };
      delete newState[batchId];
      return newState;
    });
  }, []);

  const clearCache = useCallback(() => {
    setProcessingBatchesSummary({});
    setTotalPages({});
    setBatchDetailsCache({});
    toast.info('Processing batches cache cleared.');
  }, []);

  return (
    <ProcessingBatchCacheContext.Provider
      value={{
        processingBatchesSummary,
        totalPages,
        fetchProcessingBatchesSummary,
        fetchTotalPages,
        clearCache,
        refreshCurrentPageSummary,
        getBatchDetails,
        clearBatchDetailCache,
      }}
    >
      {children}
    </ProcessingBatchCacheContext.Provider>
  );
}

export function useProcessingBatchCache() {
  const context = useContext(ProcessingBatchCacheContext);
  if (context === undefined) {
    throw new Error('useProcessingBatchCache must be used within a ProcessingBatchCacheProvider');
  }
  return context;
}

```

### apps\web\app\(dashboard)\processing-batches\add\page.tsx:
```
'use client';

import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Button } from '@workspace/ui/components/button';
import { Progress } from '@workspace/ui/components/progress';
import { useEffect } from 'react';

import { SelectCriteriaStep } from './components/select-criteria-step';
import { SelectProcurementsStep } from './components/select-procurements-step';
import { FirstStageDetailsStep } from './components/first-stage-details-step';
import { ReviewAndSubmitStep } from './components/review-submit-step';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import axios from 'axios';
import type { FieldError, FieldErrorsImpl, Merge } from 'react-hook-form'; // Import types for error messages

export default function AddProcessingBatchPage() {
  const router = useRouter();
  const {
    activeStep,
    goToNextStep,
    goToPreviousTab,
    setInitialCriteria,
    initialCrop, // Use initial for criteria step
    initialLotNo, // Use initial for criteria step
    selectedProcurementIds,
    firstStageDetails,
    isSubmitting,
    setIsSubmitting,
    resetForm,
    form: currentStepForm,
    lockedCrop, // Use locked values for submission and later steps
    lockedLotNo,
    lockedProcuredForm,
  } = useProcessingBatchFormStore();

  useEffect(() => {
    return () => {
      // resetForm(); // Consider if this is desired on unmount
    };
  }, [resetForm]);

  const steps = [
    { id: 'selectCriteria', title: 'Select Criteria', progress: 25 },
    { id: 'selectProcurements', title: 'Select Procurements', progress: 50 },
    { id: 'firstStageDetails', title: 'First Stage Details (P1)', progress: 75 },
    { id: 'review', title: 'Review & Submit', progress: 100 },
  ];

  const currentStepConfig = steps.find(s => s.id === activeStep);

  const getFirstErrorMessage = (errors: Partial<Readonly<FieldErrorsImpl<any>>>): string | undefined => {
    if (errors.crop && typeof errors.crop.message === 'string') return errors.crop.message;
    if (errors.lotNo && typeof errors.lotNo.message === 'string') return errors.lotNo.message;
    // Check for schema level refine error (which might not have a specific field path if path is ["_error"] or just one path is given in refine)
    const refineErrorKey = Object.keys(errors).find(
      key => errors[key] && typeof errors[key]?.message === 'string' && !errors[key]?.ref
    );
    if (refineErrorKey && errors[refineErrorKey] && typeof errors[refineErrorKey]?.message === 'string') {
      return errors[refineErrorKey]?.message as string;
    }
    return undefined;
  };

  const handleNext = async () => {
    if (activeStep === 'selectCriteria') {
      if (currentStepForm) {
        const isValid = await currentStepForm.trigger();
        if (!isValid) {
          const firstError = getFirstErrorMessage(currentStepForm.formState.errors);
          toast.error(firstError || 'Please provide valid criteria (at least Crop or Lot No).'); // Updated message
          return;
        }
        const criteriaValues = currentStepForm.getValues();
        // criteriaValues.crop and criteriaValues.lotNo can be null/undefined here
        setInitialCriteria({
          crop: criteriaValues.crop || null,
          lotNo: typeof criteriaValues.lotNo === 'number' ? criteriaValues.lotNo : null,
        });
      } else {
        // This case should ideally not be hit if setForm works correctly
        setInitialCriteria({ crop: null, lotNo: null });
      }
    }
    if (activeStep === 'selectProcurements' && selectedProcurementIds.length === 0) {
      toast.error('Please select at least one procurement to form the batch.');
      return;
    }

    if (activeStep === 'firstStageDetails' && currentStepForm) {
      const isValid = await currentStepForm.trigger();
      if (!isValid) {
        toast.error(
          getFirstErrorMessage(currentStepForm.formState.errors) || 'Please fill in all required P1 details.'
        );
        return;
      }
      useProcessingBatchFormStore.getState().setFirstStageDetails(currentStepForm.getValues());
    }
    goToNextStep();
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      const p1Date = firstStageDetails.dateOfProcessing;
      let p1DateString: string | undefined = undefined;

      if (p1Date instanceof Date) {
        p1DateString = p1Date.toISOString();
      } else if (typeof p1Date === 'string') {
        try {
          p1DateString = new Date(p1Date).toISOString();
        } catch (e) {
          /* will be caught below */
        }
      }

      if (!p1DateString) {
        toast.error('P1 Date of Processing is missing or invalid.');
        setIsSubmitting(false);
        return;
      }
      if (!firstStageDetails.processMethod) {
        toast.error('P1 Process Method is missing.');
        setIsSubmitting(false);
        return;
      }
      if (!firstStageDetails.doneBy) {
        toast.error('P1 Done By is missing.');
        setIsSubmitting(false);
        return;
      }
      if (!lockedCrop || typeof lockedLotNo !== 'number' || !lockedProcuredForm) {
        toast.error(
          'Batch criteria (Crop, Lot No, Procured Form) are not fully determined. Please select procurements.'
        );
        setIsSubmitting(false);
        return;
      }

      const payload = {
        crop: lockedCrop,
        lotNo: lockedLotNo, // Already ensured it's a number in previous step's logic if it came from form
        procurementIds: selectedProcurementIds,
        firstStageDetails: {
          processMethod: firstStageDetails.processMethod,
          dateOfProcessing: p1DateString,
          doneBy: firstStageDetails.doneBy,
        },
      };

      const response = await axios.post('/api/processing-batches', payload, { withCredentials: true });

      if (response.status === 201) {
        toast.success('Processing Batch created successfully!');
        const dataChangedEvent = new CustomEvent('processingBatchDataChanged');
        document.dispatchEvent(dataChangedEvent);
        resetForm();
        router.push('/processing-batches');
      } else {
        throw new Error(response.data.error || 'Failed to create processing batch');
      }
    } catch (error: any) {
      console.error('Error creating processing batch:', error);
      const errorMsg =
        error.response?.data?.details?.[0]?.message ||
        error.response?.data?.error ||
        error.message ||
        'Something went wrong';
      toast.error(`Error: ${errorMsg}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handlePrevious = () => {
    goToPreviousTab();
  };

  return (
    <div className="p-4 md:p-6 max-w-4xl mx-auto space-y-6">
      <h1 className="text-2xl font-bold">Add New Processing Batch</h1>
      <Progress value={currentStepConfig?.progress || 0} className="w-full" />
      <p className="text-sm text-muted-foreground">Step: {currentStepConfig?.title}</p>
      <div className="mt-6">
        {activeStep === 'selectCriteria' && <SelectCriteriaStep />}
        {activeStep === 'selectProcurements' && <SelectProcurementsStep />}
        {activeStep === 'firstStageDetails' && <FirstStageDetailsStep />}
        {activeStep === 'review' && <ReviewAndSubmitStep />}
      </div>
      <div className="flex justify-between mt-8">
        <Button variant="outline" onClick={handlePrevious} disabled={activeStep === 'selectCriteria' || isSubmitting}>
          Previous
        </Button>
        {activeStep !== 'review' ? (
          <Button onClick={handleNext} disabled={isSubmitting}>
            Next
          </Button>
        ) : (
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? 'Submitting...' : 'Create Batch & Start P1'}
          </Button>
        )}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\select-criteria-step.tsx:
```
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Form, FormControl, FormField, FormItem, FormMessage } from '@workspace/ui/components/form';
import { useEffect } from 'react';

const CROP_OPTIONS = [
  'Turmeric',
  'Coffee',
  'Ginger',
  'Pepper',
  'Wheat',
  'Rice',
  'Maize',
  'Soybean',
  'Cotton',
  'Tea',
  'Spices',
] as const;

const criteriaSchema = z
  .object({
    crop: z.string().optional().nullable(),
    lotNo: z.coerce.number().int().min(1, 'Lot number must be a positive integer').optional().nullable(),
  })
  .refine(data => !!data.crop || (typeof data.lotNo === 'number' && !isNaN(data.lotNo)), {
    message: 'Either Crop or Lot Number (or both) must be provided.',
    path: ['crop'], // Error will be attached to 'crop' field if this refine fails
  });

type CriteriaFormValues = z.infer<typeof criteriaSchema>;

export function SelectCriteriaStep() {
  const { initialCrop, initialLotNo, setForm } = useProcessingBatchFormStore();

  const form = useForm<CriteriaFormValues>({
    resolver: zodResolver(criteriaSchema),
    defaultValues: {
      crop: initialCrop || null,
      lotNo: initialLotNo || null,
    },
  });

  useEffect(() => {
    if (setForm) {
      setForm(form as any);
    }
    return () => {
      if (setForm) {
        setForm(null);
      }
    };
  }, [form, setForm]);

  useEffect(() => {
    form.reset({
      crop: initialCrop || null,
      lotNo: initialLotNo || null,
    });
  }, [initialCrop, initialLotNo, form]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 1: Select Initial Criteria (Optional)</CardTitle>
        <CardDescription>
          Specify Crop and/or Lot Number to pre-filter procurements. If both are left blank, you'll define criteria
          based on your first procurement choice in the next step. To pre-filter, at least one field must be entered.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form className="space-y-6">
            <FormField
              control={form.control}
              name="crop"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="crop">Crop Name (Optional)</Label>
                  <Select
                    onValueChange={value => field.onChange(value === 'NONE_SELECTED_VALUE' ? null : value)}
                    value={field.value || undefined} // Pass undefined for placeholder
                  >
                    <FormControl>
                      <SelectTrigger id="crop">
                        <SelectValue placeholder="Select a crop (optional)" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {CROP_OPTIONS.map(cropName => (
                        <SelectItem key={cropName} value={cropName}>
                          {cropName}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                  {/* The refine error (if path is "crop") will show via FormMessage if crop field itself also has an error.
                      If only refine fails, FormMessage for crop might not show it if crop field input is valid on its own.
                      The parent page's toast error for this step is a more reliable way to show the refine error.
                  */}
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="lotNo"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="lotNo">Lot Number (Optional)</Label>
                  <FormControl>
                    <Input
                      id="lotNo"
                      type="number"
                      placeholder="Enter lot number (optional)"
                      value={field.value === null || field.value === undefined ? '' : String(field.value)}
                      onChange={e => {
                        const val = e.target.value;
                        field.onChange(val === '' ? null : isNaN(parseInt(val, 10)) ? null : parseInt(val, 10));
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            {/* Displaying the refine error specifically if it's attached to form.formState.errors.crop 
                and there's no other message from the field's own validators.
                This logic can be tricky. The toast in the parent is often clearer for overall step validation.
            */}
            {form.formState.errors.crop &&
              form.formState.errors.crop.type === 'manual' && ( // refine errors often appear as 'manual'
                <p className="text-sm text-red-500 mt-1">{form.formState.errors.crop.message}</p>
              )}
            {/* Or more generally, if the refine error is the *only* error for crop: */}
            {form.formState.errors.crop &&
              Object.keys(form.formState.errors.crop).length === 1 &&
              form.formState.errors.crop.message && (
                <p className="text-sm text-red-500 mt-1">{form.formState.errors.crop.message}</p>
              )}
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\first-stage-details-step.tsx:
```
'use client';

import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Form, FormControl, FormField, FormItem, FormMessage } from '@workspace/ui/components/form'; // Assuming FormLabel is part of this
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Button } from '@workspace/ui/components/button';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { useEffect } from 'react';

const firstStageFormStepSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z.date({
    required_error: 'Date of Processing is required',
    invalid_type_error: "That's not a valid date!",
  }),
  doneBy: z.string().min(1, 'Person responsible for P1 is required'),
});

type FirstStageFormValues = z.infer<typeof firstStageFormStepSchema>;

export function FirstStageDetailsStep() {
  const { firstStageDetails, setFirstStageDetails, form: zustandForm, setForm } = useProcessingBatchFormStore();

  const form = useForm<FirstStageFormValues>({
    resolver: zodResolver(firstStageFormStepSchema),
    defaultValues: {
      processMethod: firstStageDetails.processMethod || 'wet',
      dateOfProcessing:
        firstStageDetails.dateOfProcessing instanceof Date
          ? firstStageDetails.dateOfProcessing
          : firstStageDetails.dateOfProcessing
            ? new Date(firstStageDetails.dateOfProcessing as string)
            : new Date(),
      doneBy: firstStageDetails.doneBy || '',
    },
  });

  useEffect(() => {
    if (zustandForm !== form) {
      setForm(form as any);
    }
    const zustandDate = firstStageDetails.dateOfProcessing;
    form.reset({
      processMethod: firstStageDetails.processMethod || 'wet',
      dateOfProcessing:
        zustandDate instanceof Date ? zustandDate : zustandDate ? new Date(zustandDate as string) : new Date(),
      doneBy: firstStageDetails.doneBy || '',
    });
  }, [firstStageDetails, form, zustandForm, setForm]);

  const handleValueChangeAndSyncToZustand = () => {
    const values = form.getValues();
    setFirstStageDetails(values);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 3: First Processing Stage (P1) Details</CardTitle>
        <CardDescription>Enter the details for the initial processing stage of this batch.</CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onChange={handleValueChangeAndSyncToZustand} className="space-y-6">
            <FormField
              control={form.control}
              name="processMethod"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="processMethod">Process Method</Label>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger id="processMethod">
                        <SelectValue placeholder="Select process method" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="wet">Wet</SelectItem>
                      <SelectItem value="dry">Dry</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="dateOfProcessing"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <Label htmlFor="dateOfProcessing">Date of Processing (P1)</Label>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          id="dateOfProcessing"
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="doneBy"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="doneBy">Done By (Responsible Person/Team)</Label>
                  <FormControl>
                    <Input id="doneBy" placeholder="Enter name or team" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\select-procurements-step.tsx:
```
'use client';

import { useEffect, useState, useMemo } from 'react';
import axios from 'axios';
import { useProcessingBatchFormStore, type ProcurementWithFarmerForStore } from '@/app/stores/processing-batch-form'; // Import the type
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Checkbox } from '@workspace/ui/components/checkbox';
import { Input } from '@workspace/ui/components/input';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { toast } from 'sonner';
import { format } from 'date-fns';
import { Badge } from '@workspace/ui/components/badge';

interface DisplayProcurement extends ProcurementWithFarmerForStore {
  isSelectableBasedOnLock: boolean;
  matchesSearchTerm: boolean;
}

export function SelectProcurementsStep() {
  const {
    initialCrop,
    initialLotNo,
    availableProcurements, // Now ProcurementWithFarmerForStore[] from Zustand
    selectedProcurementIds,
    setAvailableProcurements,
    toggleSelectedProcurement,
    lockedCrop,
    lockedLotNo,
    lockedProcuredForm,
    filterCriteriaLocked,
  } = useProcessingBatchFormStore();

  const [isLoading, setIsLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    const fetchProcurements = async () => {
      setIsLoading(true);
      try {
        const params: any = {};
        if (initialCrop) params.crop = initialCrop;
        if (initialLotNo) params.lotNo = initialLotNo;

        // The backend response should match ProcurementWithFarmerForStore structure for the farmer field
        const response = await axios.get<{ procurements: ProcurementWithFarmerForStore[] }>(
          `/api/procurements/unbatched`,
          { params, withCredentials: true }
        );
        setAvailableProcurements(response.data.procurements);
      } catch (error) {
        console.error('Error fetching unbatched procurements:', error);
        toast.error('Failed to load unbatched procurements.');
        setAvailableProcurements([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchProcurements();
  }, [initialCrop, initialLotNo, setAvailableProcurements]);

  const displayListItems = useMemo((): DisplayProcurement[] => {
    const lowerSearchTerm = searchTerm.trim().toLowerCase();

    return availableProcurements.map((p: ProcurementWithFarmerForStore) => {
      // Explicitly type 'p'
      let isSelectableBasedOnLock = true;
      if (filterCriteriaLocked) {
        if (lockedCrop && p.crop !== lockedCrop) isSelectableBasedOnLock = false;
        if (lockedLotNo && p.lotNo !== lockedLotNo) isSelectableBasedOnLock = false;
        if (lockedProcuredForm && p.procuredForm !== lockedProcuredForm) isSelectableBasedOnLock = false;
      }

      let matchesSearchTerm = true;
      if (lowerSearchTerm) {
        matchesSearchTerm =
          p.farmer.name.toLowerCase().includes(lowerSearchTerm) || // Safe now
          p.procurementNumber.toLowerCase().includes(lowerSearchTerm) ||
          p.id.toString().includes(lowerSearchTerm) ||
          p.crop.toLowerCase().includes(lowerSearchTerm) ||
          p.procuredForm.toLowerCase().includes(lowerSearchTerm);
      }

      // p already includes the farmer object, so the spread is fine.
      return { ...p, isSelectableBasedOnLock, matchesSearchTerm };
    });
  }, [availableProcurements, searchTerm, filterCriteriaLocked, lockedCrop, lockedLotNo, lockedProcuredForm]);

  const itemsToRender = useMemo(() => {
    return displayListItems.filter(
      item => selectedProcurementIds.includes(item.id) || (item.isSelectableBasedOnLock && item.matchesSearchTerm)
    );
  }, [displayListItems, selectedProcurementIds]);

  const totalSelectedQuantity = useMemo(() => {
    return availableProcurements
      .filter(p => selectedProcurementIds.includes(p.id))
      .reduce((sum, p) => sum + p.quantity, 0);
  }, [availableProcurements, selectedProcurementIds]);

  const handleToggleSelection = (procurement: ProcurementWithFarmerForStore) => {
    // Expect the correct type
    toggleSelectedProcurement(procurement);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 2: Select Procurements</CardTitle>
        <CardDescription>
          {filterCriteriaLocked
            ? `Select procurements for batch: Crop: ${lockedCrop}, Lot: ${lockedLotNo}, Form: ${lockedProcuredForm}.`
            : initialCrop || initialLotNo
              ? `Showing initial procurements for: ${initialCrop || 'Any Crop'}, Lot: ${initialLotNo || 'Any Lot'}. First selection will lock full criteria.`
              : `Select your first procurement to set the Crop, Lot No, and Procured Form for this batch.`}
        </CardDescription>
        {filterCriteriaLocked && (
          <div className="mt-2 flex flex-wrap gap-2">
            <Badge variant="secondary">Crop: {lockedCrop}</Badge>
            <Badge variant="secondary">Lot: {lockedLotNo}</Badge>
            <Badge variant="secondary">Form: {lockedProcuredForm}</Badge>
          </div>
        )}
        {totalSelectedQuantity > 0 && (
          <p className="text-sm font-medium mt-2">Total Selected Quantity: {totalSelectedQuantity.toFixed(2)} kg</p>
        )}
      </CardHeader>
      <CardContent>
        <div className="mb-4">
          <Input
            placeholder="Filter list by Farmer, Proc. No., etc..."
            value={searchTerm}
            onChange={e => setSearchTerm(e.target.value)}
          />
        </div>
        {isLoading && <p className="text-center py-4">Loading procurements...</p>}
        {!isLoading && itemsToRender.length === 0 && (
          <p className="text-muted-foreground text-center py-4">
            No unbatched procurements found matching the criteria.
          </p>
        )}
        {!isLoading && itemsToRender.length > 0 && (
          <ScrollArea className="h-[300px] border rounded-md">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[50px]">Select</TableHead>
                  <TableHead>Proc. No.</TableHead>
                  <TableHead>Farmer</TableHead>
                  <TableHead>Crop</TableHead>
                  <TableHead>Proc. Form</TableHead>
                  <TableHead>Lot No.</TableHead>
                  <TableHead>Qty (kg)</TableHead>
                  <TableHead>Date</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {itemsToRender.map(proc => {
                  // proc is now DisplayProcurement, which includes farmer
                  const isChecked = selectedProcurementIds.includes(proc.id);
                  const isDisabledForSelection = filterCriteriaLocked && !proc.isSelectableBasedOnLock && !isChecked;

                  return (
                    <TableRow
                      key={proc.id}
                      data-state={isChecked && 'selected'}
                      className={isDisabledForSelection ? 'opacity-50' : ''}
                    >
                      <TableCell>
                        <Checkbox
                          id={`proc-${proc.id}`}
                          checked={isChecked}
                          onCheckedChange={() => handleToggleSelection(proc)}
                          disabled={isDisabledForSelection}
                        />
                      </TableCell>
                      <TableCell className="font-medium">{proc.procurementNumber}</TableCell>
                      <TableCell>{proc.farmer.name}</TableCell> {/* Safe now */}
                      <TableCell>{proc.crop}</TableCell>
                      <TableCell>{proc.procuredForm}</TableCell>
                      <TableCell>{proc.lotNo}</TableCell>
                      <TableCell className="text-right">{proc.quantity.toFixed(2)}</TableCell>
                      <TableCell>{format(new Date(proc.date), 'dd/MM/yyyy')}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </ScrollArea>
        )}
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\review-submit-step.tsx:
```
'use client';

import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Separator } from '@workspace/ui/components/separator';
import { useMemo } from 'react';
import { format } from 'date-fns';
import type { Procurement } from '@chaya/shared';

interface ProcurementWithFarmerForReview extends Procurement {
  farmer?: { name?: string };
}

export function ReviewAndSubmitStep() {
  const {
    lockedCrop, // Use locked values for review
    lockedLotNo,
    lockedProcuredForm,
    availableProcurements,
    selectedProcurementIds,
    firstStageDetails,
  } = useProcessingBatchFormStore();

  const selectedProcsDetails = useMemo(() => {
    return availableProcurements.filter(p => selectedProcurementIds.includes(p.id));
  }, [availableProcurements, selectedProcurementIds]);

  const totalInitialQuantity = useMemo(() => {
    return selectedProcsDetails.reduce((sum, p) => sum + p.quantity, 0);
  }, [selectedProcsDetails]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 4: Review and Submit</CardTitle>
        <CardDescription>
          Please review all details before creating the processing batch and its first stage (P1).
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div>
          <h3 className="text-lg font-semibold">Batch Criteria (Locked)</h3>
          <Separator className="my-2" />
          <div className="grid grid-cols-2 gap-2">
            <p className="font-medium">Crop:</p>
            <p>{lockedCrop || 'Not Set'}</p>
            <p className="font-medium">Lot Number:</p>
            <p>{lockedLotNo || 'Not Set'}</p>
            <p className="font-medium">Procured Form:</p>
            <p>{lockedProcuredForm || 'Not Set'}</p>
          </div>
        </div>

        <div>
          <h3 className="text-lg font-semibold">Selected Procurements ({selectedProcurementIds.length})</h3>
          <Separator className="my-2" />
          {selectedProcsDetails.length > 0 ? (
            <ul className="list-disc list-inside space-y-1 text-sm max-h-40 overflow-y-auto">
              {selectedProcsDetails.map(p => (
                <li key={p.id}>
                  Proc. No: {p.procurementNumber} - {p.quantity}kg - Farmer:{' '}
                  {(p as ProcurementWithFarmerForReview).farmer?.name || 'N/A'}
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-muted-foreground">No procurements selected.</p>
          )}
          <p className="font-semibold mt-2">Total Initial Batch Quantity: {totalInitialQuantity.toFixed(2)} kg</p>
        </div>

        <div>
          <h3 className="text-lg font-semibold">First Stage (P1) Details</h3>
          <Separator className="my-2" />
          <div className="grid grid-cols-2 gap-2">
            <p className="font-medium">Process Method:</p>
            <p>{firstStageDetails.processMethod}</p>
            <p className="font-medium">Date of Processing:</p>
            <p>
              {firstStageDetails.dateOfProcessing
                ? format(new Date(firstStageDetails.dateOfProcessing), 'PPP')
                : 'Not set'}
            </p>
            <p className="font-medium">Done By:</p>
            <p>{firstStageDetails.doneBy}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\procurements\page.tsx:
```
import { Suspense } from 'react';
import ProcurementsHeader from './components/procurements-header';
import Search from './components/search';
import ProcurementsTable from './components/procurements-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { ProcurementsCacheProvider } from './context/procurement-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
  }>;
}

export default async function ProcurementsPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;

  return (
    <ProcurementsCacheProvider>
      <div className="space-y-6 p-4">
        <ProcurementsHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Enter Proc. No., crop, farmer name" />
        </div>

        <Suspense key={query + currentPage.toString()} fallback={<Loading />}>
          <ProcurementsTableWithCache query={query} currentPage={currentPage} />
        </Suspense>
      </div>
    </ProcurementsCacheProvider>
  );
}

async function ProcurementsTableWithCache({ query, currentPage }: { query: string; currentPage: number }) {
  return (
    <>
      <ProcurementsTable query={query} currentPage={currentPage} />
      <PaginationWithCache query={query} />
    </>
  );
}

async function PaginationWithCache({ query }: { query: string }) {
  return <Pagination query={query} />;
}

```

### apps\web\app\(dashboard)\procurements\loading.tsx:
```
export default function Loading() {
  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
        <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
      </div>
      <div className="rounded-md border">
        <div className="h-12 border-b bg-secondary px-4 flex items-center">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
          ))}
        </div>
        {Array.from({ length: 10 }).map((_, i) => (
          <div key={i} className="border-b px-4 py-4 flex items-center">
            {Array.from({ length: 6 }).map((_, j) => (
              <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-form-dialog.tsx:
```
'use client';

import { ProcurementFormProvider } from '@/app/providers/procurement-form-provider';
import type { ProcurementWithRelations } from '../lib/types';
import { ProcurementForm } from '@/app/components/procurement-form/procurement-form';

interface ProcurementFormDialogProps {
  mode: 'add' | 'edit';
  procurement?: ProcurementWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function ProcurementFormDialog({ mode, procurement, open, onOpenChange }: ProcurementFormDialogProps) {
  return (
    <ProcurementFormProvider initialData={procurement} mode={mode}>
      <ProcurementForm mode={mode} open={open} onOpenChange={onOpenChange} procurementId={procurement?.id} />
    </ProcurementFormProvider>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\search.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Input } from '@workspace/ui/components/input';
import { useEffect, useState } from 'react';
import { useDebounce } from '@/app/hooks/use-debounce';

interface SearchProps {
  placeholder?: string;
}

export default function Search({ placeholder }: SearchProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [searchTerm, setSearchTerm] = useState(searchParams.get('query') || '');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    const params = new URLSearchParams(searchParams);

    if (debouncedSearchTerm) {
      params.set('query', debouncedSearchTerm);
    } else {
      params.delete('query');
    }

    params.set('page', '1'); // Reset to first page on search
    // router.push(`?${params.toString()}`);
  }, [debouncedSearchTerm, router, searchParams]);

  return (
    <div className="relative w-full md:w-80">
      <Input
        placeholder={placeholder || 'Search...'}
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        className="w-full"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-context-menu.tsx:
```
'use client';

import React, { useState } from 'react';
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuSeparator,
  ContextMenuTrigger,
} from '@workspace/ui/components/context-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Eye, Pencil, Trash2 } from 'lucide-react';
import { toast } from 'sonner';
import type { ProcurementWithRelations } from '../lib/types';
import { deleteProcurement } from '../lib/actions';

interface ProcurementContextMenuProps {
  children: React.ReactNode;
  procurement: ProcurementWithRelations;
  onEdit: () => void;
  isAdmin: boolean;
}

export function ProcurementContextMenu({ children, procurement, onEdit, isAdmin }: ProcurementContextMenuProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleView = () => {
    const event = new CustomEvent('viewProcurement', {
      detail: { procurement },
    });
    document.dispatchEvent(event);
  };

  const handleDelete = async () => {
    try {
      setIsDeleting(true);
      const result = await deleteProcurement(procurement.id);

      if (result.success) {
        toast.success('Procurement deleted', {
          description: `Proc. No. ${procurement.procurementNumber} has been successfully deleted.`,
        });

        const dataChangedEvent = new CustomEvent('procurementDataChanged');
        document.dispatchEvent(dataChangedEvent);
      } else {
        toast.error('Error', {
          description: result.error || 'Failed to delete procurement.',
        });
      }

      setShowDeleteDialog(false);
    } catch (error) {
      toast.error('Error', {
        description: 'An unexpected error occurred while deleting the procurement.',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <ContextMenu>
        <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>
        <ContextMenuContent className="w-48">
          <ContextMenuItem onClick={handleView}>
            <Eye className="mr-2 h-4 w-4" />
            View Details
          </ContextMenuItem>

          {isAdmin && (
            <>
              <ContextMenuSeparator />
              <ContextMenuItem onClick={onEdit}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit Procurement
              </ContextMenuItem>
              <ContextMenuItem
                onClick={() => setShowDeleteDialog(true)}
                className="text-destructive focus:text-destructive"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete Procurement
              </ContextMenuItem>
            </>
          )}
        </ContextMenuContent>
      </ContextMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete this procurement?</AlertDialogTitle>
            <AlertDialogDescription>
              {`This action cannot be undone. This will permanently delete procurement ${procurement.procurementNumber}.`}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\pagination.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { useProcurementsCache } from '../context/procurement-cache-context';
import { useEffect, useState } from 'react';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
}

export default function Pagination({ query }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { fetchTotalPages } = useProcurementsCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  const currentPage = Number(searchParams.get('page') || '1');

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query]);

  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-between px-2 mt-4">
      <div className="text-sm text-muted-foreground">
        Page {currentPage} of {totalPages}
      </div>
      <div className="flex items-center space-x-2">
        <Button variant="outline" size="icon" onClick={() => router.push(createPageURL(1))} disabled={currentPage <= 1}>
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage - 1))}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage + 1))}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(totalPages))}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\column-filter.tsx:
```
'use client';

import type { Table } from '@tanstack/react-table';
import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { SlidersHorizontal } from 'lucide-react';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-8">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          View
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[180px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => typeof column.accessorFn !== 'undefined' && column.getCanHide())
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurements-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useState } from 'react';
import { ProcurementFormDialog } from './procurement-form-dialog';
import { useAuth } from '@/app/providers/auth-provider';

export default function ProcurementsHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';

  const [showAddDialog, setShowAddDialog] = useState(false);

  const handleExport = () => {
    console.log('Export data clicked');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Procurement Dashboard</h1>
        <p className="text-gray-600">Manage and track crop procurements</p>
      </div>

      <div className="flex items-center gap-2">
        {isAdmin && (
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            className="h-9 bg-purple-500 text-white hover:bg-purple-600 hover:text-white"
          >
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )}

        <Button
          size="sm"
          onClick={() => setShowAddDialog(true)}
          className="h-9 bg-green-500 text-white hover:bg-green-600"
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Procurement
        </Button>

        <ProcurementFormDialog mode="add" open={showAddDialog} onOpenChange={setShowAddDialog} />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-details-dialog.tsx:
```
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import { Button } from '@workspace/ui/components/button';
import type { ProcurementWithRelations } from '../lib/types';
import { format } from 'date-fns';
import { Separator } from '@workspace/ui/components/separator';
import { ScrollArea } from '@workspace/ui/components/scroll-area';

interface ProcurementDetailsDialogProps {
  procurement: ProcurementWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function ProcurementDetailsDialog({ procurement, open, onOpenChange }: ProcurementDetailsDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>Procurement Details - {procurement.procurementNumber}</DialogTitle>
        </DialogHeader>

        <ScrollArea className="flex-grow mt-4 pr-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
            <div className="space-y-4">
              <div>
                <h3 className="text-lg font-semibold">Item Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Procurement No.:</span>
                  <span>{procurement.procurementNumber}</span>
                  <span className="font-medium text-muted-foreground">Crop:</span>
                  <span>{procurement.crop}</span>
                  <span className="font-medium text-muted-foreground">Procured Form:</span>
                  <span>{procurement.procuredForm}</span>
                  <span className="font-medium text-muted-foreground">Speciality:</span>
                  <span>{procurement.speciality}</span>
                  <span className="font-medium text-muted-foreground">Quantity:</span>
                  <span>{procurement.quantity} kg</span>
                  <span className="font-medium text-muted-foreground">Lot Number:</span>
                  <span>{procurement.lotNo}</span>
                </div>
              </div>

              <div>
                <h3 className="text-lg font-semibold mt-4">Procurement Details</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Date:</span>
                  <span>{format(new Date(procurement.date), 'dd/MM/yyyy')}</span>
                  <span className="font-medium text-muted-foreground">Time:</span>
                  <span>{format(new Date(procurement.time), 'hh:mm a')}</span>
                  <span className="font-medium text-muted-foreground">Procured By:</span>
                  <span>{procurement.procuredBy}</span>
                  <span className="font-medium text-muted-foreground">Vehicle Number:</span>
                  <span>{procurement.vehicleNo || 'N/A'}</span>
                </div>
              </div>
            </div>
            <div className="space-y-4">
              <div>
                <h3 className="text-lg font-semibold">Farmer Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Name:</span>
                  <span>{procurement.farmer.name}</span>
                  <span className="font-medium text-muted-foreground">Village:</span>
                  <span>{procurement.farmer.village}</span>
                  <span className="font-medium text-muted-foreground">Panchayath:</span>
                  <span>{procurement.farmer.panchayath}</span>
                  <span className="font-medium text-muted-foreground">Mandal:</span>
                  <span>{procurement.farmer.mandal}</span>
                </div>
              </div>

              <div>
                <h3 className="text-lg font-semibold mt-4">System Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Created At:</span>
                  <span>{format(new Date(procurement.createdAt), 'dd/MM/yyyy hh:mm a')}</span>
                  <span className="font-medium text-muted-foreground">Last Updated:</span>
                  <span>{format(new Date(procurement.updatedAt), 'dd/MM/yyyy hh:mm a')}</span>
                </div>
              </div>
            </div>
          </div>
        </ScrollArea>
        <DialogFooter className="mt-auto pt-4">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurements-table.tsx:
```
'use client';

import {
  flexRender,
  getCoreRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getPaginationRowModel,
  useReactTable,
} from '@tanstack/react-table';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { columns, defaultVisibleColumns } from '../lib/columns';
import { ColumnFilter } from './column-filter';
import { useState, useEffect } from 'react';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { useAuth } from '@/app/providers/auth-provider';
import { ProcurementContextMenu } from './procurement-context-menu';
import { ProcurementDetailsDialog } from './procurement-details-dialog';
import { ProcurementFormDialog } from './procurement-form-dialog';
import { bulkDeleteProcurements } from '../lib/actions';
import { Button } from '@workspace/ui/components/button';
import { RefreshCw, TrashIcon } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { toast } from 'sonner';
import { useProcurementsCache } from '../context/procurement-cache-context';
import type { ProcurementWithRelations } from '../lib/types';

interface ProcurementsTableProps {
  query: string;
  currentPage: number;
}

export default function ProcurementsTable({ query, currentPage }: ProcurementsTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchProcurements, prefetchPages, refreshCurrentPage } = useProcurementsCache();

  const [procurements, setProcurements] = useState<ProcurementWithRelations[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [viewingProcurement, setViewingProcurement] = useState<ProcurementWithRelations | null>(null);
  const [editingProcurement, setEditingProcurement] = useState<ProcurementWithRelations | null>(null);
  const [showViewDialog, setShowViewDialog] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showBulkDeleteDialog, setShowBulkDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const [rowSelection, setRowSelection] = useState({});

  const [columnVisibility, setColumnVisibility] = useState(() => {
    const initialVisibility: Record<string, boolean> = {};
    defaultVisibleColumns.forEach(col => {
      initialVisibility[col] = true;
    });
    return initialVisibility;
  });

  const loadData = async () => {
    setLoading(true);
    try {
      const data = await fetchProcurements(currentPage, query);
      setProcurements(data);

      const pagesToPrefetch = [];
      if (currentPage > 1) pagesToPrefetch.push(currentPage - 1);
      if (currentPage < 100) pagesToPrefetch.push(currentPage + 1);
      if (pagesToPrefetch.length > 0) {
        prefetchPages(Math.min(...pagesToPrefetch), Math.max(...pagesToPrefetch), query);
      }
    } catch (error) {
      toast.error("Failed to fetch procurements' data. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    if (refreshing) return;

    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPage(currentPage, query);
      setProcurements(freshData);
      toast.success('Data refreshed successfully');
      setRowSelection({});
    } catch (error) {
      toast.error('Failed to refresh data. Please try again.');
    } finally {
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadData();
  }, [fetchProcurements, prefetchPages, currentPage, query]);

  const table = useReactTable({
    data: procurements,
    columns,
    state: {
      columnVisibility,
      rowSelection,
    },
    enableRowSelection: isAdmin,
    onRowSelectionChange: setRowSelection,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  const handleViewDetails = (procurement: ProcurementWithRelations) => {
    setViewingProcurement(procurement);
    setShowViewDialog(true);
  };

  const handleEditProcurement = (procurement: ProcurementWithRelations) => {
    if (isAdmin) {
      setEditingProcurement(procurement);
      setShowEditDialog(true);
    } else {
      toast.error('You do not have permission to edit procurements.');
    }
  };

  const handleBulkDelete = async () => {
    setIsDeleting(true);
    try {
      const selectedProcurementIds = Object.keys(rowSelection)
        .map(index => {
          const idx = parseInt(index);
          return idx >= 0 && idx < procurements.length && procurements[idx] ? procurements[idx].id : null;
        })
        .filter((id): id is number => id !== null);

      if (selectedProcurementIds.length === 0) {
        toast.error('No procurements selected for deletion.');
        setShowBulkDeleteDialog(false);
        return;
      }

      const result = await bulkDeleteProcurements(selectedProcurementIds);

      if (result.success) {
        toast.success('Procurements deleted successfully.');
        await handleRefresh();
      } else {
        toast.error('Failed to delete procurements. Please try again.');
      }

      setShowBulkDeleteDialog(false);
    } catch (error) {
      toast.error('Failed to delete procurements. An unexpected error occurred.');
    } finally {
      setIsDeleting(false);
    }
  };

  useEffect(() => {
    const handleViewProcurementEvent = (e: CustomEvent<{ procurement: ProcurementWithRelations }>) => {
      handleViewDetails(e.detail.procurement);
    };
    const handleDataChangeEvent = () => {
      handleRefresh();
    };

    document.addEventListener('viewProcurement', handleViewProcurementEvent as EventListener);
    document.addEventListener('procurementDataChanged', handleDataChangeEvent as EventListener);

    return () => {
      document.removeEventListener('viewProcurement', handleViewProcurementEvent as EventListener);
      document.removeEventListener('procurementDataChanged', handleDataChangeEvent as EventListener);
    };
  }, [currentPage, query]);

  const selectedCount = Object.keys(rowSelection).length;

  if (loading && procurements.length === 0) {
    return (
      <div className="mt-6 space-y-4">
        <div className="flex justify-between items-center">
          <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
          <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4 flex items-center">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4 flex items-center">
              {Array.from({ length: 6 }).map((_, j) => (
                <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
              ))}
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-2">
          {isAdmin && selectedCount > 0 && (
            <div className="flex items-center gap-2">
              <span className="text-sm text-muted-foreground">{selectedCount} selected</span>
              <Button variant="destructive" size="sm" onClick={() => setShowBulkDeleteDialog(true)} className="h-8">
                <TrashIcon className="mr-2 h-4 w-4" />
                Delete Selected
              </Button>
            </div>
          )}

          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={refreshing || loading}
            className="h-8 ml-2"
          >
            <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
            {refreshing ? 'Refreshing...' : 'Refresh'}
          </Button>
        </div>
        <ColumnFilter table={table} />
      </div>
      <div className="rounded-md border overflow-x-auto">
        <ScrollArea className="h-[calc(100vh-350px)] w-full">
          <Table className="min-w-max">
            <TableHeader className="sticky top-0 bg-secondary">
              {table.getHeaderGroups().map(headerGroup => (
                <TableRow key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <TableHead key={header.id}>
                      {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                    </TableHead>
                  ))}
                </TableRow>
              ))}
            </TableHeader>
            <TableBody>
              {table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map(row => (
                  <ProcurementContextMenu
                    key={row.id}
                    procurement={row.original}
                    onEdit={() => handleEditProcurement(row.original)}
                    isAdmin={isAdmin}
                  >
                    <TableRow
                      data-state={row.getIsSelected() && 'selected'}
                      onDoubleClick={() => handleViewDetails(row.original)}
                      className="cursor-pointer hover:bg-muted/50"
                    >
                      {row.getVisibleCells().map(cell => (
                        <TableCell key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</TableCell>
                      ))}
                    </TableRow>
                  </ProcurementContextMenu>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={columns.length} className="h-24 text-center">
                    {loading || refreshing ? 'Loading...' : 'No procurements found.'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </ScrollArea>
      </div>

      {viewingProcurement && (
        <ProcurementDetailsDialog
          procurement={viewingProcurement}
          open={showViewDialog}
          onOpenChange={setShowViewDialog}
        />
      )}

      {isAdmin && editingProcurement && (
        <ProcurementFormDialog
          mode="edit"
          procurement={editingProcurement}
          open={showEditDialog}
          onOpenChange={setShowEditDialog}
        />
      )}

      <AlertDialog open={showBulkDeleteDialog} onOpenChange={setShowBulkDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete these procurements?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete {selectedCount} procurement records and all
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\lib\actions.ts:
```
'use server';

import axios from 'axios';
import { cookies } from 'next/headers';

const API_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

interface GetProcurementsParams {
  page?: number;
  query?: string;
}

export async function getProcurements({ page = 1, query = '' }: GetProcurementsParams) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.get(`${API_URL}/api/procurements`, {
      headers: {
        Cookie: `token=${token}`,
      },
      params: {
        page,
        limit: 10,
        search: query,
      },
      withCredentials: true,
    });

    return response.data.procurements;
  } catch (error) {
    console.error('Error fetching procurements:', error);
    throw error;
  }
}

export async function getProcurementPages(query = '') {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.get(`${API_URL}/api/procurements`, {
      headers: {
        Cookie: `token=${token}`,
      },
      params: {
        page: 1,
        limit: 10,
        search: query,
      },
      withCredentials: true,
    });

    const totalCount = response.data.pagination.totalCount;
    const totalPages = Math.ceil(totalCount / 10);
    return totalPages;
  } catch (error) {
    console.error('Error fetching procurement count:', error);
    throw error;
  }
}

export async function bulkDeleteProcurements(ids: number[]) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.delete(`${API_URL}/api/procurements/bulk`, {
      headers: {
        Cookie: `token=${token}`,
      },
      data: { ids },
      withCredentials: true,
    });

    return { success: true };
  } catch (error) {
    console.error('Error deleting procurements:', error);
    return { success: false };
  }
}

export async function deleteProcurement(id: number) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.delete(`${API_URL}/api/procurements/${id}`, {
      headers: {
        Cookie: `token=${token}`,
      },
      withCredentials: true,
    });

    return { success: true };
  } catch (error) {
    console.error('Error deleting procurement:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

```

### apps\web\app\(dashboard)\procurements\lib\types.ts:
```
import type { Procurement, Farmer } from '@chaya/shared';

export interface ProcurementWithRelations extends Procurement {
  farmer: Pick<Farmer, 'name' | 'village' | 'panchayath' | 'mandal'>;
}

```

### apps\web\app\(dashboard)\procurements\lib\columns.tsx:
```
'use client';

import type { ColumnDef } from '@tanstack/react-table';
import { Checkbox } from '@workspace/ui/components/checkbox';
import type { ProcurementWithRelations } from './types';
import { format } from 'date-fns';

export const defaultVisibleColumns = [
  'select',
  'procurementNumber',
  'crop',
  'farmerName',
  'quantity',
  'date',
  'procuredBy',
];

export const columns: ColumnDef<ProcurementWithRelations>[] = [
  {
    id: 'select',
    header: ({ table }) => (
      <Checkbox
        checked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && 'indeterminate')}
        onCheckedChange={value => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={value => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: 'procurementNumber',
    header: 'Proc. Number',
    cell: ({ row }) => <div className="font-medium">{row.getValue('procurementNumber')}</div>,
  },
  {
    accessorKey: 'crop',
    header: 'Crop',
    cell: ({ row }) => <div>{row.getValue('crop')}</div>,
  },
  {
    accessorKey: 'farmerName',
    header: 'Farmer',
    cell: ({ row }) => <div>{row.original.farmer.name}</div>,
  },
  {
    accessorKey: 'procuredForm',
    header: 'Form',
    cell: ({ row }) => <div>{row.getValue('procuredForm')}</div>,
  },
  {
    accessorKey: 'speciality',
    header: 'Speciality',
    cell: ({ row }) => <div>{row.getValue('speciality')}</div>,
  },
  {
    accessorKey: 'quantity',
    header: 'Quantity',
    cell: ({ row }) => <div>{row.getValue('quantity')} kg</div>,
  },
  {
    accessorKey: 'date',
    header: 'Date',
    cell: ({ row }) => <div>{format(new Date(row.original.date), 'dd/MM/yyyy')}</div>,
  },
  {
    accessorKey: 'time',
    header: 'Time',
    cell: ({ row }) => <div>{format(new Date(row.original.time), 'hh:mm a')}</div>,
  },
  {
    accessorKey: 'lotNo',
    header: 'Lot No',
    cell: ({ row }) => <div>{row.getValue('lotNo')}</div>,
  },
  {
    accessorKey: 'procuredBy',
    header: 'Procured By',
    cell: ({ row }) => <div>{row.getValue('procuredBy')}</div>,
  },
  {
    accessorKey: 'vehicleNo',
    header: 'Vehicle No',
    cell: ({ row }) => <div>{row.getValue('vehicleNo')}</div>,
  },
  {
    accessorKey: 'location',
    header: 'Location',
    cell: ({ row }) => (
      <div>
        {row.original.farmer.village}, {row.original.farmer.panchayath}, {row.original.farmer.mandal}
      </div>
    ),
  },
];

```

### apps\web\app\(dashboard)\procurements\context\procurement-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import { getProcurements, getProcurementPages } from '../lib/actions';
import { ProcurementWithRelations } from '../lib/types';
import { toast } from 'sonner';

interface ProcurementsCacheContextType {
  procurements: Record<string, ProcurementWithRelations[]>;
  totalPages: Record<string, number>;
  fetchProcurements: (page: number, query: string) => Promise<ProcurementWithRelations[]>;
  fetchTotalPages: (query: string) => Promise<number>;
  clearCache: () => void;
  prefetchPages: (startPage: number, endPage: number, query: string) => Promise<void>;
  refreshCurrentPage: (page: number, query: string) => Promise<ProcurementWithRelations[]>;
}

const ProcurementsCacheContext = createContext<ProcurementsCacheContextType | undefined>(undefined);

export function ProcurementsCacheProvider({ children }: { children: React.ReactNode }) {
  const [procurements, setProcurements] = useState<Record<string, ProcurementWithRelations[]>>({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});

  const createKey = useCallback((page: number, query: string) => `${query}:${page}`, []);

  const fetchProcurements = useCallback(
    async (page: number, query: string): Promise<ProcurementWithRelations[]> => {
      const key = createKey(page, query);

      if (procurements[key]) {
        console.log(`Using cached data for page ${page}, query "${query}"`);
        return procurements[key];
      }

      console.log(`Fetching page ${page}, query "${query}" from server`);
      try {
        const data = (await getProcurements({ page, query })) as ProcurementWithRelations[];
        setProcurements(prev => ({
          ...prev,
          [key]: data,
        }));
        return data;
      } catch (error) {
        toast.error('Failed to fetch procurements data from server.');
        throw error;
      }
    },
    [procurements, createKey]
  );

  const fetchTotalPages = useCallback(
    async (query: string): Promise<number> => {
      if (totalPages[query] !== undefined) {
        return totalPages[query];
      }

      try {
        const pages = await getProcurementPages(query);
        setTotalPages(prev => ({
          ...prev,
          [query]: pages,
        }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        throw error;
      }
    },
    [totalPages]
  );

  const prefetchPages = useCallback(
    async (startPage: number, endPage: number, query: string) => {
      console.log(`Prefetching pages ${startPage}-${endPage} for query "${query}"`);

      for (let page = startPage; page <= endPage; page++) {
        const key = createKey(page, query);

        if (procurements[key]) continue;

        try {
          const data = (await getProcurements({
            page,
            query,
          })) as ProcurementWithRelations[];
          setProcurements(prev => ({
            ...prev,
            [key]: data,
          }));
        } catch (error) {
          console.error(`Error prefetching page ${page}:`, error);
          toast.error(`Failed to prefetch data for page ${page}.`);
        }
      }
    },
    [procurements, createKey]
  );

  const refreshCurrentPage = useCallback(
    async (page: number, query: string): Promise<ProcurementWithRelations[]> => {
      const key = createKey(page, query);

      console.log(`Force refreshing page ${page}, query "${query}" from server`);
      try {
        const data = (await getProcurements({
          page,
          query,
        })) as ProcurementWithRelations[];
        setProcurements(prev => ({
          ...prev,
          [key]: data,
        }));
        fetchTotalPages(query);
        return data;
      } catch (error) {
        console.error(`Error refreshing page ${page}:`, error);
        toast.error(`Failed to refresh data for page ${page}.`);
        throw error;
      }
    },
    [createKey, fetchTotalPages]
  );

  const clearCache = useCallback(() => {
    setProcurements({});
    setTotalPages({});
    toast.success('Cache cleared successfully.');
  }, []);

  const value = {
    procurements,
    totalPages,
    fetchProcurements,
    fetchTotalPages,
    clearCache,
    prefetchPages,
    refreshCurrentPage,
  };

  return <ProcurementsCacheContext.Provider value={value}>{children}</ProcurementsCacheContext.Provider>;
}

export function useProcurementsCache() {
  const context = useContext(ProcurementsCacheContext);

  if (context === undefined) {
    throw new Error('useProcurementsCache must be used within a ProcurementsCacheProvider');
  }

  return context;
}

```

### apps\web\app\(dashboard)\staff\page.tsx:
```
import { Metadata } from 'next';
import { StaffDashboard } from './components/staff-dashboard';
import { AuthProvider } from '@/app/providers/auth-provider';

export const metadata: Metadata = {
  title: 'Staff Management',
  description: 'Manage your staff members',
};

export default function StaffManagementPage() {
  return (
    <AuthProvider>
      <div className="container mx-auto py-6">
        {/* <h1 className="text-2xl font-bold mb-6">Staff Management</h1> */}
        <StaffDashboard />
      </div>
    </AuthProvider>
  );
}

```

### apps\web\app\(dashboard)\staff\components\staff-dashboard.tsx:
```
'use client';

import { useState } from 'react';
import { StaffTable } from './staff-table';
import { AddStaffDialog } from './add-staff-dialog';
import { Button } from '@workspace/ui/components/button';
import { UserPlus } from 'lucide-react';
// import { useAuth } from '@/app/providers/auth-provider';

export function StaffDashboard() {
  const [isAddStaffOpen, setIsAddStaffOpen] = useState(false);
  // const { user } = useAuth();
  return (
    <div className="bg-white rounded-lg shadow">
      <div className="p-6 flex justify-between items-center border-b">
        <h2 className="text-xl font-semibold">Staff Members</h2>
        <Button onClick={() => setIsAddStaffOpen(true)}>
          <UserPlus className="mr-2 h-4 w-4" />
          Add Staff
        </Button>
      </div>

      <StaffTable />

      <AddStaffDialog open={isAddStaffOpen} onOpenChange={setIsAddStaffOpen} />
    </div>
  );
}

```

### apps\web\app\(dashboard)\staff\components\edit-staff-dialog.tsx:
```
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import axios from 'axios';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
  isEnabled: boolean;
}

const formSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters').optional().or(z.literal('')),
});

type FormValues = z.infer<typeof formSchema>;

interface EditStaffDialogProps {
  user: User;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onUserUpdated: () => void;
}

export function EditStaffDialog({ user, open, onOpenChange, onUserUpdated }: EditStaffDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: user.name,
      email: user.email,
      password: '',
    },
  });

  const onSubmit = async (data: FormValues) => {
    const updateData = {
      name: data.name,
      email: data.email,
      ...(data.password ? { password: data.password } : {}),
    };

    setIsSubmitting(true);
    try {
      await axios.put(`http://localhost:5000/api/users/${user.id}`, updateData);
      toast.success("Staff member's details updated successfully");
      onUserUpdated();
      onOpenChange(false);
    } catch (error: any) {
      toast.error("Failed to update staff member's details", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit Staff Member</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name</FormLabel>
                  <FormControl>
                    <Input {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Password</FormLabel>
                  <FormControl>
                    <Input type="password" placeholder="Leave blank to keep current password" {...field} />
                  </FormControl>
                  <FormDescription>Only enter a value if you want to change the password</FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="mt-6">
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Saving...' : 'Save Changes'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\staff\components\staff-table.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Badge } from '@workspace/ui/components/badge';
import { Switch } from '@workspace/ui/components/switch';
import { Input } from '@workspace/ui/components/input';
import { EditStaffDialog } from './edit-staff-dialog';
import { MoreHorizontal, Edit, Trash2, Search, UserCircle, Calendar, Mail, RefreshCw } from 'lucide-react';
import axios from 'axios';
import { formatDate, getTimeSince } from '../lib/utils';
import { toast } from 'sonner';
import { useAuth } from '@/app/providers/auth-provider';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
  isEnabled: boolean;
  isActive: boolean;
  lastLoginAt: string | null;
  createdAt: string;
}

export function StaffTable() {
  const [users, setUsers] = useState<User[]>([]);
  const [filteredUsers, setFilteredUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [userToDelete, setUserToDelete] = useState<User | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const { user } = useAuth();
  const axiosConfig = {
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredUsers(users);
    } else {
      const query = searchQuery.toLowerCase();
      setFilteredUsers(
        users.filter(
          user =>
            user.name.toLowerCase().includes(query) ||
            user.email.toLowerCase().includes(query) ||
            user.role.toLowerCase().includes(query)
        )
      );
    }
  }, [searchQuery, users]);

  const fetchUsers = async () => {
    setIsLoading(true);
    try {
      const response = await axios.get('http://localhost:5000/api/users', axiosConfig);
      setUsers(response.data.users);
      setFilteredUsers(response.data.users);
    } catch (error) {
      toast.error('Failed to fetch staff members');
    } finally {
      setIsLoading(false);
    }
  };

  const refreshUsers = async () => {
    setIsRefreshing(true);
    await fetchUsers();
    setIsRefreshing(false);
  };

  const handleEditUser = (user: User) => {
    setEditingUser(user);
    setIsEditDialogOpen(true);
  };

  const handleDeleteUser = (user: User) => {
    setUserToDelete(user);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteUser = async () => {
    if (!userToDelete) return;
    try {
      await axios.delete(`http://localhost:5000/api/users/${userToDelete.id}`, axiosConfig);
      toast.success('Staff member deleted successfully');
      fetchUsers();
    } catch (error: any) {
      toast('Failed to delete staff member');
    } finally {
      setIsDeleteDialogOpen(false);
      setUserToDelete(null);
    }
  };

  const toggleUserStatus = async (user: User) => {
    setUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: !u.isEnabled } : u)));
    setFilteredUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: !u.isEnabled } : u)));
    try {
      await axios.patch(`http://localhost:5000/api/users/${user.id}/toggle-status`, {}, axiosConfig);
      toast.success('Staff member status updated successfully');
    } catch (error: any) {
      setUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: user.isEnabled } : u)));
      setFilteredUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: user.isEnabled } : u)));
      toast.error('Failed to update staff member status');
    }
  };

  return (
    <div className="space-y-4">
      <div className="p-4 border-b flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div className="relative w-full sm:w-64">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
          <Input
            placeholder="Search staff members..."
            value={searchQuery}
            onChange={e => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
        <Button variant="outline" size="sm" onClick={refreshUsers} disabled={isRefreshing}>
          <RefreshCw className={`h-4 w-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      <div className="relative overflow-x-auto rounded-md">
        <Table className="border">
          <TableHeader className="bg-muted">
            <TableRow className="hover:bg-transparent">
              <TableHead className="w-[250px]">Staff Member</TableHead>
              <TableHead>Role</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Last Login</TableHead>
              <TableHead>Created</TableHead>
              <TableHead className="w-[100px] text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              Array.from({ length: 3 }).map((_, index) => (
                <TableRow key={`skeleton-${index}`} className="animate-pulse">
                  <TableCell>
                    <div className="flex items-center space-x-3">
                      <div className="h-10 w-10 rounded-full bg-gray-200"></div>
                      <div className="space-y-1">
                        <div className="h-4 w-24 bg-gray-200 rounded"></div>
                        <div className="h-3 w-32 bg-gray-200 rounded"></div>
                      </div>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="h-6 w-16 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-6 w-16 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-4 w-20 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-4 w-20 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-8 w-8 bg-gray-200 rounded float-right"></div>
                  </TableCell>
                </TableRow>
              ))
            ) : filteredUsers.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-8">
                  {searchQuery ? 'No staff members match your search' : 'No staff members found'}
                </TableCell>
              </TableRow>
            ) : (
              filteredUsers.map(user => (
                <TableRow key={user.id} className="hover:bg-gray-50">
                  <TableCell>
                    <div className="flex items-center space-x-3">
                      <div className="h-10 w-10 rounded-full bg-primary/10 flex items-center justify-center">
                        <UserCircle className="h-6 w-6 text-primary" />
                      </div>
                      <div>
                        <div className="font-medium">{user.name}</div>
                        <div className="text-sm text-muted-foreground flex items-center">
                          <Mail className="h-3 w-3 mr-1" />
                          {user.email}
                        </div>
                      </div>
                    </div>
                  </TableCell>
                  <TableCell>
                    <Badge
                      variant={user.role === 'ADMIN' ? 'default' : 'outline'}
                      className={user.role === 'ADMIN' ? 'bg-primary text-primary-foreground' : ''}
                    >
                      {user.role}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <div className="flex items-center space-x-2">
                      <Switch
                        checked={user.isEnabled}
                        disabled={user.role === 'ADMIN'}
                        onCheckedChange={() => toggleUserStatus(user)}
                      />
                      <span className={user.isEnabled ? 'text-green-600' : 'text-red-600'}>
                        {user.isEnabled ? 'Enabled' : 'Disabled'}
                      </span>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="flex flex-col">
                      <span>{formatDate(user.lastLoginAt)}</span>
                      {user.lastLoginAt && (
                        <span className="text-xs text-muted-foreground flex items-center">
                          <Calendar className="h-3 w-3 mr-1" />
                          {getTimeSince(user.lastLoginAt)}
                        </span>
                      )}
                    </div>
                  </TableCell>
                  <TableCell>{formatDate(user.createdAt)}</TableCell>
                  <TableCell className="text-right">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" className="h-8 w-8 p-0">
                          <span className="sr-only">Open menu</span>
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuLabel>Actions</DropdownMenuLabel>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem onClick={() => handleEditUser(user)}>
                          <Edit className="mr-2 h-4 w-4" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleDeleteUser(user)}
                          disabled={user.role === 'ADMIN'}
                          className={user.role === 'ADMIN' ? 'opacity-50' : 'text-red-600'}
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {editingUser && (
        <EditStaffDialog
          user={editingUser}
          open={isEditDialogOpen}
          onOpenChange={setIsEditDialogOpen}
          onUserUpdated={fetchUsers}
        />
      )}

      <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action will permanently delete the staff member account for{' '}
              <span className="font-semibold">{userToDelete?.name}</span>. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={confirmDeleteUser} className="bg-red-600 hover:bg-red-700 text-white">
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\staff\components\add-staff-dialog.tsx:
```
// app/staff/components/add-staff-dialog.tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import axios from 'axios';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';

// Form schema for validation
const formSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  role: z.enum(['ADMIN', 'STAFF']),
});

type FormValues = z.infer<typeof formSchema>;

interface AddStaffDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AddStaffDialog({ open, onOpenChange }: AddStaffDialogProps) {
  const axiosConfig = {
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      email: '',
      password: '',
      role: 'STAFF',
    },
  });

  const onSubmit = async (data: FormValues) => {
    setIsSubmitting(true);
    try {
      await axios.post('http://localhost:5000/api/auth/register', data, axiosConfig);
      toast.success('Staff member added successfully');
      form.reset();
      onOpenChange(false);
    } catch (error: any) {
      toast.error('Failed to add staff member', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Add New Staff Member</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name</FormLabel>
                  <FormControl>
                    <Input placeholder="John Doe" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" placeholder="john.doe@example.com" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Password</FormLabel>
                  <FormControl>
                    <Input type="password" placeholder="••••••••" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="role"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Role</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a role" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="STAFF">Staff</SelectItem>
                      <SelectItem value="ADMIN">Admin</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="mt-6">
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Adding...' : 'Add Staff Member'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\staff\lib\utils.ts:
```
export function formatDate(dateString: string | null): string {
  if (!dateString) return 'Never';

  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
  });
}

export function getTimeSince(dateString: string | null): string {
  if (!dateString) return 'Never logged in';

  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();

  const seconds = Math.floor(diffMs / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
  if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  return 'Just now';
}

```

### apps\web\app\stores\procurement-form.ts:
```
import { create } from 'zustand';
import type { UseFormReturn } from 'react-hook-form';
import type { ProcurementWithRelations } from '@/app/(dashboard)/procurements/lib/types';
import { z } from 'zod';
import { toast } from 'sonner';

const basicInfoSchemaForStore = z.object({
  farmerId: z.number({ required_error: 'Farmer is required' }),
  crop: z.string().min(1, 'Crop is required'),
  procuredForm: z.string().min(1, 'Procured form is required'),
  speciality: z.string().min(1, 'Speciality is required'),
  quantity: z
    .number({ required_error: 'Quantity is required', invalid_type_error: 'Quantity must be a number' })
    .positive('Quantity must be a positive number'),
});
const detailsSchemaForStore = z.object({
  date: z.date({ required_error: 'Date is required' }),
  time: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (expected HH:mm:ss)'),
  lotNo: z
    .number({ required_error: 'Lot number is required', invalid_type_error: 'Lot number must be a number' })
    .int()
    .min(1)
    .max(999, 'Lot number too high'),
  procuredBy: z.string().min(1, 'Procured by is required'),
  vehicleNo: z.string().min(1, 'Vehicle number is required').optional(),
});

export const procurementFullFormSchema = basicInfoSchemaForStore.merge(detailsSchemaForStore);
export type ProcurementFullFormValues = z.infer<typeof procurementFullFormSchema>;

// EXPORT TabType
export type TabType = 'basic' | 'details' | 'review';

interface ProcurementFormState {
  activeTab: TabType;
  setActiveTab: (tab: TabType) => void;
  goToNextTab: () => void;
  goToPreviousTab: () => void;
  form: UseFormReturn<ProcurementFullFormValues, any> | null;
  setForm: (form: UseFormReturn<ProcurementFullFormValues, any> | null) => void;
  isSubmitting: boolean;
  setIsSubmitting: (isSubmitting: boolean) => void;
  initialData: ProcurementWithRelations | null;
  mode: 'add' | 'edit';
  initializeForm: (initialData: ProcurementWithRelations | null | undefined, mode: 'add' | 'edit') => void;
}

export const useProcurementFormStore = create<ProcurementFormState>((set, get) => ({
  activeTab: 'basic',
  setActiveTab: tab => set({ activeTab: tab }),
  goToNextTab: async () => {
    const { activeTab, form } = get();
    if (form) {
      let fieldsToValidate: (keyof ProcurementFullFormValues)[] = [];
      if (activeTab === 'basic') {
        fieldsToValidate = ['farmerId', 'crop', 'procuredForm', 'speciality', 'quantity'];
      } else if (activeTab === 'details') {
        fieldsToValidate = ['date', 'time', 'lotNo', 'procuredBy', 'vehicleNo'];
      }

      if (fieldsToValidate.length > 0) {
        const isValid = await form.trigger(fieldsToValidate);
        if (!isValid) {
          toast.error('Please correct the errors on the current tab before proceeding.');
          return;
        }
      }
    }

    if (activeTab === 'basic') set({ activeTab: 'details' });
    else if (activeTab === 'details') set({ activeTab: 'review' });
  },
  goToPreviousTab: () => {
    const { activeTab } = get();
    if (activeTab === 'review') set({ activeTab: 'details' });
    else if (activeTab === 'details') set({ activeTab: 'basic' });
  },
  form: null,
  setForm: form => set({ form }),
  isSubmitting: false,
  setIsSubmitting: isSubmitting => set({ isSubmitting }),
  initialData: null,
  mode: 'add',
  initializeForm: (initialData, mode) => {
    set({
      initialData: initialData || null,
      mode,
      activeTab: 'basic',
      isSubmitting: false,
    });
  },
}));

```

### apps\web\app\stores\farmer-form.ts:
```
import { create } from 'zustand';
import { useForm } from 'react-hook-form';
import { differenceInYears } from 'date-fns';

type FormType = ReturnType<typeof useForm>;

export interface LocationData {
  lat: number;
  lng: number;
  accuracy: number;
  altitude: number | null;
  altitudeAccuracy: number | null;
  timestamp: number;
}

interface FarmerFormState {
  form: FormType | null;
  activeTab: string;
  isSubmitting: boolean;
  tabs: string[];
  setForm: (form: FormType | null) => void;
  setActiveTab: (tab: string) => void;
  addField: () => void;
  removeField: (index: number) => void;
  setIsSubmitting: (value: boolean) => void;
  goToNextTab: () => void;
  goToPreviousTab: () => void;
  resetForm: () => void;
  updateFieldLocation: (index: number, location: LocationData) => void;
  calculateAge: (birthDate: string) => void;
  notifyFormSuccess: () => void;
}

export const useFarmerFormStore = create<FarmerFormState>((set, get) => ({
  form: null,
  activeTab: 'personal',
  isSubmitting: false,
  tabs: ['personal', 'address', 'bank', 'documents', 'fields', 'review'],

  setForm: form => {
    console.log('Form set in store:', form ? 'Form object exists' : 'Form is null');
    set({ form });
  },
  setActiveTab: tab => set({ activeTab: tab }),

  addField: () => {
    const { form } = get();
    if (!form) return;

    const fields = form.getValues('fields') || [];
    form.setValue('fields', [
      ...fields,
      {
        areaHa: 0,
        yieldEstimate: 0,
        location: {
          lat: 0,
          lng: 0,
          accuracy: 0,
          altitude: null,
          altitudeAccuracy: null,
          timestamp: Date.now(),
        },
        landDocumentUrl: '',
      },
    ]);
  },

  removeField: index => {
    const { form } = get();
    if (!form) return;

    const fields = form.getValues('fields') || [];
    form.setValue(
      'fields',
      fields.filter((_: any, i: number) => i !== index)
    );
  },

  setIsSubmitting: value => set({ isSubmitting: value }),

  goToNextTab: () => {
    const { activeTab, tabs } = get();
    const currentIndex = tabs.indexOf(activeTab);
    if (currentIndex < tabs.length - 1) {
      set({ activeTab: tabs[currentIndex + 1] });
    }
  },

  goToPreviousTab: () => {
    const { activeTab, tabs } = get();
    const currentIndex = tabs.indexOf(activeTab);
    if (currentIndex > 0) {
      set({ activeTab: tabs[currentIndex - 1] });
    }
  },

  resetForm: () => {
    const { form } = get();
    if (form) {
      form.reset();
    }
    set({ activeTab: 'personal', isSubmitting: false });
  },

  updateFieldLocation: (index, location) => {
    const { form } = get();
    if (!form) return;

    form.setValue(`fields.${index}.location`, location);
  },

  calculateAge: birthDate => {
    const { form } = get();
    if (!form || !birthDate) return;

    const age = differenceInYears(new Date(), new Date(birthDate));
    form.setValue('farmer.age', age);
  },

  notifyFormSuccess: () => {
    if (typeof window !== 'undefined') {
      const dataChangedEvent = new CustomEvent('farmerDataChanged');
      document.dispatchEvent(dataChangedEvent);
      console.log('Form submission success event dispatched');
    }
  },
}));

```

### apps\web\app\stores\processing-batch-form.ts:
```
import { create } from 'zustand';
import type { UseFormReturn } from 'react-hook-form';
import type { Procurement as BaseProcurement, CreateProcessingBatchInput } from '@chaya/shared'; // Renamed to BaseProcurement
import { toast } from 'sonner';

// Define the procurement type as it's stored in this Zustand store
export interface ProcurementWithFarmerForStore extends BaseProcurement {
  farmer: { name: string; village?: string }; // village is optional if not always present/needed
}

type ProcessingBatchFormStep = 'selectCriteria' | 'selectProcurements' | 'firstStageDetails' | 'review';

interface ProcessingBatchFormState {
  activeStep: ProcessingBatchFormStep;
  setActiveStep: (step: ProcessingBatchFormStep) => void;
  goToNextStep: () => void;
  goToPreviousTab: () => void;

  initialCrop: string | null;
  initialLotNo: number | null;

  lockedCrop: string | null;
  lockedLotNo: number | null;
  lockedProcuredForm: string | null;
  filterCriteriaLocked: boolean;

  availableProcurements: ProcurementWithFarmerForStore[]; // USE THE NEW TYPE HERE
  selectedProcurementIds: number[];
  firstStageDetails: Partial<CreateProcessingBatchInput['firstStageDetails']>;

  setInitialCriteria: (criteria: { crop?: string | null; lotNo?: number | null }) => void;
  setAvailableProcurements: (procurements: ProcurementWithFarmerForStore[]) => void; // EXPECT THE NEW TYPE
  toggleSelectedProcurement: (procurement: ProcurementWithFarmerForStore) => void; // EXPECT THE NEW TYPE
  setFirstStageDetails: (details: Partial<CreateProcessingBatchInput['firstStageDetails']>) => void;

  clearLockedFilters: () => void;

  form: UseFormReturn<any> | null;
  setForm: (form: UseFormReturn<any> | null) => void;

  isSubmitting: boolean;
  setIsSubmitting: (isSubmitting: boolean) => void;

  resetForm: () => void;
}

const initialFirstStageDetailsState: Partial<CreateProcessingBatchInput['firstStageDetails']> = {
  processMethod: 'wet',
  dateOfProcessing: new Date(),
  doneBy: '',
};

const initialCoreState = {
  activeStep: 'selectCriteria' as ProcessingBatchFormStep,
  initialCrop: null,
  initialLotNo: null,
  lockedCrop: null,
  lockedLotNo: null,
  lockedProcuredForm: null,
  filterCriteriaLocked: false,
  availableProcurements: [],
  selectedProcurementIds: [],
  firstStageDetails: { ...initialFirstStageDetailsState },
  form: null,
  isSubmitting: false,
};

export const useProcessingBatchFormStore = create<ProcessingBatchFormState>((set, get) => ({
  ...initialCoreState,
  setActiveStep: step => set({ activeStep: step }),
  goToNextStep: () => {
    const { activeStep } = get();
    if (activeStep === 'selectCriteria') set({ activeStep: 'selectProcurements' });
    else if (activeStep === 'selectProcurements') set({ activeStep: 'firstStageDetails' });
    else if (activeStep === 'firstStageDetails') set({ activeStep: 'review' });
  },
  goToPreviousTab: () => {
    const { activeStep } = get();
    if (activeStep === 'review') set({ activeStep: 'firstStageDetails' });
    else if (activeStep === 'firstStageDetails') {
      set({ activeStep: 'selectProcurements' });
    } else if (activeStep === 'selectProcurements') {
      set({
        activeStep: 'selectCriteria',
        filterCriteriaLocked: false,
        lockedCrop: null,
        lockedLotNo: null,
        lockedProcuredForm: null,
        selectedProcurementIds: [],
      });
    }
  },

  setInitialCriteria: criteria =>
    set({
      initialCrop: criteria.crop || null,
      initialLotNo: criteria.lotNo || null,
      lockedCrop: criteria.crop || null,
      lockedLotNo: criteria.lotNo || null,
      lockedProcuredForm: null,
      filterCriteriaLocked: !!(criteria.crop && criteria.lotNo),
      selectedProcurementIds: [],
      availableProcurements: [],
    }),

  setAvailableProcurements: procurements => set({ availableProcurements: procurements }),

  toggleSelectedProcurement: procurement => {
    // procurement is ProcurementWithFarmerForStore
    set(state => {
      const isSelected = state.selectedProcurementIds.includes(procurement.id);
      let newSelectedIds = [...state.selectedProcurementIds];
      let newLockedCrop = state.lockedCrop;
      let newLockedLotNo = state.lockedLotNo;
      let newLockedProcuredForm = state.lockedProcuredForm;
      let newFilterCriteriaLocked = state.filterCriteriaLocked;

      if (isSelected) {
        newSelectedIds = newSelectedIds.filter(pid => pid !== procurement.id);
        if (newSelectedIds.length === 0) {
          newFilterCriteriaLocked = !!(state.initialCrop && state.initialLotNo);
          newLockedCrop = state.initialCrop;
          newLockedLotNo = state.initialLotNo;
          newLockedProcuredForm = null;
        }
      } else {
        // procurement.procuredForm is available because type is ProcurementWithFarmerForStore
        if (!state.filterCriteriaLocked || state.selectedProcurementIds.length === 0) {
          newLockedCrop = state.initialCrop || procurement.crop;
          newLockedLotNo = state.initialLotNo || procurement.lotNo;
          newLockedProcuredForm = procurement.procuredForm;
          newFilterCriteriaLocked = true;
          newSelectedIds.push(procurement.id);
        } else {
          if (
            procurement.crop === newLockedCrop &&
            procurement.lotNo === newLockedLotNo &&
            procurement.procuredForm === newLockedProcuredForm
          ) {
            newSelectedIds.push(procurement.id);
          } else {
            toast.error(
              'This procurement does not match the established batch criteria (Crop, Lot No, Procured Form).'
            );
          }
        }
      }
      return {
        selectedProcurementIds: newSelectedIds,
        lockedCrop: newLockedCrop,
        lockedLotNo: newLockedLotNo,
        lockedProcuredForm: newLockedProcuredForm,
        filterCriteriaLocked: newFilterCriteriaLocked,
      };
    });
  },

  setFirstStageDetails: details =>
    set(state => ({
      firstStageDetails: { ...state.firstStageDetails, ...details },
    })),

  clearLockedFilters: () =>
    set({
      lockedCrop: null,
      lockedLotNo: null,
      lockedProcuredForm: null,
      filterCriteriaLocked: false,
    }),

  setForm: form => set({ form }),
  setIsSubmitting: isSubmitting => set({ isSubmitting }),
  resetForm: () => set({ ...initialCoreState, firstStageDetails: { ...initialFirstStageDetailsState } }),
}));

```

### apps\web\utils\uploadthing.ts:
```
import { generateUploadButton, generateUploadDropzone, generateReactHelpers } from '@uploadthing/react';
import type { OurFileRouter } from '@/app/api/uploadthing/core';

// Explicit type annotations for each export
export const UploadButton: ReturnType<typeof generateUploadButton<OurFileRouter>> =
  generateUploadButton<OurFileRouter>();

export const UploadDropzone: ReturnType<typeof generateUploadDropzone<OurFileRouter>> =
  generateUploadDropzone<OurFileRouter>();

// Generate helpers, but do NOT export the object itself
const uploadHelpers: ReturnType<typeof generateReactHelpers<OurFileRouter>> = generateReactHelpers<OurFileRouter>();

export const useUploadThing: typeof uploadHelpers.useUploadThing = uploadHelpers.useUploadThing;
export const uploadFiles: typeof uploadHelpers.uploadFiles = uploadHelpers.uploadFiles;

```

### apps\api\index.ts:
```
console.log('Hello via Bun!');

```

### apps\api\src\index.ts:
```
import Fastify from 'fastify';
import cors from '@fastify/cors';
import jwt from '@fastify/jwt';
import cookie from '@fastify/cookie';

import authRoutes from './routes/auth';
import userRoutes from './routes/users';
import farmerRoutes from './routes/farmer';
import fieldRoutes from './routes/fields';
import procurementRoutes from './routes/procurement';
import processingBatchRoutes from './routes/processingBatch';
import processingStageRoutes from './routes/processingStage';
import salesRoutes from './routes/sales';
import helloWorldRoutes from './routes/helloWorld';

const fastify = Fastify({
  logger: {
    level: 'debug',
    transport: {
      target: 'pino-pretty',
      options: {
        colorize: true,
        translateTime: 'SYS:standard',
        ignore: 'pid,hostname',
      },
    },
  },
});

async function registerPlugins() {
  await fastify.register(cors, {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  });

  await fastify.register(jwt, {
    secret: process.env.JWT_SECRET || 'your-secret-key-change-in-production',
  });

  await fastify.register(cookie, {
    secret: process.env.COOKIE_SECRET || 'cookie-secret-change-in-production',
    hook: 'onRequest',
  });
}

async function registerRoutes() {
  fastify.register(authRoutes, { prefix: '/api/auth' });
  fastify.register(userRoutes, { prefix: '/api/users' });
  fastify.register(farmerRoutes, { prefix: '/api/farmers' });
  fastify.register(fieldRoutes, { prefix: '/api/fields' });
  fastify.register(procurementRoutes, { prefix: '/api/procurements' });
  fastify.register(processingBatchRoutes, { prefix: '/api/processing-batches' });
  fastify.register(processingStageRoutes, { prefix: '/api/processing-stages' });
  fastify.register(salesRoutes, { prefix: '/api/sales' });

  fastify.register(helloWorldRoutes, { prefix: '/api' });
}

async function start() {
  try {
    await registerPlugins();
    await registerRoutes();

    const port = process.env.PORT ? parseInt(process.env.PORT) : 5000;
    const host = process.env.HOST || '0.0.0.0';

    await fastify.listen({ port, host });
    console.log(`Server is running on ${host}:${port}`);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
}

start();

```

### apps\api\src\helper\index.ts:
```
import { prisma } from '@chaya/shared';
import { v4 as uuidv4 } from 'uuid';

export async function generateSurveyNumber(): Promise<string> {
  let isUnique = false;
  let surveyNumber = '';

  while (!isUnique) {
    const letters = Array.from({ length: 4 }, () => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
    const numbers = String(Math.floor(Math.random() * 10000000)).padStart(7, '0');
    surveyNumber = `${letters}${numbers}`;
    const exists = await prisma.farmer.findUnique({
      where: { surveyNumber },
    });
    if (!exists) isUnique = true;
  }
  return surveyNumber;
}

export function generateProcurementNumber(crop: string, date: Date, lotNo: number): string {
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = date.toISOString().split('T')[0].replace(/-/g, '');
  const lotCode = lotNo.toString();

  const randomSuffix = Math.random().toString(36).substring(2, 5).toUpperCase();
  const base = `${cropCode}${dateCode}${lotCode}${randomSuffix}`;
  const procurementNum = base.padEnd(14, '0');

  return procurementNum;
}

export async function generateProcessingBatchCode(
  crop: string,
  lotNo: number,
  dateOfProcessing: Date
): Promise<string> {
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = dateOfProcessing.toISOString().split('T')[0].replace(/-/g, '');
  const lotStr = lotNo.toString();

  let isUnique = false;
  let uniqueSuffix = '';
  let processingBatchCode = '';

  while (!isUnique) {
    uniqueSuffix = uuidv4().substring(0, 8).toUpperCase();
    processingBatchCode = `PBC-${cropCode}-${lotStr}-${dateCode}-${uniqueSuffix}`;

    const exists = await prisma.processingBatch.findUnique({
      where: { batchCode: processingBatchCode },
    });
    if (!exists) isUnique = true;
  }
  return processingBatchCode;
}

```

### apps\api\src\routes\auth.ts:
```
import type { FastifyInstance } from 'fastify';
import { hashPassword, verifyPassword } from '../lib/password';
import { prisma } from '@chaya/shared';
import { loginSchema, registerSchema } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest, type JWTPayload } from '../middlewares/auth'; // Use JWTPayload from here
import type { FastifyRequest, FastifyReply } from 'fastify';

// Interface JwtPayload (local) is removed, using JWTPayload from middlewares

async function authRoutes(fastify: FastifyInstance) {
  fastify.post('/login', async (request, reply) => {
    try {
      const { email, password } = loginSchema.parse(request.body);

      const user = await prisma.user.findUnique({
        where: { email },
      });

      if (!user) {
        return reply.status(401).send({ error: 'Invalid email or password' });
      }

      if (!user.isEnabled) {
        return reply.status(403).send({
          error: 'Your account has been disabled. Please contact an administrator.',
        });
      }

      const isPasswordValid = await verifyPassword(password, user.password);
      if (!isPasswordValid) {
        return reply.status(401).send({ error: 'Invalid email or password' });
      }

      const token = fastify.jwt.sign(
        {
          id: user.id,
          role: user.role,
        } as Omit<JWTPayload, 'iat' | 'exp'>, // Sign with core fields, iat/exp added by jwt.sign
        {
          expiresIn: '7d',
        }
      );

      await prisma.user.update({
        where: { id: user.id },
        data: {
          lastLoginAt: new Date(),
          isActive: true,
        },
      });

      reply.setCookie('token', token, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge in milliseconds
      });

      return {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      console.error('Login error:', error);
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.post('/logout', async (request, reply) => {
    try {
      if (request.cookies.token) {
        try {
          const decoded = fastify.jwt.verify<JWTPayload>(request.cookies.token);

          await prisma.user.update({
            where: { id: decoded.id },
            data: { isActive: false },
          });
        } catch (error) {
          // Token might be invalid or expired, clear cookie anyway
          console.warn('Token verification error on logout:', error);
        }
      }

      reply.clearCookie('token', {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
      });

      return { success: true };
    } catch (error) {
      console.error('Logout error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.post('/register', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    // const authRequest = request as AuthenticatedRequest; // Not needed here directly as verifyAdmin handles user existence
    try {
      const userData = registerSchema.parse(request.body);

      const existingUser = await prisma.user.findUnique({
        where: { email: userData.email },
      });

      if (existingUser) {
        return reply.status(400).send({ error: 'Email already in use' });
      }

      const hashedPassword = await hashPassword(userData.password);

      const newUser = await prisma.user.create({
        data: {
          name: userData.name,
          email: userData.email,
          password: hashedPassword,
          role: userData.role,
        },
      });

      return {
        user: {
          id: newUser.id,
          name: newUser.name,
          email: newUser.email,
          role: newUser.role,
        },
      };
    } catch (error) {
      console.error('Registration error:', error);
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.get('/me', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authRequest = request as AuthenticatedRequest;
    try {
      const user = await prisma.user.findUnique({
        where: { id: authRequest.user.id },
        select: {
          // Select only necessary fields
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true, // Good to check isEnabled on /me as well
        },
      });

      if (!user || !user.isEnabled) {
        // If user somehow got disabled after token issuance but before expiry
        reply.clearCookie('token', {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
        });
        return reply.status(401).send({ error: 'User not found or disabled' });
      }

      return {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      console.error('Get user error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default authRoutes;

```

### apps\api\src\routes\farmer.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createFarmerSchema, updateFarmerSchema, farmerQuerySchema } from '@chaya/shared';
import { Prisma } from '@chaya/shared';
import { generateSurveyNumber } from '../helper';
import Redis from 'ioredis';

const redis = new Redis();

function getFarmersCacheKey(query: any) {
  return `farmers:list:${JSON.stringify(query)}`;
}

async function invalidateFarmersCache(id?: string) {
  const keys = await redis.keys('farmers:list:*');
  if (keys.length) await redis.del(...keys);
}

async function farmerRoutes(fastify: FastifyInstance) {
  fastify.get('/', { preHandler: authenticate }, async (request, reply) => {
    const query = farmerQuerySchema.parse(request.query);
    const cacheKey = getFarmersCacheKey(query);
    const cached = await redis.get(cacheKey);
    if (cached) return JSON.parse(cached);

    const page = query.page || 1;
    const limit = query.limit || 10;
    const skip = (page - 1) * limit;

    const where: Prisma.FarmerWhereInput = {
      isActive: query.isActive,
    };

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { surveyNumber: { contains: query.search, mode: 'insensitive' } },
        { aadharNumber: { contains: query.search, mode: 'insensitive' } },
        { contactNumber: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    if (query.state) where.state = query.state;
    if (query.district) where.district = query.district;
    if (query.gender) where.gender = query.gender;

    const [farmers, totalCount] = await Promise.all([
      prisma.farmer.findMany({
        where,
        include: {
          documents: true,
          bankDetails: true,
          fields: true,
          createdBy: {
            select: {
              id: true,
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      prisma.farmer.count({ where }),
    ]);

    const result = {
      farmers,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    };

    await redis.set(cacheKey, JSON.stringify(result), 'EX', 3600);
    return result;
  });

  fastify.get('/:id', { preHandler: authenticate }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const cacheKey = `farmers:${id}`;
    const cached = await redis.get(cacheKey);
    if (cached) return { farmer: JSON.parse(cached) };

    const farmer = await prisma.farmer.findUnique({
      where: { id: parseInt(id) },
      include: {
        documents: true,
        bankDetails: true,
        fields: true,
        createdBy: {
          select: {
            id: true,
            name: true,
          },
        },
        updatedBy: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!farmer) {
      return reply.status(404).send({ error: 'Farmer not found' });
    }

    await redis.set(cacheKey, JSON.stringify(farmer), 'EX', 3600);
    return { farmer };
  });

  fastify.post('/', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;
      const { farmer, bankDetails, documents, fields } = createFarmerSchema.parse(request.body);

      const existingFarmer = await prisma.farmer.findFirst({
        where: {
          OR: [{ surveyNumber: farmer.surveyNumber }, { aadharNumber: farmer.aadharNumber }],
        },
      });

      if (existingFarmer) {
        return reply.status(400).send({
          error: 'A farmer with this survey number or Aadhar number already exists',
        });
      }
      const surveyNumber = await generateSurveyNumber();
      const newFarmer = await prisma.farmer.create({
        data: {
          ...farmer,
          surveyNumber,
          createdById: authRequest.user.id,
          updatedById: authRequest.user.id,
          bankDetails: {
            create: bankDetails,
          },
          documents: {
            create: documents,
          },
          fields: {
            create: fields || [],
          },
        },
        include: {
          bankDetails: true,
          documents: true,
          fields: true,
        },
      });

      await invalidateFarmersCache();
      return { farmer: newFarmer };
    } catch (error) {
      if ((error as any).code === 'P2002') {
        return reply.status(400).send({ error: 'Unique constraint violation' });
      }
      return reply.status(400).send({ error: 'Invalid request data' });
    }
  });

  fastify.put('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;
      const { id } = request.params as { id: string };
      const updateData = updateFarmerSchema.parse(request.body);

      const existingFarmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
        include: {
          bankDetails: true,
          documents: true,
          fields: true,
        },
      });

      if (!existingFarmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const updatedFarmer = await prisma.$transaction(async tx => {
        const farmer = await tx.farmer.update({
          where: { id: parseInt(id) },
          data: {
            ...updateData.farmer,
            updatedById: authRequest.user.id,
          },
        });

        if (updateData.bankDetails && existingFarmer.bankDetails) {
          await tx.bankDetails.update({
            where: { farmerId: farmer.id },
            data: updateData.bankDetails,
          });
        } else if (updateData.bankDetails && !existingFarmer.bankDetails) {
          if (
            !updateData.bankDetails.ifscCode ||
            !updateData.bankDetails.bankName ||
            !updateData.bankDetails.branchName ||
            !updateData.bankDetails.accountNumber ||
            !updateData.bankDetails.address ||
            !updateData.bankDetails.bankCode
          ) {
            throw new Error('All bank details fields are required when creating new bank details');
          }
          await tx.bankDetails.create({
            data: {
              ifscCode: updateData.bankDetails.ifscCode,
              bankName: updateData.bankDetails.bankName,
              branchName: updateData.bankDetails.branchName,
              accountNumber: updateData.bankDetails.accountNumber,
              address: updateData.bankDetails.address,
              bankCode: updateData.bankDetails.bankCode,
              farmerId: farmer.id,
            },
          });
        }

        if (updateData.documents && existingFarmer.documents) {
          await tx.farmerDocuments.update({
            where: { farmerId: farmer.id },
            data: updateData.documents,
          });
        } else if (updateData.documents && !existingFarmer.documents) {
          if (
            !updateData.documents.profilePicUrl ||
            !updateData.documents.aadharDocUrl ||
            !updateData.documents.bankDocUrl
          ) {
            throw new Error('All document URLs are required when creating new documents');
          }
          await tx.farmerDocuments.create({
            data: {
              profilePicUrl: updateData.documents.profilePicUrl,
              aadharDocUrl: updateData.documents.aadharDocUrl,
              bankDocUrl: updateData.documents.bankDocUrl,
              farmerId: farmer.id,
            },
          });
        }

        if (updateData.fields?.length) {
          const invalidFields = updateData.fields.filter(
            field => !field.areaHa || !field.yieldEstimate || !field.location || !field.landDocumentUrl
          );
          if (invalidFields.length > 0) {
            throw new Error('All field properties are required when creating new fields');
          }
          await tx.field.deleteMany({
            where: { farmerId: farmer.id },
          });
          await tx.field.createMany({
            data: updateData.fields.map(field => ({
              areaHa: field.areaHa!,
              yieldEstimate: field.yieldEstimate!,
              location: field.location!,
              landDocumentUrl: field.landDocumentUrl!,
              farmerId: farmer.id,
            })),
          });
        }

        return tx.farmer.findUnique({
          where: { id: farmer.id },
          include: {
            bankDetails: true,
            documents: true,
            fields: true,
          },
        });
      });

      await invalidateFarmersCache(id);
      return { farmer: updatedFarmer };
    } catch (error) {
      if (error instanceof Error && error.message.includes('required')) {
        return reply.status(400).send({ error: error.message });
      }
      return reply.status(400).send({ error: 'Invalid request data' });
    }
  });

  fastify.patch('/:id/toggle-status', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const authRequest = request as AuthenticatedRequest;

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const updatedFarmer = await prisma.farmer.update({
        where: { id: parseInt(id) },
        data: {
          isActive: !farmer.isActive,
          updatedById: authRequest.user.id,
        },
        include: {
          bankDetails: true,
          documents: true,
        },
      });

      await invalidateFarmersCache(id);
      return { farmer: updatedFarmer };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      await prisma.farmer.delete({
        where: { id: parseInt(id) },
      });

      await invalidateFarmersCache(id);
      return { success: true };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/export', { preHandler: authenticate }, async (request, reply) => {
    try {
      const query = farmerQuerySchema.parse(request.query);

      const where: Prisma.FarmerWhereInput = {
        isActive: query.isActive,
      };

      if (query.search) {
        where.OR = [
          { name: { contains: query.search, mode: 'insensitive' } },
          { surveyNumber: { contains: query.search, mode: 'insensitive' } },
          { aadharNumber: { contains: query.search, mode: 'insensitive' } },
          { contactNumber: { contains: query.search, mode: 'insensitive' } },
        ];
      }

      if (query.state) where.state = query.state;
      if (query.district) where.district = query.district;
      if (query.gender) where.gender = query.gender;

      const limit = query.limit || 1000;

      const farmers = await prisma.farmer.findMany({
        where,
        include: {
          bankDetails: true,
        },
        orderBy: { name: 'asc' },
        take: limit,
      });

      const csvData = farmers.map(farmer => ({
        ID: farmer.id,
        SurveyNumber: farmer.surveyNumber,
        Name: farmer.name,
        Gender: farmer.gender,
        Community: farmer.community,
        AadharNumber: farmer.aadharNumber,
        State: farmer.state,
        District: farmer.district,
        Mandal: farmer.mandal,
        Village: farmer.village,
        Panchayath: farmer.panchayath,
        DateOfBirth: farmer.dateOfBirth.toISOString().split('T')[0],
        Age: farmer.age,
        ContactNumber: farmer.contactNumber,
        BankName: farmer.bankDetails?.bankName || '',
        BranchName: farmer.bankDetails?.branchName || '',
        AccountNumber: farmer.bankDetails?.accountNumber || '',
        IFSC: farmer.bankDetails?.ifscCode || '',
      }));

      const headers = Object.keys(csvData[0] || {}).join(',');

      const rows = csvData.map(row => {
        return Object.values(row)
          .map(value => {
            if (typeof value === 'string') {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          })
          .join(',');
      });

      const csv = [headers, ...rows].join('\n');

      reply.header('Content-Type', 'text/csv');
      reply.header('Content-Disposition', 'attachment; filename=farmers.csv');

      return csv;
    } catch (error) {
      return reply.status(400).send({ error: 'Invalid query parameters' });
    }
  });
}

export default farmerRoutes;

```

### apps\api\src\routes\processingBatch.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma, ProcessingStageStatus as PrismaProcessingStageStatus } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createProcessingBatchSchema, processingBatchQuerySchema } from '@chaya/shared';
import { generateProcessingBatchCode } from '../helper'; // Ensure this uses the global prisma, not 'tx'
import Redis from 'ioredis';

const redis = new Redis();

// ... (invalidateProcessingCache and ExtendedProcessingStageStatus type) ...
async function invalidateProcessingCache(batchId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*');
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) keysToDelete.push(`processing-batch:${batchId}`);
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

type ExtendedProcessingStageStatus = PrismaProcessingStageStatus | 'SOLD_OUT' | 'NO_STAGES';

async function processingBatchRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const { crop, lotNo, procurementIds, firstStageDetails } = createProcessingBatchSchema.parse(request.body);
      const userId = authUser.id;

      if (!procurementIds || procurementIds.length === 0) {
        return reply.status(400).send({ error: 'At least one procurement ID must be provided.' });
      }

      const procurements = await prisma.procurement.findMany({
        where: {
          id: { in: procurementIds },
          crop: { equals: crop, mode: 'insensitive' },
          lotNo: lotNo,
          processingBatchId: null,
        },
      });

      if (procurements.length !== procurementIds.length) {
        return reply
          .status(400)
          .send({ error: 'One or more procurement IDs are invalid, do not match crop/lot, or are already batched.' });
      }

      const initialBatchQuantity = procurements.reduce((sum, p) => sum + p.quantity, 0);
      if (initialBatchQuantity <= 0) {
        return reply.status(400).send({ error: 'Total quantity for the batch must be positive.' });
      }

      // 1. Generate the batch code *before* starting the transaction.
      // The dateOfProcessing from firstStageDetails is a string, convert to Date for the helper.
      const dateForBatchCode = new Date(firstStageDetails.dateOfProcessing);
      if (isNaN(dateForBatchCode.getTime())) {
        return reply.status(400).send({ error: 'Invalid dateOfProcessing for batch code generation.' });
      }
      const uniqueProcessingBatchCode = await generateProcessingBatchCode(crop, lotNo, dateForBatchCode);

      const result = await prisma.$transaction(
        async tx => {
          const newBatch = await tx.processingBatch.create({
            data: {
              batchCode: uniqueProcessingBatchCode, // Use the pre-generated code
              crop,
              lotNo,
              initialBatchQuantity,
              createdById: userId,
              procurements: { connect: procurementIds.map(id => ({ id })) },
            },
          });

          // firstStageDetails.dateOfProcessing is a string from Zod, convert to Date for Prisma
          const p1DateOfProcessing = new Date(firstStageDetails.dateOfProcessing);
          if (isNaN(p1DateOfProcessing.getTime())) {
            // This should ideally be caught by Zod schema validation if it's strict on format
            throw new Error('Invalid dateOfProcessing for P1 stage.');
          }

          await tx.processingStage.create({
            data: {
              processingBatchId: newBatch.id,
              processingCount: 1,
              processMethod: firstStageDetails.processMethod,
              dateOfProcessing: p1DateOfProcessing,
              doneBy: firstStageDetails.doneBy,
              initialQuantity: initialBatchQuantity,
              status: 'IN_PROGRESS',
              createdById: userId,
            },
          });

          // Reload the batch with its first stage for the response, using the transaction client 'tx'
          return tx.processingBatch.findUnique({
            where: { id: newBatch.id },
            include: { processingStages: { orderBy: { processingCount: 'asc' }, take: 1 } },
          });
        },
        {
          maxWait: 10000, // Optional: Increase maxWait if needed (milliseconds)
          timeout: 10000, // Optional: Increase timeout if needed (milliseconds)
        }
      ); // End of transaction

      await invalidateProcessingCache();
      return reply.status(201).send({ batch: result }); // Send the result of the transaction
    } catch (error: any) {
      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2028') {
        console.error('Transaction timeout error:', error);
        return reply.status(500).send({ error: 'Server operation timed out, please try again.' });
      }
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Create processing batch error:', error);
      return reply.status(500).send({ error: 'Server error creating processing batch' });
    }
  });

  fastify.get('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const query = processingBatchQuerySchema.parse(request.query);
    const cacheKey = `processing-batches:list:${JSON.stringify(query)}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) return JSON.parse(cached);

      const page = query.page || 1;
      const limit = query.limit || 10;
      const skip = (page - 1) * limit;

      const where: Prisma.ProcessingBatchWhereInput = {};
      if (query.search) {
        where.OR = [
          { batchCode: { contains: query.search, mode: 'insensitive' } },
          { crop: { contains: query.search, mode: 'insensitive' } },
        ];
      }

      const queryStatus = query.status as ExtendedProcessingStageStatus | undefined;
      const applySoldOutFilterLogic = queryStatus === 'SOLD_OUT';

      if (
        queryStatus &&
        !applySoldOutFilterLogic &&
        Object.values(PrismaProcessingStageStatus).includes(queryStatus as PrismaProcessingStageStatus)
      ) {
        const batchesWithLatestStageStatus = await prisma.processingBatch.findMany({
          where,
          select: {
            id: true,
            processingStages: { orderBy: { processingCount: 'desc' }, take: 1, select: { status: true } },
          },
        });
        const batchIdsFilteredByStatus = batchesWithLatestStageStatus
          .filter(b => b.processingStages.length > 0 && b.processingStages[0].status === queryStatus)
          .map(b => b.id);

        if (batchIdsFilteredByStatus.length === 0 && queryStatus) {
          return { processingBatches: [], pagination: { page, limit, totalCount: 0, totalPages: 0 } };
        }
        if (where.id && typeof where.id === 'object' && !Array.isArray(where.id) && 'in' in where.id) {
          (where.id as Prisma.IntFilter).in = batchIdsFilteredByStatus;
        } else {
          where.id = { in: batchIdsFilteredByStatus };
        }
      }

      const allCandidateBatches = await prisma.processingBatch.findMany({
        where,
        include: {
          processingStages: {
            orderBy: { processingCount: 'desc' },
            include: {
              dryingEntries: { orderBy: { day: 'desc' }, take: 1 },
              sales: { select: { quantitySold: true } },
            },
          },
          sales: { select: { quantitySold: true, processingStageId: true } },
        },
        orderBy: { createdAt: 'desc' },
      });

      const transformedAndFilteredBatches = allCandidateBatches
        .map(batch => {
          const latestStage = batch.processingStages[0];
          let physicalQuantityAtLatestPoint: number = 0;
          let effectiveStatus: ExtendedProcessingStageStatus = 'NO_STAGES';

          if (latestStage) {
            effectiveStatus = latestStage.status;
            if (latestStage.status === PrismaProcessingStageStatus.IN_PROGRESS) {
              physicalQuantityAtLatestPoint =
                latestStage.dryingEntries[0]?.currentQuantity ?? latestStage.initialQuantity;
            } else if (latestStage.status === PrismaProcessingStageStatus.FINISHED) {
              physicalQuantityAtLatestPoint = latestStage.quantityAfterProcess ?? 0;
            } else if (latestStage.status === PrismaProcessingStageStatus.CANCELLED) {
              physicalQuantityAtLatestPoint = 0;
            }
          } else {
            physicalQuantityAtLatestPoint = batch.initialBatchQuantity;
          }

          const totalQuantitySoldFromBatch = batch.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
          const netAvailableQuantity = physicalQuantityAtLatestPoint;

          if (effectiveStatus === PrismaProcessingStageStatus.FINISHED && netAvailableQuantity <= 0) {
            effectiveStatus = 'SOLD_OUT';
          }

          return {
            id: batch.id,
            batchCode: batch.batchCode,
            crop: batch.crop,
            lotNo: batch.lotNo,
            initialBatchQuantity: batch.initialBatchQuantity,
            createdAt: batch.createdAt,
            // ... other fields from ProcessingBatch if needed ...
            latestStageSummary: latestStage
              ? {
                  id: latestStage.id,
                  processingCount: latestStage.processingCount,
                  status: effectiveStatus,
                  processMethod: latestStage.processMethod,
                  dateOfProcessing: latestStage.dateOfProcessing,
                  doneBy: latestStage.doneBy,
                  initialQuantity: latestStage.initialQuantity,
                  quantityAfterProcess: latestStage.quantityAfterProcess,
                  lastDryingQuantity: latestStage.dryingEntries[0]?.currentQuantity ?? null,
                }
              : null,
            totalQuantitySoldFromBatch,
            netAvailableQuantity,
          };
        })
        .filter(b => {
          if (applySoldOutFilterLogic) {
            return b.latestStageSummary?.status === 'SOLD_OUT';
          }
          return true;
        });

      const finalTotalCount = transformedAndFilteredBatches.length;
      const paginatedBatches = transformedAndFilteredBatches.slice(skip, skip + limit);

      const result = {
        processingBatches: paginatedBatches,
        pagination: { page, limit, totalCount: finalTotalCount, totalPages: Math.ceil(finalTotalCount / limit) },
      };
      await redis.set(cacheKey, JSON.stringify(result), 'EX', 3600);
      return result;
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid query parameters', details: error.issues });
      console.error('Get processing batches error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:batchId', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { batchId } = request.params as { batchId: string };
    const id = parseInt(batchId);
    if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Batch ID' });

    const cacheKey = `processing-batch:${id}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        const parsedCached = JSON.parse(cached);
        const latestStageForCached = parsedCached.processingStages
          ?.slice()
          .sort((a: any, b: any) => b.processingCount - a.processingCount)[0];
        let currentPotentialOutputCached: number = parsedCached.initialBatchQuantity;
        let effectiveStatusCached: ExtendedProcessingStageStatus = latestStageForCached
          ? latestStageForCached.status
          : 'NO_STAGES';

        if (latestStageForCached) {
          if (latestStageForCached.status === 'IN_PROGRESS') {
            currentPotentialOutputCached =
              latestStageForCached.dryingEntries?.slice().sort((a: any, b: any) => b.day - a.day)[0]?.currentQuantity ??
              latestStageForCached.initialQuantity;
          } else if (latestStageForCached.status === 'FINISHED') {
            currentPotentialOutputCached = latestStageForCached.quantityAfterProcess || 0;
          } else if (latestStageForCached.status === 'CANCELLED') {
            currentPotentialOutputCached = 0;
          }
        }
        const totalSoldCached = parsedCached.sales?.reduce((sum: number, sale: any) => sum + sale.quantitySold, 0) || 0;
        const netAvailableCached = Math.max(0, currentPotentialOutputCached - totalSoldCached);

        if (latestStageForCached && latestStageForCached.status === 'FINISHED' && netAvailableCached <= 0) {
          effectiveStatusCached = 'SOLD_OUT';
        }
        parsedCached.netAvailableQuantity = netAvailableCached;

        // Ensure latestStageSummary exists and update its status
        if (latestStageForCached) {
          parsedCached.latestStageSummary = {
            ...(parsedCached.latestStageSummary || {
              // Create if not exists from old cache
              id: latestStageForCached.id,
              processingCount: latestStageForCached.processingCount,
              processMethod: latestStageForCached.processMethod,
              dateOfProcessing: latestStageForCached.dateOfProcessing,
              doneBy: latestStageForCached.doneBy,
              initialQuantity: latestStageForCached.initialQuantity,
              quantityAfterProcess: latestStageForCached.quantityAfterProcess,
              lastDryingQuantity:
                latestStageForCached.dryingEntries?.slice().sort((a: any, b: any) => b.day - a.day)[0]
                  ?.currentQuantity ?? null,
            }),
            status: effectiveStatusCached,
          };
        } else if (parsedCached.latestStageSummary) {
          parsedCached.latestStageSummary.status = effectiveStatusCached;
        }

        return parsedCached;
      }

      const batchFromDb = await prisma.processingBatch.findUnique({
        where: { id },
        include: {
          procurements: { include: { farmer: { select: { name: true, village: true } } } },
          processingStages: {
            include: { dryingEntries: { orderBy: { day: 'asc' } }, sales: { select: { quantitySold: true } } },
            orderBy: { processingCount: 'asc' },
          },
          sales: {
            orderBy: { dateOfSale: 'desc' },
            include: { processingStage: { select: { processingCount: true } } },
          },
          createdBy: { select: { id: true, name: true } },
        },
      });

      if (!batchFromDb) return reply.status(404).send({ error: 'Processing batch not found' });

      const stages = batchFromDb.processingStages.sort((a, b) => b.processingCount - a.processingCount);
      const latestStage = stages[0];

      let physicalQuantityAtLatestPoint: number = batchFromDb.initialBatchQuantity;
      let effectiveStatus: ExtendedProcessingStageStatus = 'NO_STAGES';

      if (latestStage) {
        effectiveStatus = latestStage.status;
        if (latestStage.status === PrismaProcessingStageStatus.IN_PROGRESS) {
          physicalQuantityAtLatestPoint =
            latestStage.dryingEntries?.slice().sort((a, b) => b.day - a.day)[0]?.currentQuantity ??
            latestStage.initialQuantity;
        } else if (latestStage.status === PrismaProcessingStageStatus.FINISHED) {
          physicalQuantityAtLatestPoint = latestStage.quantityAfterProcess ?? 0;
        } else if (latestStage.status === PrismaProcessingStageStatus.CANCELLED) {
          physicalQuantityAtLatestPoint = 0;
        }
      }

      const totalQuantitySoldFromBatch = batchFromDb.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
      const netAvailableQuantity = physicalQuantityAtLatestPoint;

      if (effectiveStatus === PrismaProcessingStageStatus.FINISHED && netAvailableQuantity <= 0) {
        effectiveStatus = 'SOLD_OUT';
      }

      const latestStageSummaryData = latestStage
        ? {
            id: latestStage.id,
            processingCount: latestStage.processingCount,
            status: effectiveStatus,
            processMethod: latestStage.processMethod,
            dateOfProcessing: latestStage.dateOfProcessing,
            doneBy: latestStage.doneBy,
            initialQuantity: latestStage.initialQuantity,
            quantityAfterProcess: latestStage.quantityAfterProcess,
            lastDryingQuantity:
              latestStage.dryingEntries?.slice().sort((a, b) => b.day - a.day)[0]?.currentQuantity ?? null,
          }
        : null;

      const batchWithDetails = {
        ...batchFromDb,
        totalQuantitySoldFromBatch,
        netAvailableQuantity,
        latestStageSummary: latestStageSummaryData,
      };

      await redis.set(cacheKey, JSON.stringify(batchWithDetails), 'EX', 3600);
      return batchWithDetails;
    } catch (error) {
      console.error(`Error fetching batch ${id}:`, error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:batchId', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { batchId } = request.params as { batchId: string };
    const id = parseInt(batchId);
    if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Batch ID' });

    try {
      const batch = await prisma.processingBatch.findUnique({ where: { id } });
      if (!batch) return reply.status(404).send({ error: 'Processing batch not found.' });

      await prisma.$transaction(async tx => {
        await tx.procurement.updateMany({
          where: { processingBatchId: id },
          data: { processingBatchId: null },
        });
        await tx.processingBatch.delete({ where: { id } });
      });

      await invalidateProcessingCache(id);
      return { success: true, message: `Processing batch ${batch.batchCode} deleted.` };
    } catch (error) {
      console.error(`Error deleting batch ${id}:`, error);
      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        return reply.status(404).send({ error: 'Processing batch not found.' });
      }
      return reply.status(500).send({ error: 'Server error deleting batch.' });
    }
  });

  return fastify; // Ensure fastify instance is returned
}

export default processingBatchRoutes;

```

### apps\api\src\routes\sales.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createSaleSchema } from '@chaya/shared';
import Redis from 'ioredis';

const redis = new Redis();

async function invalidateSalesCache(batchId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*');
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) keysToDelete.push(`processing-batch:${batchId}`);
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

async function salesRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const userId = authUser.id;
      const parsedSaleData = createSaleSchema.parse(request.body);
      const { processingBatchId, processingStageId, quantitySold, dateOfSale } = parsedSaleData;

      const stage = await prisma.processingStage.findUnique({
        where: { id: processingStageId },
        include: { processingBatch: true },
      });

      if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
      if (stage.processingBatchId !== processingBatchId) {
        return reply.status(400).send({ error: 'Stage does not belong to the specified batch.' });
      }
      if (stage.status !== 'FINISHED') {
        return reply.status(400).send({ error: 'Sales can only be recorded from FINISHED processing stages.' });
      }

      const salesFromThisStage = await prisma.sale.aggregate({
        _sum: { quantitySold: true },
        where: { processingStageId: stage.id },
      });
      const alreadySoldFromStage = salesFromThisStage._sum.quantitySold || 0;
      const availableFromStage = (stage.quantityAfterProcess || 0) - alreadySoldFromStage;

      if (availableFromStage < quantitySold) {
        return reply.status(400).send({
          error: `Insufficient quantity available from stage P${stage.processingCount}. Available: ${availableFromStage.toFixed(2)} kg.`,
        });
      }

      const newSale = await prisma.sale.create({
        data: {
          processingBatchId,
          processingStageId,
          quantitySold,
          dateOfSale,
          createdById: userId,
        },
      });

      await invalidateSalesCache(processingBatchId);
      return reply.status(201).send(newSale);
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Record sale error:', error);
      return reply.status(500).send({ error: 'Server error recording sale' });
    }
  });

  // GET route remains the same
  fastify.get('/', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { processingBatchId, processingStageId } = request.query as {
      processingBatchId?: string;
      processingStageId?: string;
    };
    const where: Prisma.SaleWhereInput = {};
    if (processingBatchId) where.processingBatchId = parseInt(processingBatchId);
    if (processingStageId) where.processingStageId = parseInt(processingStageId);

    const sales = await prisma.sale.findMany({
      where,
      include: {
        processingBatch: { select: { batchCode: true, crop: true } },
        processingStage: { select: { processingCount: true } },
        createdBy: { select: { name: true } },
      },
      orderBy: { dateOfSale: 'desc' },
    });
    return sales;
  });
}

export default salesRoutes;

```

### apps\api\src\routes\procurement.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin } from '../middlewares/auth';
import { createProcurementSchema, updateProcurementSchema, procurementQuerySchema } from '@chaya/shared';
import { generateProcurementNumber } from '../helper';
import { Prisma } from '@prisma/client';
import { format } from 'date-fns';

async function procurementRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { farmerId, crop, procuredForm, speciality, quantity, date, time, lotNo, procuredBy, vehicleNo } =
        createProcurementSchema.parse(request.body);

      const combinedDateTime = new Date(`${date.toISOString().split('T')[0]}T${time}`);
      if (isNaN(combinedDateTime.getTime())) {
        return reply.status(400).send({ error: 'Invalid date or time combination' });
      }

      const procurementNumber = generateProcurementNumber(crop, date, lotNo);

      const existingProcurement = await prisma.procurement.findUnique({
        where: { procurementNumber },
      });

      if (existingProcurement) {
        return reply.status(400).send({
          error: 'Procurement number already exists. This might indicate a duplicate entry or a hash collision (rare).',
        });
      }

      const farmerExists = await prisma.farmer.findUnique({ where: { id: farmerId } });
      if (!farmerExists) {
        return reply.status(404).send({ error: 'Farmer not found.' });
      }

      const procurement = await prisma.procurement.create({
        data: {
          farmerId,
          crop,
          procuredForm,
          speciality,
          quantity,
          procurementNumber,
          date,
          time: combinedDateTime,
          lotNo,
          procuredBy,
          vehicleNo,
        },
      });

      return { procurement };
    } catch (error: any) {
      if (error.issues) {
        return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      }
      console.error('Create procurement error:', error);
      return reply.status(500).send({ error: 'Server error creating procurement' });
    }
  });

  fastify.get('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const {
        page,
        limit,
        search,
        farmerId,
        crop,
        lotNo: queryLotNo,
        isBatched,
      } = procurementQuerySchema.parse(request.query);
      const skip = (page - 1) * limit;
      const where: Prisma.ProcurementWhereInput = {};

      if (search) {
        where.OR = [
          { procurementNumber: { contains: search, mode: 'insensitive' } },
          { crop: { contains: search, mode: 'insensitive' } },
          { procuredBy: { contains: search, mode: 'insensitive' } },
          { farmer: { name: { contains: search, mode: 'insensitive' } } },
        ];
      }
      if (farmerId) where.farmerId = farmerId;
      if (crop) where.crop = { contains: crop, mode: 'insensitive' };
      if (queryLotNo) where.lotNo = queryLotNo;

      if (typeof isBatched === 'boolean') {
        where.processingBatchId = isBatched ? { not: null } : { equals: null };
      }

      const [procurements, totalCount] = await Promise.all([
        prisma.procurement.findMany({
          where,
          include: {
            farmer: { select: { id: true, name: true, village: true, panchayath: true, mandal: true } },
            processingBatch: { select: { id: true, batchCode: true } },
          },
          orderBy: { createdAt: 'desc' },
          skip,
          take: limit,
        }),
        prisma.procurement.count({ where }),
      ]);

      return {
        procurements,
        pagination: { page, limit, totalCount, totalPages: Math.ceil(totalCount / limit) },
      };
    } catch (error: any) {
      if (error.issues) {
        return reply.status(400).send({ error: 'Invalid query parameters', details: error.issues });
      }
      console.error('Get procurements error:', error);
      return reply.status(500).send({ error: 'Server error fetching procurements' });
    }
  });

  fastify.get('/unbatched', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { crop, lotNo } = request.query as { crop?: string; lotNo?: string }; // Removed procuredForm as it's not used here

      const whereClause: Prisma.ProcurementWhereInput = {
        processingBatchId: null,
      };

      if (crop) {
        whereClause.crop = { equals: crop, mode: 'insensitive' };
      }
      if (lotNo) {
        const parsedLotNo = parseInt(lotNo, 10);
        if (!isNaN(parsedLotNo)) {
          whereClause.lotNo = parsedLotNo;
        }
      }

      const unbatchedProcurements = await prisma.procurement.findMany({
        where: whereClause,
        include: { farmer: { select: { name: true, village: true } } },
        orderBy: [{ date: 'asc' }, { id: 'asc' }],
        take: 500,
      });
      return { procurements: unbatchedProcurements };
    } catch (error) {
      console.error('Error fetching unbatched procurements:', error);
      // Log the actual Prisma error if it's a Prisma error
      if (
        error instanceof Prisma.PrismaClientKnownRequestError ||
        error instanceof Prisma.PrismaClientValidationError
      ) {
        console.error('Prisma Error Meta:', (error as any).meta);
      }
      return reply.status(500).send({ error: 'Failed to fetch unbatched procurements' });
    }
  });

  fastify.get('/:id', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const procurement = await prisma.procurement.findUnique({
        where: { id: procurementId },
        include: {
          farmer: { select: { name: true, village: true, panchayath: true, mandal: true } },
          processingBatch: { select: { id: true, batchCode: true } },
        },
      });

      if (!procurement) return reply.status(404).send({ error: 'Procurement not found' });
      return { procurement };
    } catch (error) {
      console.error('Get procurement error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.put('/:id', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const data = updateProcurementSchema.parse({ ...(request.body as object), id: procurementId });

      const existingProcurement = await prisma.procurement.findUnique({ where: { id: procurementId } });
      if (!existingProcurement) return reply.status(404).send({ error: 'Procurement not found' });
      if (existingProcurement.processingBatchId) {
        return reply.status(400).send({ error: 'Cannot edit procurement already assigned to a processing batch.' });
      }

      let combinedDateTime;
      const newDate = data.date ? data.date : existingProcurement.date;
      const newTimeStr = data.time ? data.time : format(existingProcurement.time, 'HH:mm:ss');

      combinedDateTime = new Date(`${format(newDate, 'yyyy-MM-dd')}T${newTimeStr}`);

      if (isNaN(combinedDateTime.getTime())) {
        return reply.status(400).send({ error: 'Invalid date or time combination resulted' });
      }

      const updatedProcurement = await prisma.procurement.update({
        where: { id: procurementId },
        data: {
          farmerId: data.farmerId,
          crop: data.crop,
          procuredForm: data.procuredForm,
          speciality: data.speciality,
          quantity: data.quantity,
          date: data.date,
          time: combinedDateTime,
          lotNo: data.lotNo,
          procuredBy: data.procuredBy,
          vehicleNo: data.vehicleNo,
        },
      });
      return { procurement: updatedProcurement };
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Update procurement error:', error);
      return reply.status(500).send({ error: 'Server error updating procurement' });
    }
  });

  fastify.delete('/:id', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const procurement = await prisma.procurement.findUnique({ where: { id: procurementId } });
      if (!procurement) return reply.status(404).send({ error: 'Procurement not found' });
      if (procurement.processingBatchId) {
        return reply.status(400).send({
          error: 'Cannot delete procurement already assigned to a processing batch. Remove from batch first.',
        });
      }

      await prisma.procurement.delete({ where: { id: procurementId } });
      return { success: true };
    } catch (error) {
      console.error('Delete procurement error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/bulk', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { ids } = request.body as { ids?: number[] };
      if (!Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({ error: 'Invalid or empty list of IDs' });
      }
      const validIds = ids.filter(id => typeof id === 'number' && !isNaN(id));
      if (validIds.length !== ids.length) {
        return reply.status(400).send({ error: 'All IDs must be numbers.' });
      }

      const batchedProcurements = await prisma.procurement.count({
        where: { id: { in: validIds }, processingBatchId: { not: null } },
      });
      if (batchedProcurements > 0) {
        return reply
          .status(400)
          .send({ error: 'One or more selected procurements are part of a batch and cannot be deleted.' });
      }

      const { count } = await prisma.procurement.deleteMany({ where: { id: { in: validIds } } });
      return { success: true, message: `${count} procurements deleted.` };
    } catch (error) {
      console.error('Bulk delete procurements error:', error);
      return reply.status(500).send({ error: 'Server error during bulk delete' });
    }
  });
}

export default procurementRoutes;

```

### apps\api\src\routes\users.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { updateUserSchema } from '@chaya/shared';
import { hashPassword } from '../lib/password';
import Redis from 'ioredis';

const redis = new Redis();

async function userRoutes(fastify: FastifyInstance) {
  fastify.get('/', { preHandler: verifyAdmin }, async (request, reply) => {
    const cacheKey = 'users:all';
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        return { users: JSON.parse(cached) };
      }
      const users = await prisma.user.findMany({
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          createdAt: true,
        },
        orderBy: { createdAt: 'desc' },
      });
      await redis.set(cacheKey, JSON.stringify(users), 'EX', 3600);
      return { users };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const cacheKey = `users:${id}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        return { user: JSON.parse(cached) };
      }
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          createdAt: true,
        },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      await redis.set(cacheKey, JSON.stringify(user), 'EX', 3600);
      return { user };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.put('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const userData = updateUserSchema.parse(request.body);
      const existingUser = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!existingUser) {
        return reply.status(404).send({ error: 'User not found' });
      }
      const updateData: any = {};
      if (userData.name) updateData.name = userData.name;
      if (userData.email) updateData.email = userData.email;
      if (userData.isEnabled !== undefined) updateData.isEnabled = userData.isEnabled;
      if (userData.password) {
        updateData.password = await hashPassword(userData.password);
      }
      const updatedUser = await prisma.user.update({
        where: { id: parseInt(id) },
        data: updateData,
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          updatedAt: true,
        },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { user: updatedUser };
    } catch (error) {
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.patch('/:id/toggle-status', { preHandler: verifyAdmin }, async (request, reply) => {
    const authRequest = request as AuthenticatedRequest;
    try {
      const { id } = authRequest.params as { id: string };
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      const updatedUser = await prisma.user.update({
        where: { id: parseInt(id) },
        data: { isEnabled: !user.isEnabled },
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
        },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { user: updatedUser };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      if (user.role === 'ADMIN') {
        return reply.status(403).send({ error: 'Cannot delete admin users' });
      }
      await prisma.user.delete({
        where: { id: parseInt(id) },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { success: true };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default userRoutes;

```

### apps\api\src\routes\fields.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin } from '../middlewares/auth';
import type { AuthenticatedRequest } from '../middlewares/auth';

import { fieldSchema } from '@chaya/shared';

async function fieldRoutes(fastify: FastifyInstance) {
  fastify.get('/farmer/:farmerId', { preHandler: authenticate }, async (request, reply) => {
    try {
      const { farmerId } = request.params as { farmerId: string };

      const fields = await prisma.field.findMany({
        where: { farmerId: parseInt(farmerId) },
        orderBy: { createdAt: 'desc' },
      });

      return { fields };
    } catch (error) {
      console.error('Get fields error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:id', { preHandler: authenticate }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      return { field };
    } catch (error) {
      console.error('Get field error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.post('/farmer/:farmerId', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { farmerId } = request.params as { farmerId: string };
      const fieldData = fieldSchema.parse(request.body);

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(farmerId) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const field = await prisma.field.create({
        data: {
          ...fieldData,
          farmerId: parseInt(farmerId),
        },
      });

      await prisma.farmer.update({
        where: { id: parseInt(farmerId) },
        data: { updatedById: authRequest.user.id },
      });

      return { field };
    } catch (error) {
      console.error('Create field error:', error);
      return reply.status(400).send({ error: 'Invalid field data' });
    }
  });

  fastify.put('/:id', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { id } = request.params as { id: string };
      const fieldData = fieldSchema.parse(request.body);

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      if (authRequest.user.role !== 'ADMIN') {
        const farmer = await prisma.farmer.findUnique({
          where: { id: field.farmerId },
        });

        if (farmer?.createdById !== authRequest.user.id) {
          return reply.status(403).send({ error: 'Not authorized to update this field' });
        }
      }

      const updatedField = await prisma.field.update({
        where: { id: parseInt(id) },
        data: fieldData,
      });

      await prisma.farmer.update({
        where: { id: field.farmerId },
        data: { updatedById: authRequest.user.id },
      });

      return { field: updatedField };
    } catch (error) {
      console.error('Update field error:', error);
      return reply.status(400).send({ error: 'Invalid field data' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { id } = request.params as { id: string };

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      await prisma.field.delete({
        where: { id: parseInt(id) },
      });

      await prisma.farmer.update({
        where: { id: field.farmerId },
        data: { updatedById: authRequest.user.id },
      });

      return { success: true };
    } catch (error) {
      console.error('Delete field error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default fieldRoutes;

```

### apps\api\src\routes\helloWorld.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';

const createPing = async () => {
  const ping = await prisma.ping.create({
    data: {},
  });
  console.log('Created Ping:', ping);
  return ping;
};

async function helloWorldRoutes(fastify: FastifyInstance) {
  fastify.get('/hello', async (request, reply) => {
    const ping = await createPing();
    return { hello: 'world', ping };
  });
}

export default helloWorldRoutes;

```

### apps\api\src\routes\processingStage.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma, ProcessingStageStatus } from '@chaya/shared'; // Import ProcessingStageStatus
import { authenticate, type AuthenticatedRequest } from '../middlewares/auth';
import { createProcessingStageSchema, finalizeProcessingStageSchema, createDryingEntrySchema } from '@chaya/shared';
import Redis from 'ioredis';

const redis = new Redis();

async function invalidateStageRelatedCache(batchId?: number | string, stageId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*');
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) keysToDelete.push(`processing-batch:${batchId}`);
  // No need to delete stage-specific cache if not implemented
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

async function processingStageRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const userId = authUser.id;
      // dateOfProcessing is already a Date object due to Zod transform in shared schema
      const { processingBatchId, previousStageId, processMethod, dateOfProcessing, doneBy } =
        createProcessingStageSchema.parse(request.body);

      const batch = await prisma.processingBatch.findUnique({
        where: { id: processingBatchId },
        include: {
          processingStages: {
            orderBy: { processingCount: 'desc' },
            take: 1,
            include: { sales: { select: { quantitySold: true } } }, // Include sales from the latest stage
          },
        },
      });

      if (!batch) return reply.status(404).send({ error: 'Processing batch not found.' });

      const latestStage = batch.processingStages[0];
      if (!latestStage)
        return reply.status(400).send({ error: 'No initial stage found for this batch. Cannot start a new stage.' });

      if (latestStage.status !== ProcessingStageStatus.FINISHED) {
        return reply.status(400).send({ error: 'The latest processing stage must be FINISHED to start a new one.' });
      }
      // Ensure previousStageId from payload matches the actual latest finished stage
      if (previousStageId && latestStage.id !== previousStageId) {
        return reply
          .status(400)
          .send({ error: 'Mismatch: previousStageId does not correspond to the latest finished stage of the batch.' });
      }

      if (latestStage.quantityAfterProcess === null || latestStage.quantityAfterProcess <= 0) {
        return reply.status(400).send({ error: 'Previous stage has no output quantity (yield) to process further.' });
      }

      // Calculate quantity sold specifically from this latestStage (the previous stage)
      const soldFromLatestStage = latestStage.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
      const availableFromLatestStageForNext = (latestStage.quantityAfterProcess || 0) - soldFromLatestStage;

      if (availableFromLatestStageForNext <= 0) {
        return reply.status(400).send({
          error: `Previous stage (P${latestStage.processingCount}) has no remaining quantity after sales to start a new stage.`,
        });
      }

      const newStage = await prisma.processingStage.create({
        data: {
          processingBatchId,
          processingCount: latestStage.processingCount + 1,
          processMethod,
          dateOfProcessing, // Already a Date object
          doneBy,
          initialQuantity: availableFromLatestStageForNext,
          status: ProcessingStageStatus.IN_PROGRESS,
          createdById: userId,
        },
      });

      await invalidateStageRelatedCache(processingBatchId);
      return reply.status(201).send(newStage);
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Create processing stage error:', error);
      return reply.status(500).send({ error: 'Server error creating processing stage' });
    }
  });

  // ... PUT /:stageId/finalize ... (no change needed here for this specific issue)
  // ... POST /:stageId/drying ... (no change needed here)
  // ... GET /:stageId/drying ... (no change needed here)
  fastify.put(
    '/:stageId/finalize',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        const { dateOfCompletion, quantityAfterProcess } = finalizeProcessingStageSchema.parse(request.body);

        const stage = await prisma.processingStage.findUnique({ where: { id } });
        if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
        if (stage.status === ProcessingStageStatus.FINISHED)
          return reply.status(400).send({ error: 'Stage is already finalized.' });

        // Validate quantityAfterProcess against latest drying entry if available
        const latestDryingEntry = await prisma.drying.findFirst({
          where: { processingStageId: id },
          orderBy: { day: 'desc' },
        });

        if (latestDryingEntry && quantityAfterProcess > latestDryingEntry.currentQuantity) {
          // return reply.status(400).send({ error: `Final quantity (${quantityAfterProcess}kg) cannot exceed the latest drying quantity (${latestDryingEntry.currentQuantity}kg).` });
          // This validation might be too strict if user manually adjusts after some unrecorded loss.
          // For now, we allow it, but it's a point of consideration.
        }
        if (quantityAfterProcess > stage.initialQuantity) {
          // return reply.status(400).send({ error: `Final quantity (${quantityAfterProcess}kg) cannot exceed the stage's initial quantity (${stage.initialQuantity}kg).` });
          // Also potentially too strict.
        }

        const updatedStage = await prisma.processingStage.update({
          where: { id },
          data: { dateOfCompletion, quantityAfterProcess, status: ProcessingStageStatus.FINISHED },
        });

        await invalidateStageRelatedCache(updatedStage.processingBatchId, updatedStage.id.toString());
        return updatedStage;
      } catch (error: any) {
        if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
        console.error('Finalize stage error:', error);
        return reply.status(500).send({ error: 'Server error finalizing stage' });
      }
    }
  );

  fastify.post(
    '/:stageId/drying',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        const data = createDryingEntrySchema.parse({ ...(request.body as object), processingStageId: id });

        const stage = await prisma.processingStage.findUnique({ where: { id } });
        if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
        if (stage.status !== ProcessingStageStatus.IN_PROGRESS) {
          return reply.status(400).send({ error: 'Can only add drying data to IN_PROGRESS stages.' });
        }

        const existingDryingForDay = await prisma.drying.findFirst({
          where: { processingStageId: id, day: data.day },
        });
        if (existingDryingForDay) {
          return reply.status(400).send({ error: `Drying data for day ${data.day} already exists for this stage.` });
        }
        if (data.currentQuantity > stage.initialQuantity) {
          // Potentially too strict if initial quantity was an estimate and drying reveals more
          // console.warn(`Drying current quantity ${data.currentQuantity} exceeds stage initial quantity ${stage.initialQuantity}`);
        }

        const newDryingEntry = await prisma.drying.create({ data });

        await invalidateStageRelatedCache(stage.processingBatchId, stage.id.toString());
        return reply.status(201).send(newDryingEntry);
      } catch (error: any) {
        if (error.issues)
          return reply.status(400).send({ error: 'Invalid request data for drying entry', details: error.issues });
        console.error('Add drying data error:', error);
        return reply.status(500).send({ error: 'Server error adding drying data' });
      }
    }
  );

  fastify.get(
    '/:stageId/drying',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        const dryingEntries = await prisma.drying.findMany({
          where: { processingStageId: id },
          orderBy: { day: 'asc' },
        });
        return { dryingEntries };
      } catch (error) {
        console.error('Get drying data error:', error);
        return reply.status(500).send({ error: 'Server error fetching drying data' });
      }
    }
  );
}
export default processingStageRoutes;

```

### apps\api\src\middlewares\auth.ts:
```
import type { FastifyRequest, FastifyReply } from 'fastify';
import { prisma } from '@chaya/shared';

export interface JWTPayload {
  id: number;
  role: 'ADMIN' | 'STAFF';
  iat: number;
  exp: number;
}

export async function authenticate(request: FastifyRequest, reply: FastifyReply) {
  try {
    const token = request.cookies.token;
    if (!token) {
      console.log('No token found in cookies');
      reply.status(401).send({ error: 'Authentication required' });
      return false;
    }
    const decoded = request.server.jwt.verify<JWTPayload>(token);
    const user = await prisma.user.findUnique({
      where: { id: decoded.id, isEnabled: true },
    });
    if (!user) {
      console.log('User not found or disabled');
      reply.status(401).send({ error: 'User not found or disabled' });
      return false;
    }
    (request as any).user = decoded;
    return true;
  } catch (error) {
    console.error('Authentication error:', error);
    reply.status(401).send({ error: 'Invalid or expired token' });
    return false;
  }
}

export async function verifyAdmin(request: FastifyRequest, reply: FastifyReply) {
  const isAuthenticated = await authenticate(request, reply);
  if (!isAuthenticated) return false;

  const user = (request as any).user as JWTPayload;
  if (!user || user.role !== 'ADMIN') {
    console.log('User is not an admin. Role:', user?.role);
    reply.status(403).send({ error: 'Admin access required' });
    return false;
  }
  return true;
}

export interface AuthenticatedRequest extends FastifyRequest {
  user: JWTPayload;
}

```

### apps\api\src\lib\password.ts:
```
import { hash, compare } from 'bcryptjs';

// Hash a password
export async function hashPassword(password: string): Promise<string> {
  return hash(password, 12);
}

// Verify a password against a hash
export async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
  return compare(password, hashedPassword);
}

```

### packages\ui\eslint.config.js:
```
import { config } from '@workspace/eslint-config/react-internal';

/** @type {import("eslint").Linter.Config} */
export default config;

```

### packages\ui\src\components\badge.tsx:
```
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@workspace/ui/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default: 'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary: 'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40',
        outline: 'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> & VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span';

  return <Comp data-slot="badge" className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };

```

### packages\ui\src\components\collapsible.tsx:
```
'use client';

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

function Collapsible({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}

function CollapsibleTrigger({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return <CollapsiblePrimitive.CollapsibleTrigger data-slot="collapsible-trigger" {...props} />;
}

function CollapsibleContent({ ...props }: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return <CollapsiblePrimitive.CollapsibleContent data-slot="collapsible-content" {...props} />;
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

```

### packages\ui\src\components\button.tsx:
```
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@workspace/ui/lib/utils';

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40',
        outline: 'border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : 'button';

  return <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} />;
}

export { Button, buttonVariants };

```

### packages\ui\src\components\dropdown-menu.tsx:
```
'use client';

import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function DropdownMenu({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />;
}

function DropdownMenuTrigger({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return <DropdownMenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />;
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />;
}

function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: 'default' | 'destructive';
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return <DropdownMenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} />;
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn('px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)}
      {...props}
    />
  );
}

function DropdownMenuSeparator({ className, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)}
      {...props}
    />
  );
}

function DropdownMenuSub({ ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8',
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg',
        className
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
};

```

### packages\ui\src\components\form.tsx:
```
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from 'react-hook-form';

import { cn } from '@workspace/ui/lib/utils';
import { Label } from '@workspace/ui/components/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState } = useFormContext();
  const formState = useFormState({ name: fieldContext.name });
  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

function FormItem({ className, ...props }: React.ComponentProps<'div'>) {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div data-slot="form-item" className={cn('grid gap-2', className)} {...props} />
    </FormItemContext.Provider>
  );
}

function FormLabel({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField();

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn('data-[error=true]:text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
      aria-invalid={!!error}
      {...props}
    />
  );
}

function FormDescription({ className, ...props }: React.ComponentProps<'p'>) {
  const { formDescriptionId } = useFormField();

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}

function FormMessage({ className, ...props }: React.ComponentProps<'p'>) {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message ?? '') : props.children;

  if (!body) {
    return null;
  }

  return (
    <p data-slot="form-message" id={formMessageId} className={cn('text-destructive text-sm', className)} {...props}>
      {body}
    </p>
  );
}

export { useFormField, Form, FormItem, FormLabel, FormControl, FormDescription, FormMessage, FormField };

```

### packages\ui\src\components\sheet.tsx:
```
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}

function SheetTrigger({ ...props }: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}

function SheetClose({ ...props }: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}

function SheetPortal({ ...props }: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}

function SheetOverlay({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80',
        className
      )}
      {...props}
    />
  );
}

function SheetContent({
  className,
  children,
  side = 'right',
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: 'top' | 'right' | 'bottom' | 'left';
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
          side === 'right' &&
            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',
          side === 'left' &&
            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',
          side === 'top' &&
            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',
          side === 'bottom' &&
            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}

function SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="sheet-header" className={cn('flex flex-col gap-1.5 p-4', className)} {...props} />;
}

function SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="sheet-footer" className={cn('mt-auto flex flex-col gap-2 p-4', className)} {...props} />;
}

function SheetTitle({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  );
}

function SheetDescription({ className, ...props }: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}

export { Sheet, SheetTrigger, SheetClose, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription };

```

### packages\ui\src\components\scroll-area.tsx:
```
'use client';

import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '@workspace/ui/lib/utils';

function ScrollArea({ className, children, ...props }: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn('relative', className)} {...props}>
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}

function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent',
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}

export { ScrollArea, ScrollBar };

```

### packages\ui\src\components\popover.tsx:
```
'use client';

import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@workspace/ui/lib/utils';

function Popover({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = 'center',
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden',
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };

```

### packages\ui\src\components\progress.tsx:
```
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@workspace/ui/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }

```

### packages\ui\src\components\command.tsx:
```
'use client';

import * as React from 'react';
import { Command as CommandPrimitive } from 'cmdk';
import { SearchIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@workspace/ui/components/dialog';

function Command({ className, ...props }: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        'bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md',
        className
      )}
      {...props}
    />
  );
}

function CommandDialog({
  title = 'Command Palette',
  description = 'Search for a command to run...',
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string;
  description?: string;
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
}

function CommandInput({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div data-slot="command-input-wrapper" className="flex h-9 items-center gap-2 border-b px-3">
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          'placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        {...props}
      />
    </div>
  );
}

function CommandList({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn('max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto', className)}
      {...props}
    />
  );
}

function CommandEmpty({ ...props }: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return <CommandPrimitive.Empty data-slot="command-empty" className="py-6 text-center text-sm" {...props} />;
}

function CommandGroup({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        'text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium',
        className
      )}
      {...props}
    />
  );
}

function CommandSeparator({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn('bg-border -mx-1 h-px', className)}
      {...props}
    />
  );
}

function CommandItem({ className, ...props }: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}

function CommandShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)}
      {...props}
    />
  );
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

```

### packages\ui\src\components\breadcrumb.tsx:
```
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function Breadcrumb({ ...props }: React.ComponentProps<'nav'>) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />;
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<'ol'>) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        'text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5',
        className
      )}
      {...props}
    />
  );
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<'li'>) {
  return <li data-slot="breadcrumb-item" className={cn('inline-flex items-center gap-1.5', className)} {...props} />;
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp data-slot="breadcrumb-link" className={cn('hover:text-foreground transition-colors', className)} {...props} />
  );
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn('text-foreground font-normal', className)}
      {...props}
    />
  );
}

function BreadcrumbSeparator({ children, className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn('[&>svg]:size-3.5', className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  );
}

function BreadcrumbEllipsis({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn('flex size-9 items-center justify-center', className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  );
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};

```

### packages\ui\src\components\context-menu.tsx:
```
'use client';

import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function ContextMenu({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />;
}

function ContextMenuTrigger({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />;
}

function ContextMenuGroup({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />;
}

function ContextMenuPortal({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />;
}

function ContextMenuSub({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />;
}

function ContextMenuRadioGroup({ ...props }: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return <ContextMenuPrimitive.RadioGroup data-slot="context-menu-radio-group" {...props} />;
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  );
}

function ContextMenuSubContent({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg',
        className
      )}
      {...props}
    />
  );
}

function ContextMenuContent({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md',
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  );
}

function ContextMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: 'default' | 'destructive';
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  );
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  );
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn('text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)}
      {...props}
    />
  );
}

function ContextMenuSeparator({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}

function ContextMenuShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)}
      {...props}
    />
  );
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

```

### packages\ui\src\components\skeleton.tsx:
```
import { cn } from '@workspace/ui/lib/utils';

function Skeleton({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="skeleton" className={cn('bg-primary/10 animate-pulse rounded-md', className)} {...props} />;
}

export { Skeleton };

```

### packages\ui\src\components\chart.tsx:
```
'use client';

import * as React from 'react';
import * as RechartsPrimitive from 'recharts';

import { cn } from '@workspace/ui/lib/utils';

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: '', dark: '.dark' } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> });
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error('useChart must be used within a <ChartContainer />');
  }

  return context;
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<'div'> & {
  config: ChartConfig;
  children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>['children'];
}) {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(([, config]) => config.theme || config.color);

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] || itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join('\n')}
}
`
          )
          .join('\n'),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = 'dot',
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<'div'> & {
    hideLabel?: boolean;
    hideIndicator?: boolean;
    indicator?: 'line' | 'dot' | 'dashed';
    nameKey?: string;
    labelKey?: string;
  }) {
  const { config } = useChart();

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null;
    }

    const [item] = payload;
    const key = `${labelKey || item?.dataKey || item?.name || 'value'}`;
    const itemConfig = getPayloadConfigFromPayload(config, item, key);
    const value =
      !labelKey && typeof label === 'string' ? config[label as keyof typeof config]?.label || label : itemConfig?.label;

    if (labelFormatter) {
      return <div className={cn('font-medium', labelClassName)}>{labelFormatter(value, payload)}</div>;
    }

    if (!value) {
      return null;
    }

    return <div className={cn('font-medium', labelClassName)}>{value}</div>;
  }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);

  if (!active || !payload?.length) {
    return null;
  }

  const nestLabel = payload.length === 1 && indicator !== 'dot';

  return (
    <div
      className={cn(
        'border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl',
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || 'value'}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);
          const indicatorColor = color || item.payload.fill || item.color;

          return (
            <div
              key={item.dataKey}
              className={cn(
                '[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5',
                indicator === 'dot' && 'items-center'
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn('shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)', {
                          'h-2.5 w-2.5': indicator === 'dot',
                          'w-1': indicator === 'line',
                          'w-0 border-[1.5px] border-dashed bg-transparent': indicator === 'dashed',
                          'my-0.5': nestLabel && indicator === 'dashed',
                        })}
                        style={
                          {
                            '--color-bg': indicatorColor,
                            '--color-border': indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn('flex flex-1 justify-between leading-none', nestLabel ? 'items-end' : 'items-center')}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">{itemConfig?.label || item.name}</span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}

const ChartLegend = RechartsPrimitive.Legend;

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = 'bottom',
  nameKey,
}: React.ComponentProps<'div'> &
  Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {
    hideIcon?: boolean;
    nameKey?: string;
  }) {
  const { config } = useChart();

  if (!payload?.length) {
    return null;
  }

  return (
    <div className={cn('flex items-center justify-center gap-4', verticalAlign === 'top' ? 'pb-3' : 'pt-3', className)}>
      {payload.map(item => {
        const key = `${nameKey || item.dataKey || 'value'}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);

        return (
          <div
            key={item.value}
            className={cn('[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3')}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {
  if (typeof payload !== 'object' || payload === null) {
    return undefined;
  }

  const payloadPayload =
    'payload' in payload && typeof payload.payload === 'object' && payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (key in payload && typeof payload[key as keyof typeof payload] === 'string') {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === 'string'
  ) {
    configLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config];
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle };

```

### packages\ui\src\components\card.tsx:
```
import * as React from 'react';

import { cn } from '@workspace/ui/lib/utils';

function Card({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card"
      className={cn('bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm', className)}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-header" className={cn('flex flex-col gap-1.5 px-6', className)} {...props} />;
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-title" className={cn('leading-none font-semibold', className)} {...props} />;
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-description" className={cn('text-muted-foreground text-sm', className)} {...props} />;
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-content" className={cn('px-6', className)} {...props} />;
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="card-footer" className={cn('flex items-center px-6', className)} {...props} />;
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

```

### packages\ui\src\components\avatar.tsx:
```
'use client';

import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';

import { cn } from '@workspace/ui/lib/utils';

function Avatar({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn('relative flex size-8 shrink-0 overflow-hidden rounded-full', className)}
      {...props}
    />
  );
}

function AvatarImage({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image data-slot="avatar-image" className={cn('aspect-square size-full', className)} {...props} />
  );
}

function AvatarFallback({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn('bg-muted flex size-full items-center justify-center rounded-full', className)}
      {...props}
    />
  );
}

export { Avatar, AvatarImage, AvatarFallback };

```

### packages\ui\src\components\tabs.tsx:
```
'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '@workspace/ui/lib/utils';

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return <TabsPrimitive.Root data-slot="tabs" className={cn('flex flex-col gap-2', className)} {...props} />;
}

function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1',
        className
      )}
      {...props}
    />
  );
}

function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}

function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return <TabsPrimitive.Content data-slot="tabs-content" className={cn('flex-1 outline-none', className)} {...props} />;
}

export { Tabs, TabsList, TabsTrigger, TabsContent };

```

### packages\ui\src\components\alert.tsx:
```
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@workspace/ui/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'text-destructive-foreground [&>svg]:text-current *:data-[slot=alert-description]:text-destructive-foreground/80',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

function Alert({ className, variant, ...props }: React.ComponentProps<'div'> & VariantProps<typeof alertVariants>) {
  return <div data-slot="alert" role="alert" className={cn(alertVariants({ variant }), className)} {...props} />;
}

function AlertTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-title"
      className={cn('col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight', className)}
      {...props}
    />
  );
}

function AlertDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        'text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed',
        className
      )}
      {...props}
    />
  );
}

export { Alert, AlertTitle, AlertDescription };

```

### packages\ui\src\components\alert-dialog.tsx:
```
'use client';

import * as React from 'react';
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog';

import { cn } from '@workspace/ui/lib/utils';
import { buttonVariants } from '@workspace/ui/components/button';

function AlertDialog({ ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({ ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />;
}

function AlertDialogPortal({ ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />;
}

function AlertDialogOverlay({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80',
        className
      )}
      {...props}
    />
  );
}

function AlertDialogContent({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  );
}

function AlertDialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn('flex flex-col-reverse gap-2 sm:flex-row sm:justify-end', className)}
      {...props}
    />
  );
}

function AlertDialogTitle({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn('text-lg font-semibold', className)}
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}

function AlertDialogAction({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return <AlertDialogPrimitive.Action className={cn(buttonVariants(), className)} {...props} />;
}

function AlertDialogCancel({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return <AlertDialogPrimitive.Cancel className={cn(buttonVariants({ variant: 'outline' }), className)} {...props} />;
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

```

### packages\ui\src\components\label.tsx:
```
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';

import { cn } from '@workspace/ui/lib/utils';

function Label({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        'flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50',
        className
      )}
      {...props}
    />
  );
}

export { Label };

```

### packages\ui\src\components\sonner.tsx:
```
'use client';

import { useTheme } from 'next-themes';
import { Toaster as Sonner, ToasterProps } from 'sonner';

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium',
          cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium',
        },
      }}
      {...props}
    />
  );
};

export { Toaster };

```

### packages\ui\src\components\combobox.tsx:
```
'use client';

import * as React from 'react';
import { Check, ChevronsUpDown } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { Button } from '@workspace/ui/components/button';
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from '@workspace/ui/components/command';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';

interface ComboboxItem {
  label: string;
  value: string;
}

interface ComboboxProps {
  items: ComboboxItem[];
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  isLoading?: boolean;
}

export const Combobox: React.FC<ComboboxProps> = ({
  items,
  value,
  onChange,
  placeholder = 'Select an option...',
  isLoading = false,
}) => {
  const [open, setOpen] = React.useState(false);

  const selectedItem = items.find(item => item.value === value);

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button variant="outline" role="combobox" aria-expanded={open} className="w-full justify-between">
          {selectedItem ? selectedItem.label : placeholder}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-full p-0">
        <Command>
          <CommandInput placeholder="Search..." disabled={isLoading} />
          <CommandList>
            {isLoading ? (
              <CommandEmpty>Loading...</CommandEmpty>
            ) : (
              <>
                <CommandEmpty>No results found.</CommandEmpty>
                <CommandGroup>
                  {items.map(item => (
                    <CommandItem
                      key={item.value}
                      value={item.value}
                      onSelect={currentValue => {
                        onChange(currentValue);
                        setOpen(false);
                      }}
                    >
                      <Check className={cn('mr-2 h-4 w-4', value === item.value ? 'opacity-100' : 'opacity-0')} />
                      {item.label}
                    </CommandItem>
                  ))}
                </CommandGroup>
              </>
            )}
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
};

```

### packages\ui\src\components\tooltip.tsx:
```
'use client';

import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '@workspace/ui/lib/utils';

function TooltipProvider({ delayDuration = 0, ...props }: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return <TooltipPrimitive.Provider data-slot="tooltip-provider" delayDuration={delayDuration} {...props} />;
}

function Tooltip({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({ ...props }: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit rounded-md px-3 py-1.5 text-xs text-balance',
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

```

### packages\ui\src\components\checkbox.tsx:
```
'use client';

import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { CheckIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function Checkbox({ className, ...props }: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        'peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };

```

### packages\ui\src\components\dialog.tsx:
```
'use client';

import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({ ...props }: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}

function DialogContent({ className, children, ...props }: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn('flex flex-col-reverse gap-2 sm:flex-row sm:justify-end', className)}
      {...props}
    />
  );
}

function DialogTitle({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  );
}

function DialogDescription({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

```

### packages\ui\src\components\calendar.tsx:
```
'use client';

import * as React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { DayPicker } from 'react-day-picker';

import { cn } from '@workspace/ui/lib/utils';
import { buttonVariants } from '@workspace/ui/components/button';

function Calendar({ className, classNames, showOutsideDays = true, ...props }: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row gap-2',
        month: 'flex flex-col gap-4',
        caption: 'flex justify-center pt-1 relative items-center w-full',
        caption_label: 'text-sm font-medium',
        nav: 'flex items-center gap-1',
        nav_button: cn(
          buttonVariants({ variant: 'outline' }),
          'size-7 bg-transparent p-0 opacity-50 hover:opacity-100'
        ),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-x-1',
        head_row: 'flex',
        head_cell: 'text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: cn(
          'relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md',
          props.mode === 'range'
            ? '[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md'
            : '[&:has([aria-selected])]:rounded-md'
        ),
        day: cn(buttonVariants({ variant: 'ghost' }), 'size-8 p-0 font-normal aria-selected:opacity-100'),
        day_range_start: 'day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground',
        day_range_end: 'day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground',
        day_selected:
          'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside: 'day-outside text-muted-foreground aria-selected:text-muted-foreground',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle: 'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => <ChevronLeft className={cn('size-4', className)} {...props} />,
        IconRight: ({ className, ...props }) => <ChevronRight className={cn('size-4', className)} {...props} />,
      }}
      {...props}
    />
  );
}

export { Calendar };

```

### packages\ui\src\components\radio-group.tsx:
```
'use client';

import * as React from 'react';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import { CircleIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function RadioGroup({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return <RadioGroupPrimitive.Root data-slot="radio-group" className={cn('grid gap-3', className)} {...props} />;
}

function RadioGroupItem({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        'border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };

```

### packages\ui\src\components\switch.tsx:
```
'use client';

import * as React from 'react';
import * as SwitchPrimitive from '@radix-ui/react-switch';

import { cn } from '@workspace/ui/lib/utils';

function Switch({ className, ...props }: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        'peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          'bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0'
        )}
      />
    </SwitchPrimitive.Root>
  );
}

export { Switch };

```

### packages\ui\src\components\table.tsx:
```
'use client';

import * as React from 'react';

import { cn } from '@workspace/ui/lib/utils';

function Table({ className, ...props }: React.ComponentProps<'table'>) {
  return (
    <div data-slot="table-container" className="relative w-full overflow-x-auto">
      <table data-slot="table" className={cn('w-full caption-bottom text-sm', className)} {...props} />
    </div>
  );
}

function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {
  return <thead data-slot="table-header" className={cn('[&_tr]:border-b', className)} {...props} />;
}

function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {
  return <tbody data-slot="table-body" className={cn('[&_tr:last-child]:border-0', className)} {...props} />;
}

function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn('bg-muted/50 border-t font-medium [&>tr]:last:border-b-0', className)}
      {...props}
    />
  );
}

function TableRow({ className, ...props }: React.ComponentProps<'tr'>) {
  return (
    <tr
      data-slot="table-row"
      className={cn('hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors', className)}
      {...props}
    />
  );
}

function TableHead({ className, ...props }: React.ComponentProps<'th'>) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        'text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}

function TableCell({ className, ...props }: React.ComponentProps<'td'>) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}

function TableCaption({ className, ...props }: React.ComponentProps<'caption'>) {
  return (
    <caption data-slot="table-caption" className={cn('text-muted-foreground mt-4 text-sm', className)} {...props} />
  );
}

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };

```

### packages\ui\src\components\separator.tsx:
```
'use client';

import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@workspace/ui/lib/utils';

function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className
      )}
      {...props}
    />
  );
}

export { Separator };

```

### packages\ui\src\components\sidebar.tsx:
```
'use client';

import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelLeftIcon } from 'lucide-react';

import { useIsMobile } from '@workspace/ui/hooks/use-mobile';
import { cn } from '@workspace/ui/lib/utils';
import { Button } from '@workspace/ui/components/button';
import { Input } from '@workspace/ui/components/input';
import { Separator } from '@workspace/ui/components/separator';
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from '@workspace/ui/components/sheet';
import { Skeleton } from '@workspace/ui/components/skeleton';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@workspace/ui/components/tooltip';

const SIDEBAR_COOKIE_NAME = 'sidebar_state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';

type SidebarContext = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }

  return context;
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile(open => !open) : setOpen(open => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? 'expanded' : 'collapsed';

  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn('group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full', className)}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}

function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right';
  variant?: 'sidebar' | 'floating' | 'inset';
  collapsible?: 'offcanvas' | 'icon' | 'none';
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn('bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col', className)}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)'
        )}
      />
      <div
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          // Adjust the padding for floating and inset variants.
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}

function SidebarTrigger({ className, onClick, ...props }: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('h-7 w-7', className)}
      onClick={event => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}

function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  );
}

function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className
      )}
      {...props}
    />
  );
}

function SidebarInput({ className, ...props }: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  );
}

function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}

function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}

function SidebarSeparator({ className, ...props }: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  );
}

function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  );
}

function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  );
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div';

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}

function SidebarGroupContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  );
}

function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  );
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  );
}

const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button';
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent side="right" align="center" hidden={state !== 'collapsed' || isMobile} {...tooltip} />
    </Tooltip>
  );
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuBadge({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean;
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && <Skeleton className="size-4 rounded-md" data-sidebar="menu-skeleton-icon" />}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}

function SidebarMenuSubItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  );
}

function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean;
  size?: 'sm' | 'md';
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

```

### packages\ui\src\components\input.tsx:
```
import * as React from 'react';

import { cn } from '@workspace/ui/lib/utils';

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className
      )}
      {...props}
    />
  );
}

export { Input };

```

### packages\ui\src\components\select.tsx:
```
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from 'lucide-react';

import { cn } from '@workspace/ui/lib/utils';

function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({ ...props }: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({ className, children, ...props }: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = 'popper',
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md',
          position === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            'p-1',
            position === 'popper' &&
              'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1'
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn('px-2 py-1.5 text-sm font-medium', className)}
      {...props}
    />
  );
}

function SelectItem({ className, children, ...props }: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn('bg-border pointer-events-none -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}

function SelectScrollUpButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn('flex cursor-default items-center justify-center py-1', className)}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn('flex cursor-default items-center justify-center py-1', className)}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};

```

### packages\ui\src\components\textarea.tsx:
```
import * as React from 'react';

import { cn } from '@workspace/ui/lib/utils';

function Textarea({ className, ...props }: React.ComponentProps<'textarea'>) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        'border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className
      )}
      {...props}
    />
  );
}

export { Textarea };

```

### packages\ui\src\hooks\use-mobile.ts:
```
import * as React from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);

  return !!isMobile;
}

```

### packages\ui\src\lib\utils.ts:
```
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

```

### packages\ui\src\styles\globals.css:
```
@import 'tailwindcss';
@source "../../../apps/**/*.{ts,tsx}";
@source "../../../components/**/*.{ts,tsx}";
@source "../**/*.{ts,tsx}";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.145 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.145 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.985 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.269 0 0);
  --input: oklch(0.269 0 0);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(0.269 0 0);
  --sidebar-ring: oklch(0.439 0 0);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }

  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

```

### packages\shared\prisma\seed.ts:
```
import { PrismaClient, Role, Gender, Relationship, ProcessingStageStatus } from '@prisma/client';
import { hashPassword } from '../../../apps/api/src/lib/password.js';

const prisma = new PrismaClient();

// Crop and ProcuredForm definitions matching your new requirements
const CROP_PROCURED_FORMS = {
  Turmeric: ['Fresh Finger', 'Fresh Bulb', 'Dried Finger', 'Dried Bulb'],
  Coffee: ['Fruit', 'Dry Cherry', 'Parchment'],
  Ginger: ['Fresh', 'Dried'],
  Pepper: ['Green Pepper', 'Black Pepper'],
  Wheat: ['Raw Grain', 'Cleaned Grain'], // Added Wheat for existing seed logic
} as const;

type SeedCropType = keyof typeof CROP_PROCURED_FORMS;

function generateProcurementNumberForSeed(
  crop: string,
  date: Date | undefined,
  lotNo: number,
  counter: number
): string {
  if (!date) {
    console.warn('Date is undefined for generateProcurementNumberForSeed. Using current date as fallback.');
    date = new Date();
  }
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = date.toISOString().split('T')[0]?.replace(/-/g, '') || 'NODATE';
  const lotCode = lotNo.toString();
  const counterStr = counter.toString().padStart(3, '0');

  return `${cropCode}${dateCode}${lotCode}${counterStr}`.padEnd(16, 'X'); // Increased length slightly
}

function generateProcessingBatchCodeForSeed(
  crop: string,
  lotNo: number,
  dateOfProcessing: Date | undefined,
  counter: number
): string {
  if (!dateOfProcessing) {
    console.warn(
      'DateOfProcessing is undefined for generateProcessingBatchCodeForSeed. Using current date as fallback.'
    );
    dateOfProcessing = new Date();
  }
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = dateOfProcessing.toISOString().split('T')[0]?.replace(/-/g, '') || 'NODATEPBC';
  const lotStr = lotNo.toString();
  // Using a more random suffix to improve uniqueness for seed data
  const suffix =
    (Math.random().toString(36).substring(2, 7) + Math.random().toString(36).substring(2, 7)).toUpperCase() +
    counter.toString();
  return `PBC-${cropCode}-${lotStr}-${dateCode}-${suffix}`;
}

async function main() {
  console.log(`Start seeding ...`);

  const adminPassword = await hashPassword('Admin@123');
  const staffPassword = await hashPassword('Staff@123');

  const adminUser = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: { password: adminPassword },
    create: {
      email: 'admin@example.com',
      name: 'Admin User',
      password: adminPassword,
      role: Role.ADMIN,
      isEnabled: true,
    },
  });

  const staffUser = await prisma.user.upsert({
    where: { email: 'staff@example.com' },
    update: { password: staffPassword },
    create: {
      email: 'staff@example.com',
      name: 'Staff User',
      password: staffPassword,
      role: Role.STAFF,
      isEnabled: true,
    },
  });
  console.log(`Created users: ${adminUser.name}, ${staffUser.name}`);

  const farmer1 = await prisma.farmer.upsert({
    where: { surveyNumber: 'FARMSEED001' },
    update: {},
    create: {
      surveyNumber: 'FARMSEED001',
      name: 'Seeder Farmer One',
      relationship: Relationship.SELF,
      gender: Gender.MALE,
      community: 'General',
      aadharNumber: '111122223333',
      state: 'State A',
      district: 'District X',
      mandal: 'Mandal P',
      village: 'Village Alpha',
      panchayath: 'Alpha GP',
      dateOfBirth: new Date('1975-05-10'),
      age: 49,
      contactNumber: '9000000001',
      createdById: adminUser.id,
      updatedById: adminUser.id,
      bankDetails: {
        create: {
          ifscCode: 'IFSC001',
          bankName: 'Seed Bank',
          branchName: 'Main',
          accountNumber: 'ACC001',
          address: 'Bank Address',
          bankCode: 'SB01',
        },
      },
      documents: {
        create: {
          profilePicUrl: 'https://placehold.co/400',
          aadharDocUrl: 'https://placehold.co/doc.pdf',
          bankDocUrl: 'https://placehold.co/doc.pdf',
        },
      },
    },
  });
  const farmer2 = await prisma.farmer.upsert({
    where: { surveyNumber: 'FARMSEED002' },
    update: {},
    create: {
      surveyNumber: 'FARMSEED002',
      name: 'Seeder Farmer Two',
      relationship: Relationship.SELF,
      gender: Gender.FEMALE,
      community: 'OBC',
      aadharNumber: '444455556666',
      state: 'State B',
      district: 'District Y',
      mandal: 'Mandal Q',
      village: 'Village Beta',
      panchayath: 'Beta GP',
      dateOfBirth: new Date('1980-11-20'),
      age: 43,
      contactNumber: '9000000002',
      createdById: staffUser.id,
      updatedById: staffUser.id,
      bankDetails: {
        create: {
          ifscCode: 'IFSC002',
          bankName: 'Agri Bank',
          branchName: 'Rural',
          accountNumber: 'ACC002',
          address: 'Agri Address',
          bankCode: 'AG01',
        },
      },
      documents: {
        create: {
          profilePicUrl: 'https://placehold.co/400',
          aadharDocUrl: 'https://placehold.co/doc.pdf',
          bankDocUrl: 'https://placehold.co/doc.pdf',
        },
      },
    },
  });
  console.log(`Created farmers: ${farmer1.name}, ${farmer2.name}`);

  const procurementBaseDate = new Date();
  procurementBaseDate.setDate(procurementBaseDate.getDate() - 10); // 10 days ago

  // Procurements for Turmeric - Lot 1
  const procTurmeric1F1L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[0], // Fresh Finger
      speciality: 'Organic',
      quantity: 120.5,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(9, 0, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
      vehicleNo: 'TS01AA1111',
    },
  });
  const procTurmeric2F2L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer2.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[0], // Fresh Finger
      speciality: 'Standard',
      quantity: 80.0,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 2),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(9, 30, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
    },
  });
  const procTurmeric3F1L1DF = await prisma.procurement.create({
    // Different ProcuredForm
    data: {
      farmerId: farmer1.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[2], // Dried Finger
      speciality: 'Organic',
      quantity: 50.0,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 3),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(10, 0, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
    },
  });

  // Procurements for Coffee - Lot 1
  const procCoffee1F1L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Coffee',
      procuredForm: CROP_PROCURED_FORMS.Coffee[1], // Dry Cherry
      speciality: 'Fair Trade',
      quantity: 250.0,
      procurementNumber: generateProcurementNumberForSeed('Coffee', procurementBaseDate, 1, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(11, 0, 0, 0)),
      lotNo: 1,
      procuredBy: adminUser.name,
      vehicleNo: 'KA02BB2222',
    },
  });
  const procCoffee2F2L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer2.id,
      crop: 'Coffee',
      procuredForm: CROP_PROCURED_FORMS.Coffee[1], // Dry Cherry
      speciality: 'Standard',
      quantity: 180.5,
      procurementNumber: generateProcurementNumberForSeed('Coffee', procurementBaseDate, 1, 2),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(11, 30, 0, 0)),
      lotNo: 1,
      procuredBy: adminUser.name,
    },
  });

  // Procurements for Ginger - Lot 2 (Farmer 1)
  const procGinger1F1L2 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Ginger',
      procuredForm: CROP_PROCURED_FORMS.Ginger[0], // Fresh
      speciality: 'Organic',
      quantity: 75.5,
      procurementNumber: generateProcurementNumberForSeed('Ginger', procurementBaseDate, 2, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(14, 0, 0, 0)),
      lotNo: 2,
      procuredBy: staffUser.name,
    },
  });

  console.log(`Created various procurements.`);

  // --- Processing Batch example for Turmeric, Lot 1, Fresh Finger ---
  const turmericBatchInitialQty = procTurmeric1F1L1.quantity + procTurmeric2F2L1.quantity;
  const turmericP1Date = new Date();
  turmericP1Date.setDate(turmericP1Date.getDate() - 7); // 7 days ago

  const turmericBatchCode = generateProcessingBatchCodeForSeed('Turmeric', 1, turmericP1Date, 1);
  const turmericProcessingBatch = await prisma.processingBatch.create({
    data: {
      batchCode: turmericBatchCode,
      crop: 'Turmeric',
      lotNo: 1, // Matching the selected procurements' lotNo
      initialBatchQuantity: turmericBatchInitialQty,
      createdById: adminUser.id,
      procurements: {
        connect: [{ id: procTurmeric1F1L1.id }, { id: procTurmeric2F2L1.id }], // Only Fresh Finger from Lot 1
      },
      processingStages: {
        create: {
          processingCount: 1,
          processMethod: 'dry', // Turmeric often dried
          initialQuantity: turmericBatchInitialQty,
          dateOfProcessing: turmericP1Date,
          doneBy: 'Turmeric P1 Seed Team',
          status: ProcessingStageStatus.IN_PROGRESS,
          createdById: adminUser.id,
        },
      },
    },
    include: { processingStages: { orderBy: { processingCount: 'asc' } } },
  });

  if (!turmericProcessingBatch.processingStages || turmericProcessingBatch.processingStages.length === 0) {
    console.error(`Failed to create P1 stage for Turmeric batch ${turmericProcessingBatch.batchCode}.`);
  } else {
    const p1Turmeric = turmericProcessingBatch.processingStages[0];
    if (!p1Turmeric || typeof p1Turmeric.id === 'undefined') {
      console.error(`P1 Turmeric stage object is invalid for batch ${turmericProcessingBatch.batchCode}.`);
    } else {
      console.log(`Created Turmeric batch: ${turmericProcessingBatch.batchCode} with P1: ${p1Turmeric.id}`);

      let currentDryingQty = p1Turmeric.initialQuantity;
      for (let i = 1; i <= 2; i++) {
        // 2 days of drying
        currentDryingQty -= Math.random() * 5 + 1; // Turmeric loses more weight
        await prisma.drying.create({
          data: {
            processingStageId: p1Turmeric.id,
            day: i,
            temperature: 35 + Math.random() * 5,
            humidity: 40 + Math.random() * 10,
            pH: 6.0 + Math.random() * 0.5,
            moisturePercentage: 50 - i * 10,
            currentQuantity: parseFloat(currentDryingQty.toFixed(2)),
          },
        });
      }
      console.log(`Added drying entries for Turmeric P1.`);

      const p1TurmericFinalYield = parseFloat(currentDryingQty.toFixed(2)) - (Math.random() * 2 + 0.5);
      const finalizedP1Turmeric = await prisma.processingStage.update({
        where: { id: p1Turmeric.id },
        data: {
          status: ProcessingStageStatus.FINISHED,
          dateOfCompletion: new Date(new Date(turmericP1Date).setDate(turmericP1Date.getDate() + 2)),
          quantityAfterProcess: parseFloat(p1TurmericFinalYield.toFixed(2)),
        },
      });
      console.log(`Finalized Turmeric P1. Yield: ${finalizedP1Turmeric.quantityAfterProcess}kg`);

      if (finalizedP1Turmeric.quantityAfterProcess && finalizedP1Turmeric.quantityAfterProcess > 10) {
        await prisma.sale.create({
          data: {
            processingBatchId: turmericProcessingBatch.id,
            processingStageId: finalizedP1Turmeric.id,
            quantitySold: 10,
            dateOfSale: new Date(),
            createdById: staffUser.id,
          },
        });
        console.log(`Sold 10kg from Turmeric P1.`);
      }
    }
  }

  console.log(`Seeding finished.`);
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async e => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });

```

### packages\shared\src\index.ts:
```
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

export * from '@prisma/client';

export * from './schemas/auth';
export * from './schemas/farmer';
export * from './schemas/users';
export * from './schemas/procurement';
export * from './schemas/processingBatch';
export * from './schemas/processingStage';
export * from './schemas/sale';

```

### packages\shared\src\schemas\auth.ts:
```
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
});

export const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
});

export type LoginInput = z.infer<typeof loginSchema>;
export type RegisterInput = z.infer<typeof registerSchema>;

```

### packages\shared\src\schemas\farmer.ts:
```
import { z } from 'zod';

export const farmerSchema = z.object({
  id: z.number().optional(),
  surveyNumber: z.string().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  relationship: z.enum(['SELF', 'SPOUSE', 'CHILD', 'OTHER']),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']),
  community: z.string().min(1, 'Community is required'),
  aadharNumber: z.string().min(12, 'Valid Aadhar number required').max(12),
  state: z.string().min(1, 'State is required'),
  district: z.string().min(1, 'District is required'),
  mandal: z.string().min(1, 'Mandal is required'),
  village: z.string().min(1, 'Village is required'),
  panchayath: z.string().min(1, 'Panchayath is required'),
  dateOfBirth: z.string().transform(str => new Date(str)),
  age: z.number().int().min(18, 'Farmer must be at least 18 years old'),
  contactNumber: z.string().min(10, 'Valid contact number required'),
  isActive: z.boolean().default(true),
});

export const bankDetailsSchema = z.object({
  ifscCode: z.string().min(1, 'IFSC code is required'),
  bankName: z.string().min(1, 'Bank name is required'),
  branchName: z.string().min(1, 'Branch name is required'),
  accountNumber: z.string().min(1, 'Account number is required'),
  address: z.string().min(1, 'Bank address is required'),
  bankCode: z.string().min(1, 'Bank code is required'),
});

export const farmerDocumentsSchema = z.object({
  profilePicUrl: z.string().url('Valid profile picture URL required'),
  aadharDocUrl: z.string().url('Valid Aadhar document URL required'),
  bankDocUrl: z.string().url('Valid bank document URL required'),
});

export const fieldSchema = z.object({
  areaHa: z.number().positive('Area must be a positive number'),
  yieldEstimate: z.number().positive('Yield estimate must be a positive number'),
  location: z.object({
    lat: z.number(),
    lng: z.number(),
    accuracy: z.number(),
    altitude: z.number().nullable(),
    altitudeAccuracy: z.number().nullable(),
    timestamp: z.number(),
  }),
  landDocumentUrl: z.string().url('Valid land document URL required'),
});

export const createFarmerSchema = z.object({
  farmer: farmerSchema,
  bankDetails: bankDetailsSchema,
  documents: farmerDocumentsSchema,
  fields: z.array(fieldSchema).optional(),
});

export const updateFarmerSchema = z.object({
  farmer: farmerSchema.partial(),
  bankDetails: bankDetailsSchema.partial().optional(),
  documents: farmerDocumentsSchema.partial().optional(),
  fields: z.array(fieldSchema.partial()).optional(),
});

export const farmerQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  state: z.string().optional(),
  district: z.string().optional(),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']).optional(),
  isActive: z.preprocess(val => {
    if (typeof val === 'string') {
      if (val.toLowerCase() === 'true') return true;
      if (val.toLowerCase() === 'false') return false;
    }
    return val;
  }, z.boolean().optional().default(true)),
});

export type FarmerInput = z.infer<typeof farmerSchema>;
export type BankDetailsInput = z.infer<typeof bankDetailsSchema>;
export type FarmerDocumentsInput = z.infer<typeof farmerDocumentsSchema>;
export type FieldInput = z.infer<typeof fieldSchema>;
export type CreateFarmerInput = z.infer<typeof createFarmerSchema>;
export type UpdateFarmerInput = z.infer<typeof updateFarmerSchema>;
export type FarmerQuery = z.infer<typeof farmerQuerySchema>;

```

### packages\shared\src\schemas\processingBatch.ts:
```
import { z } from 'zod';
import { ProcessingStageStatus } from '@prisma/client';

export const createProcessingBatchFirstStageSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible for P1 is required'),
});

export const createProcessingBatchSchema = z.object({
  crop: z.string().min(1, 'Crop is required'),
  lotNo: z.number().int().min(1, 'Lot number is required'),
  procurementIds: z.array(z.number().int()).min(1, 'At least one procurement must be selected'),
  firstStageDetails: createProcessingBatchFirstStageSchema,
});
export type CreateProcessingBatchInput = z.infer<typeof createProcessingBatchSchema>;

const queryStatusEnumValues: [string, ...string[]] = [
  ProcessingStageStatus.IN_PROGRESS,
  ProcessingStageStatus.FINISHED,
  ProcessingStageStatus.CANCELLED,
  'SOLD_OUT',
];

export const processingBatchQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  status: z.enum(queryStatusEnumValues).optional(),
});
export type ProcessingBatchQuery = z.infer<typeof processingBatchQuerySchema>;

```

### packages\shared\src\schemas\procurement.ts:
```
import { z } from 'zod';

export const createProcurementSchema = z.object({
  farmerId: z.number(),
  crop: z.string().min(1, 'Crop is required'),
  procuredForm: z.string().min(1, 'Procured form is required'),
  speciality: z.string().min(1, 'Speciality is required'),
  quantity: z.number().positive('Quantity must be a positive number'),
  date: z.string().transform(str => new Date(str)), // This should be the procurement date
  time: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (expected HH:mm:ss)'), // Procurement time
  lotNo: z.number().int().min(1, 'Lot number must be a positive integer'), // Max removed, can be any int now.
  procuredBy: z.string().min(1, 'Procured by is required'),
  vehicleNo: z.string().min(1, 'Vehicle number is required').optional(),
});

export type CreateProcurementInput = z.infer<typeof createProcurementSchema>;

export const updateProcurementSchema = createProcurementSchema.partial().extend({
  id: z.number(),
});
export type UpdateProcurementInput = z.infer<typeof updateProcurementSchema>;

export const procurementQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  farmerId: z.string().transform(Number).optional(),
  crop: z.string().optional(),
  lotNo: z.string().transform(Number).optional(),
  isBatched: z.boolean().optional(), // To filter procurements already in a batch or not
});

export type ProcurementQuery = z.infer<typeof procurementQuerySchema>;

```

### packages\shared\src\schemas\users.ts:
```
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
  isEnabled: z.boolean().default(true),
  isActive: z.boolean().default(false),
  lastLoginAt: z.date().nullable().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export const updateUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters').optional(),
  email: z.string().email('Invalid email address').optional(),
  isEnabled: z.boolean().optional(),
  password: z.string().min(6, 'Password must be at least 6 characters').optional(),
});

export type ZodUser = z.infer<typeof userSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;

```

### packages\shared\src\schemas\processingStage.ts:
```
import { z } from 'zod';

export const createProcessingStageSchema = z.object({
  processingBatchId: z.number().int(),
  previousStageId: z.number().int().optional(),
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible is required'),
});
export type CreateProcessingStageInput = z.infer<typeof createProcessingStageSchema>;

export const finalizeProcessingStageSchema = z.object({
  dateOfCompletion: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  quantityAfterProcess: z.coerce
    .number({
      required_error: 'Final quantity is required',
      invalid_type_error: 'Final quantity must be a number',
    })
    .positive('Final quantity must be a positive number'),
});
export type FinalizeProcessingStageInput = z.infer<typeof finalizeProcessingStageSchema>;

export const createDryingEntrySchema = z.object({
  processingStageId: z.number().int(),
  day: z.number().int().positive('Day must be a positive integer'),
  temperature: z.number({ required_error: 'Temperature is required' }),
  humidity: z.number().min(0).max(100, 'Humidity must be between 0 and 100'),
  pH: z.number().min(0).max(14, 'pH must be between 0 and 14'),
  moisturePercentage: z.number().min(0).max(100, 'Moisture % must be between 0 and 100'),
  currentQuantity: z.coerce
    .number({
      required_error: 'Current quantity is required',
      invalid_type_error: 'Current quantity must be a number',
    })
    .positive('Current quantity after drying must be positive'),
});
export type CreateDryingEntryInput = z.infer<typeof createDryingEntrySchema>;

```

### packages\shared\src\schemas\sale.ts:
```
import { z } from 'zod';

export const createSaleFormSchema = z.object({
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSaleInput: z.date({
    required_error: 'Date of Sale is required',
    invalid_type_error: "That's not a valid date!",
  }),
  timeOfSaleInput: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (HH:mm:ss)'),
});
export type CreateSaleFormValues = z.infer<typeof createSaleFormSchema>;

export const createSaleSchema = z.object({
  processingBatchId: z.number().int(),
  processingStageId: z.number().int(),
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSale: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
});
export type CreateSaleInput = z.infer<typeof createSaleSchema>;

```

### packages\eslint-config\base.js:
```
import js from '@eslint/js';
import eslintConfigPrettier from 'eslint-config-prettier';
import onlyWarn from 'eslint-plugin-only-warn';
import turboPlugin from 'eslint-plugin-turbo';
import tseslint from 'typescript-eslint';

/**
 * A shared ESLint configuration for the repository.
 *
 * @type {import("eslint").Linter.Config}
 * */
export const config = [
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  {
    plugins: {
      turbo: turboPlugin,
    },
    rules: {
      'turbo/no-undeclared-env-vars': 'warn',
    },
  },
  {
    plugins: {
      onlyWarn,
    },
  },
  {
    ignores: ['dist/**'],
  },
];

```

### packages\eslint-config\react-internal.js:
```
import js from '@eslint/js';
import eslintConfigPrettier from 'eslint-config-prettier';
import pluginReact from 'eslint-plugin-react';
import pluginReactHooks from 'eslint-plugin-react-hooks';
import globals from 'globals';
import tseslint from 'typescript-eslint';

import { config as baseConfig } from './base.js';

/**
 * A custom ESLint configuration for libraries that use React.
 *
 * @type {import("eslint").Linter.Config} */
export const config = [
  ...baseConfig,
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
  {
    languageOptions: {
      ...pluginReact.configs.flat.recommended.languageOptions,
      globals: {
        ...globals.serviceworker,
        ...globals.browser,
      },
    },
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
    },
    settings: { react: { version: 'detect' } },
    rules: {
      ...pluginReactHooks.configs.recommended.rules,
      // React scope no longer necessary with new JSX transform.
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
    },
  },
];

```

### packages\eslint-config\next.js:
```
import js from '@eslint/js';
import pluginNext from '@next/eslint-plugin-next';
import eslintConfigPrettier from 'eslint-config-prettier';
import pluginReact from 'eslint-plugin-react';
import pluginReactHooks from 'eslint-plugin-react-hooks';
import globals from 'globals';
import tseslint from 'typescript-eslint';

import { config as baseConfig } from './base.js';

/**
 * A custom ESLint configuration for libraries that use Next.js.
 *
 * @type {import("eslint").Linter.Config}
 * */
export const nextJsConfig = [
  ...baseConfig,
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  {
    ...pluginReact.configs.flat.recommended,
    languageOptions: {
      ...pluginReact.configs.flat.recommended.languageOptions,
      globals: {
        ...globals.serviceworker,
      },
    },
  },
  {
    plugins: {
      '@next/next': pluginNext,
    },
    rules: {
      ...pluginNext.configs.recommended.rules,
      ...pluginNext.configs['core-web-vitals'].rules,
    },
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
    },
    settings: { react: { version: 'detect' } },
    rules: {
      ...pluginReactHooks.configs.recommended.rules,
      // React scope no longer necessary with new JSX transform.
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
    },
  },
];

```

