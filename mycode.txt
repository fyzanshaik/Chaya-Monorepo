### apps\web\layout1.ts:
```
// import { Geist, Geist_Mono } from 'next/font/google';

// import '@workspace/ui/globals.css';
// import { Providers } from '@/components/providers';

// const fontSans = Geist({
// 	subsets: ['latin'],
// 	variable: '--font-sans',
// });

// const fontMono = Geist_Mono({
// 	subsets: ['latin'],
// 	variable: '--font-mono',
// });

// export default function RootLayout({
// 	children,
// }: Readonly<{
// 	children: React.ReactNode;
// }>) {
// 	return (
// 		<html lang="en" suppressHydrationWarning>
// 			<body className={`${fontSans.variable} ${fontMono.variable} font-sans antialiased `}>
// 				<Providers>{children}</Providers>
// 			</body>
// 		</html>
// 	);
// }

```

### apps\web\middleware.ts:
```
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Get token from cookie
  const token = request.cookies.get('token')?.value;

  // Protected routes pattern
  const isProtectedRoute =
    pathname.startsWith('/dashboard') || pathname.startsWith('/farmers') || pathname.startsWith('/staff');

  // Auth routes pattern
  const isAuthRoute = pathname === '/login';

  // Redirect to login if accessing protected route without token
  if (isProtectedRoute && !token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // Redirect to dashboard if accessing auth route with token
  if (isAuthRoute && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
/**
     *  This middleware checks if the user is accessing a protected route without a token and redirects them to the login page. It also checks if the user is accessing an auth route with a token and redirects them to the dashboard. 
    To apply the middleware to all routes, update the  next.config.js  file:
     * 
     *  */

```

### apps\web\eslint.config.js:
```
import { defineConfig } from 'eslint-define-config';

export const nextJsConfig = defineConfig({
  extends: ['next/core-web-vitals', 'turbo', 'prettier'],
  plugins: ['prettier'],
  rules: {
    'prettier/prettier': 'error',
  },
});

```

### apps\web\components\providers.tsx:
```
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
      enableColorScheme
    >
      {children}
    </NextThemesProvider>
  );
}

```

### apps\web\app\page.tsx:
```
import { Button } from '@workspace/ui/components/button';
import Link from 'next/link';
export default function Home() {
  return (
    <div>
      Chaya Website
      <Link href="/login" passHref>
        <Button>Go to login</Button>
      </Link>
    </div>
  );
}

```

### apps\web\app\layout.tsx:
```
import type { Metadata } from 'next';
import '@workspace/ui/globals.css';
import { ThemeProvider } from './providers/theme-provider';
export const metadata: Metadata = {
  title: 'Chaya App',
  description: 'Agricultural Management Application',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body>
        <ThemeProvider attribute="class" defaultTheme="light" enableSystem disableTransitionOnChange>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

```

### apps\web\app\components\login-form.tsx:
```
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

import { useAuth } from '@/app/providers/auth-provider';
import { AlertCircle } from 'lucide-react';
import { Alert, AlertDescription } from '@workspace/ui/components/alert';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { cn } from '@workspace/ui/lib/utils';

export function LoginForm({ className, ...props }: React.ComponentPropsWithoutRef<'form'>) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { setUser } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    try {
      const response = await fetch('http://localhost:5000/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
        credentials: 'include',
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Invalid credentials');
      }

      const data = await response.json();
      setUser(data.user);
      router.push('/dashboard');
    } catch (err: unknown) {
      if (err instanceof Error) {
        setError(err.message || 'An error occurred during login');
      } else {
        setError('An error occurred during login');
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form
      className={cn('flex flex-col gap-6 p-4 md:p-6 bg-card rounded-lg shadow', className)}
      {...props}
      onSubmit={handleSubmit}
    >
      <div className="flex flex-col items-center gap-2 text-center">
        <h1 className="text-2xl font-bold text-primary">Login to your account</h1>
        <p className="text-sm text-muted-foreground">Enter your email below to login to your account</p>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-2">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid gap-6">
        <div className="grid gap-2">
          <Label htmlFor="email" className="text-sm font-medium">
            Email
          </Label>
          <Input
            id="email"
            type="email"
            placeholder="email@example.com"
            required
            className="border border-input focus:ring-primary focus:border-primary"
            value={email}
            onChange={e => setEmail(e.target.value)}
            disabled={isLoading}
          />
        </div>
        <div className="grid gap-2">
          <div className="flex items-center justify-between">
            <Label htmlFor="password" className="text-sm font-medium">
              Password
            </Label>
          </div>
          <Input
            id="password"
            type="password"
            required
            className="border border-input focus:ring-primary focus:border-primary"
            value={password}
            onChange={e => setPassword(e.target.value)}
            disabled={isLoading}
          />
        </div>
        <Button type="submit" className="w-full bg-primary text-primary-foreground" disabled={isLoading}>
          {isLoading ? 'Logging in...' : 'Login'}
        </Button>
      </div>
    </form>
  );
}

```

### apps\web\app\components\upload\document-uploaded-alt.tsx:
```
// components/upload/document-uploader-alt.tsx
'use client';

import { useState } from 'react';
import { UploadButton } from '@/utils/uploadthing';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Check, Loader2, Upload, X } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';

type UploadEndpoint = 'profilePicture' | 'aadharDocument' | 'bankDocument' | 'landDocument';

interface DocumentUploaderAltProps {
  endpoint: UploadEndpoint;
  value?: string;
  onChange: (url: string) => void;
  label: string;
  accept?: string;
}

export function DocumentUploaderAlt({ endpoint, value, onChange, label, accept }: DocumentUploaderAltProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleRemove = () => {
    onChange('');
  };

  return (
    <div className="space-y-2">
      <div className="text-sm font-medium">{label}</div>

      {value ? (
        <Card className="overflow-hidden">
          <CardContent className="p-0">
            <div className="flex items-center justify-between p-4">
              <div className="flex items-center gap-2">
                <Check className="h-5 w-5 text-green-500" />
                <span className="text-sm">Document uploaded</span>
              </div>
              <div className="flex gap-2">
                <Button variant="ghost" size="sm" onClick={handleRemove}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            <div className="flex flex-col items-center justify-center space-y-2">
              <div className="flex h-10 w-10 items-center justify-center rounded-full bg-muted">
                <Upload className="h-5 w-5" />
              </div>

              <div className="space-y-1 text-center">
                <p className="text-sm font-medium">Upload {label}</p>
                <p className="text-xs text-muted-foreground">Max file size: 500KB</p>
              </div>

              <UploadButton
                endpoint={endpoint}
                onClientUploadComplete={res => {
                  if (res && res[0]) {
                    onChange(res[0].url);
                  }
                  setIsUploading(false);
                }}
                onUploadError={err => {
                  setError(err.message);
                  setIsUploading(false);
                }}
                onUploadBegin={() => {
                  setIsUploading(true);
                  setError(null);
                }}
                className="w-full"
                appearance={{
                  button: 'w-full bg-muted hover:bg-muted/80 text-foreground',
                  allowedContent: 'hidden',
                }}
              />

              {isUploading && (
                <div className="flex flex-col items-center gap-2 mt-2">
                  <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
                  <p className="text-sm text-muted-foreground">Uploading...</p>
                </div>
              )}

              {error && <p className="text-sm text-red-500">{error}</p>}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

```

### apps\web\app\components\upload\document-uploader.tsx:
```
'use client';

import { useState, useCallback } from 'react';
import { UploadDropzone } from '@/utils/uploadthing';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Check, Loader2, X, AlertCircle } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';
import imageCompression from 'browser-image-compression';

type UploadEndpoint = 'profilePicture' | 'aadharDocument' | 'bankDocument' | 'landDocument';

interface DocumentUploaderProps {
  endpoint: UploadEndpoint;
  value?: string;
  onChange: (url: string) => void;
  label: string;
  accept?: string;
}

const MAX_PDF_SIZE_KB = 200;
const MAX_IMAGE_SIZE_KB = 300;

export function DocumentUploader({ endpoint, value, onChange, label }: DocumentUploaderProps) {
  const [error, setError] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [isCompressing, setIsCompressing] = useState(false);

  const handleRemove = () => {
    onChange('');
  };

  const compressFile = useCallback(async (file: File): Promise<File> => {
    const fileSizeKB = Math.round(file.size / 1024);

    if (file.type === 'application/pdf') {
      if (fileSizeKB > MAX_PDF_SIZE_KB) {
        throw new Error(
          `PDF file is too large (${fileSizeKB}KB). Please compress to under ${MAX_PDF_SIZE_KB}KB before uploading.`
        );
      }
      return file;
    }

    if (!file.type.startsWith('image/')) {
      return file;
    }

    setIsCompressing(true);

    try {
      const options = {
        maxSizeMB: MAX_IMAGE_SIZE_KB / 1024,
        maxWidthOrHeight: 1500,
        useWebWorker: true,
      };

      const compressedFile = await imageCompression(file, options);
      const compressedSizeKB = Math.round(compressedFile.size / 1024);

      if (compressedSizeKB > MAX_IMAGE_SIZE_KB) {
        throw new Error(
          `Image could not be compressed enough (${compressedSizeKB}KB). Please use an image editor to reduce to under ${MAX_IMAGE_SIZE_KB}KB.`
        );
      }

      return compressedFile;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to compress image. Please try a smaller image (under ${MAX_IMAGE_SIZE_KB}KB).`);
    } finally {
      setIsCompressing(false);
    }
  }, []);

  const validateAndProcessFiles = useCallback(
    async (files: File[]): Promise<File[]> => {
      try {
        const processedFiles = await Promise.all(
          files.map(async file => {
            try {
              return await compressFile(file);
            } catch (error) {
              if (error instanceof Error) {
                setError(error.message);
              } else {
                setError(`Unknown error processing file`);
              }
              throw error;
            }
          })
        );

        return processedFiles;
      } catch (error) {
        throw new Error('File processing failed');
      }
    },
    [compressFile]
  );

  return (
    <div className="space-y-2">
      <div className="text-sm font-medium">{label}</div>

      {value ? (
        <Card className="overflow-hidden">
          <CardContent className="p-0">
            <div className="flex items-center justify-between p-4">
              <div className="flex items-center gap-2">
                <Check className="h-5 w-5 text-green-500" />
                <span className="text-sm">Document uploaded</span>
              </div>
              <div className="flex gap-2">
                <Button variant="ghost" size="sm" onClick={handleRemove}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      ) : isUploading || isCompressing ? (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            <div className="flex flex-col items-center justify-center py-6">
              <Loader2 className="h-8 w-8 text-primary animate-spin mb-2" />
              <p className="text-sm text-muted-foreground">
                {isCompressing ? 'Compressing file...' : 'Uploading document...'}
              </p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card className="overflow-hidden">
          <CardContent className="p-4">
            {error && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
                <div className="flex items-start gap-2 text-sm text-red-600">
                  <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="font-medium">Upload failed</p>
                    <p>{error}</p>
                  </div>
                </div>
              </div>
            )}

            <UploadDropzone
              endpoint={endpoint}
              onUploadBegin={() => {
                setIsUploading(true);
                setError(null);
              }}
              onClientUploadComplete={res => {
                setIsUploading(false);
                if (res && res[0]) {
                  onChange(res[0].url);
                }
              }}
              onUploadError={err => {
                setIsUploading(false);
                setError(err.message);
              }}
              onBeforeUploadBegin={validateAndProcessFiles}
              content={{
                label: `Upload ${label}`,
                allowedContent: `Images (${MAX_IMAGE_SIZE_KB}KB) or PDFs (${MAX_PDF_SIZE_KB}KB)`,
              }}
              config={{
                mode: 'auto',
              }}
            />

            <div className="mt-3 text-xs text-muted-foreground space-y-1">
              <p>• Images will be automatically compressed if possible</p>
              <p>• PDFs must be under {MAX_PDF_SIZE_KB}KB (typically 1 page)</p>
              <p>• For best results, ensure documents are clearly legible</p>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

```

### apps\web\app\components\layout\app-sidebar.tsx:
```
'use client';

import * as React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Home, Users, Package, BarChart, LogOut, Leaf, ChevronLeft, Menu } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { cn } from '@workspace/ui/lib/utils';
import { Button } from '@workspace/ui/components/button';

const baseNavItems = [
  { title: 'Dashboard', href: '/dashboard', icon: Home, adminOnly: true },
  { title: 'Farmer Details', href: '/farmers', icon: Leaf, adminOnly: false },
  { title: 'Procurement', href: '/procurements', icon: Package, adminOnly: false },
  { title: 'Processing Batches', href: '/processing-batches', icon: BarChart, adminOnly: false },
];

const adminNavItems = [{ title: 'Staff Management', href: '/staff', icon: Users, adminOnly: true }];

const MIN_WIDTH = 60;
const MAX_WIDTH = 280;
const DEFAULT_WIDTH = 200;

export function AppSidebar(props: React.HTMLAttributes<HTMLDivElement>) {
  const pathname = usePathname();
  const { user, signOut } = useAuth();
  const [isLoaded, setIsLoaded] = React.useState(false);
  const [collapsed, setCollapsed] = React.useState(true);
  const [sidebarWidth, setSidebarWidth] = React.useState(MIN_WIDTH);
  const [isResizing, setIsResizing] = React.useState(false);

  const isRouteActive = (href: string) => pathname === href || pathname.startsWith(`${href}/`);

  const navItems = React.useMemo(() => {
    let items = [...baseNavItems];
    if (user?.role === 'ADMIN') {
      items = items.concat(adminNavItems);
    }
    items = items.filter(item => !item.adminOnly || (item.adminOnly && user?.role === 'ADMIN'));
    return items;
  }, [user]);

  React.useEffect(() => {
    try {
      const storedCollapsed = localStorage.getItem('sidebar-collapsed');
      const storedWidth = localStorage.getItem('sidebar-width');

      setCollapsed(storedCollapsed ? JSON.parse(storedCollapsed) : false);
      setSidebarWidth(storedWidth ? Math.max(MIN_WIDTH, Math.min(JSON.parse(storedWidth), MAX_WIDTH)) : DEFAULT_WIDTH);
    } catch (error) {
      console.error('Error loading sidebar state:', error);
    } finally {
      setIsLoaded(true);
    }
  }, []);

  React.useEffect(() => {
    if (!isLoaded) return;
    localStorage.setItem('sidebar-collapsed', JSON.stringify(collapsed));
    localStorage.setItem('sidebar-width', JSON.stringify(sidebarWidth));
  }, [collapsed, sidebarWidth, isLoaded]);

  const toggleCollapse = () => {
    setCollapsed(!collapsed);
  };

  const startResize = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
  };

  React.useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isResizing) return;
      let newWidth = e.clientX;
      newWidth = Math.max(MIN_WIDTH, Math.min(newWidth, MAX_WIDTH));
      setSidebarWidth(newWidth);

      if (newWidth < MIN_WIDTH + 20 && !collapsed) {
        setCollapsed(true);
      } else if (newWidth > MIN_WIDTH + 50 && collapsed) {
        setCollapsed(false);
      }
    };

    const handleMouseUp = () => {
      setIsResizing(false);
      document.body.style.cursor = '';
    };

    if (isResizing) {
      document.body.style.cursor = 'col-resize';
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isResizing, collapsed]);

  if (!isLoaded || !user) {
    // Add !user check here to avoid rendering sidebar before user is loaded
    return (
      <div className="flex flex-col h-full bg-white border-r border-gray-200 shadow-md" style={{ width: MIN_WIDTH }}>
        <div className="flex items-center justify-center h-16 border-b">
          <div className="w-8 h-8 bg-gray-200 rounded animate-pulse" />
        </div>
        {/* ... rest of skeleton ... */}
      </div>
    );
  }

  return (
    <div
      className="flex flex-col h-full bg-white border-r  shadow-md relative group transition-all duration-300 ease-in-out"
      style={{ width: collapsed ? MIN_WIDTH : sidebarWidth }}
      {...props}
    >
      <div className="flex items-center justify-between h-16 border-b border-gray-200 px-4 bg-gray-100">
        {!collapsed && (
          <div className="text-xl font-bold text-green-600 whitespace-nowrap transition-opacity duration-200 ease-in-out">
            Chaya
          </div>
        )}
        <Button
          variant="outline"
          size="icon"
          onClick={toggleCollapse}
          className="h-8 w-8 ml-1 border border-gray-300 rounded-md shadow-sm hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-green-500 transition-all duration-200"
          aria-label={collapsed ? 'Expand sidebar' : 'Collapse sidebar'}
        >
          {collapsed ? <Menu className="h-4 w-4 text-gray-600" /> : <ChevronLeft className="h-4 w-4 text-gray-600" />}
        </Button>
      </div>

      <div className="flex flex-1 flex-col justify-between overflow-hidden">
        <nav className="p-2 space-y-1 overflow-y-auto">
          {navItems.map(item => {
            // Condition to render item:
            // Render if not adminOnly, OR if adminOnly and user is ADMIN
            if (!item.adminOnly || (item.adminOnly && user?.role === 'ADMIN')) {
              const active = isRouteActive(item.href);
              return (
                <Link
                  key={item.href}
                  href={item.href}
                  className={cn(
                    'flex items-center gap-2 px-3 py-2 rounded-md transition-all duration-200',
                    active
                      ? 'bg-green-100 text-green-800 border-l-4 border-green-600'
                      : 'text-gray-700 hover:bg-gray-100 border-l-4 border-transparent',
                    collapsed ? 'justify-center' : ''
                  )}
                  title={collapsed ? item.title : undefined}
                >
                  <item.icon className="w-5 h-5 flex-shrink-0" />
                  {!collapsed && (
                    <span className="whitespace-nowrap transition-opacity duration-200">{item.title}</span>
                  )}
                </Link>
              );
            }
            return null; // Don't render if adminOnly and user is not admin
          })}
        </nav>

        <div className="p-2  border-t border-gray-200 ">
          <button
            onClick={signOut}
            className={cn(
              'flex items-center gap-2 px-3 py-2 text-red-600 rounded-md hover:bg-red-50 w-full transition-all duration-200 border border-transparent hover:border-red-200',
              collapsed ? 'justify-center' : ''
            )}
            title={collapsed ? 'Log Out' : undefined}
          >
            <LogOut className="w-5 h-5 flex-shrink-0" />
            {!collapsed && <span className="whitespace-nowrap transition-opacity duration-200">Log Out</span>}
          </button>
        </div>
      </div>

      <div
        className="absolute right-0 top-0 bottom-0 w-1 cursor-col-resize bg-gray-300 hover:w-2 hover:bg-green-300 active:w-3 active:bg-green-400 transition-all duration-200"
        onMouseDown={startResize}
      />
    </div>
  );
}

```

### apps\web\app\components\farmer-form\address-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';

export function AddressSection() {
  const { control } = useFormContext();

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="farmer.state"
          render={({ field }) => (
            <FormItem>
              <FormLabel>State</FormLabel>
              <FormControl>
                <Input placeholder="Enter state" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.district"
          render={({ field }) => (
            <FormItem>
              <FormLabel>District</FormLabel>
              <FormControl>
                <Input placeholder="Enter district" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.mandal"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Mandal</FormLabel>
              <FormControl>
                <Input placeholder="Enter mandal" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.village"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Village</FormLabel>
              <FormControl>
                <Input placeholder="Enter village" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.panchayath"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Panchayath</FormLabel>
              <FormControl>
                <Input placeholder="Enter panchayath" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\LocationButton.tsx:
```
import { MapPin, Loader2 } from 'lucide-react';
import { Button } from '@workspace/ui/components/button';
import { useState } from 'react';
import { toast } from 'sonner';

export interface LocationData {
  lat: number;
  lng: number;
  accuracy: number;
  altitude: number | null;
  altitudeAccuracy: number | null;
  timestamp: number;
}

interface LocationButtonProps {
  onLocationUpdate: (location: LocationData) => void;
  fieldIndex: number;
}

export function LocationButton({ onLocationUpdate }: LocationButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  const getCurrentLocation = () => {
    setIsLoading(true);
    if (!('geolocation' in navigator)) {
      toast.error('Geolocation is not supported by your browser');
      setIsLoading(false);
      return;
    }

    const options: PositionOptions = {
      enableHighAccuracy: true,
      timeout: 5000,
      maximumAge: 0,
    };

    navigator.geolocation.getCurrentPosition(
      position => {
        const locationData: LocationData = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          altitude: position.coords.altitude,
          altitudeAccuracy: position.coords.altitudeAccuracy,
          timestamp: position.timestamp,
        };
        onLocationUpdate(locationData);
        setIsLoading(false);
        toast.success('Location updated successfully');
      },
      error => {
        let errorMessage = 'Failed to get location';
        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'Location permission denied. Please enable location access.';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'Location information unavailable. Please check your device settings.';
            break;
          case error.TIMEOUT:
            errorMessage = 'Location request timed out. Please try again.';
            break;
        }
        toast.error(errorMessage);
        setIsLoading(false);
      },
      options
    );
  };

  return (
    <Button
      type="button"
      variant="outline"
      onClick={getCurrentLocation}
      disabled={isLoading}
      className="w-full flex items-center justify-center gap-2"
    >
      {isLoading ? <Loader2 className="h-4 w-4 animate-spin" /> : <MapPin className="h-4 w-4" />}
      {isLoading ? 'Getting Location...' : 'Get Current Location'}
    </Button>
  );
}

```

### apps\web\app\components\farmer-form\fields-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Button } from '@workspace/ui/components/button';
import { Card, CardContent, CardHeader, CardTitle } from '@workspace/ui/components/card';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { DocumentUploader } from '../upload/document-uploader';
import { Plus, Trash2 } from 'lucide-react';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { LocationButton, LocationData } from './LocationButton';

export function FieldsSection() {
  const { control, watch, setValue } = useFormContext();
  const fields = watch('fields') || [];
  const { addField, removeField } = useFarmerFormStore();

  const handleLocationUpdate = (index: number, locationData: LocationData) => {
    setValue(`fields.${index}.location`, locationData, {
      shouldValidate: true,
      shouldDirty: true,
    });
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">Farm Fields</h3>
        <Button type="button" onClick={() => addField()} size="sm" variant="outline">
          <Plus className="mr-2 h-4 w-4" />
          Add Field
        </Button>
      </div>

      <div className="space-y-4">
        {fields.map((_: any, index: number) => (
          <Card key={index}>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-base">Field {index + 1}</CardTitle>
              {fields.length > 1 && (
                <Button
                  type="button"
                  onClick={() => removeField(index)}
                  variant="ghost"
                  size="sm"
                  className="h-8 w-8 p-0"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                <FormField
                  control={control}
                  name={`fields.${index}.areaHa`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Area (Hectares)</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="Enter area"
                          {...field}
                          onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                          value={field.value || ''}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={control}
                  name={`fields.${index}.yieldEstimate`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Yield Estimate</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="Enter yield estimate"
                          {...field}
                          onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                          value={field.value || ''}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="sm:col-span-2 space-y-4">
                  <FormLabel>Location</FormLabel>
                  <LocationButton
                    onLocationUpdate={(locationData: any) => handleLocationUpdate(index, locationData)}
                    fieldIndex={index}
                  />

                  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 mt-4">
                    <FormField
                      control={control}
                      name={`fields.${index}.location.lat`}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Latitude</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              placeholder="Enter latitude"
                              {...field}
                              onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                              value={field.value || ''}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={control}
                      name={`fields.${index}.location.lng`}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Longitude</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              placeholder="Enter longitude"
                              {...field}
                              onChange={e => field.onChange(parseFloat(e.target.value) || 0)}
                              value={field.value || ''}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </div>

                <FormField
                  control={control}
                  name={`fields.${index}.landDocumentUrl`}
                  render={({ field }) => (
                    <FormItem className="sm:col-span-2">
                      <FormControl>
                        <DocumentUploader
                          endpoint="landDocument"
                          label="Land Document"
                          value={field.value}
                          onChange={field.onChange}
                          accept="image/*,.pdf"
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\index.ts:
```
export * from './farmer-form';
export * from './personal-info-section';
export * from './address-section';
export * from './bank-details-section';
export * from './documents-section';
export * from './fields-section';
export * from './review-section';

```

### apps\web\app\components\farmer-form\personal-info-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { CalendarIcon, ChevronLeft, ChevronRight } from 'lucide-react';
import { addYears, format, subYears } from 'date-fns';
import { Calendar } from '@workspace/ui/components/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Button } from '@workspace/ui/components/button';
import { useEffect, useState } from 'react';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { cn } from '@workspace/ui/lib/utils';

export function PersonalInfoSection() {
  const { control, watch } = useFormContext();
  const { calculateAge } = useFarmerFormStore();

  // Watch birth date to calculate age automatically
  const birthDate = watch('farmer.dateOfBirth');

  // State for the calendar to handle year navigation
  const [calendarDate, setCalendarDate] = useState<Date>(new Date());

  useEffect(() => {
    if (birthDate) {
      calculateAge(birthDate);
    }
  }, [birthDate, calculateAge]);

  // Navigate years quickly
  const goToPreviousYear = () => {
    setCalendarDate(prev => subYears(prev, 1));
  };

  const goToNextYear = () => {
    setCalendarDate(prev => addYears(prev, 1));
  };

  const goBackTenYears = () => {
    setCalendarDate(prev => subYears(prev, 10));
  };

  const goForwardTenYears = () => {
    setCalendarDate(prev => addYears(prev, 10));
  };

  // Array of common years for quick selection
  const quickYears = [
    new Date().getFullYear() - 18, // 18 years ago
    new Date().getFullYear() - 25, // 25 years ago
    new Date().getFullYear() - 35, // 35 years ago
    new Date().getFullYear() - 45, // 45 years ago
    new Date().getFullYear() - 55, // 55 years ago
    new Date().getFullYear() - 65, // 65 years ago
  ];

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="farmer.name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Full Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter full name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.relationship"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Relationship</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select relationship" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="SELF">SELF</SelectItem>
                  <SelectItem value="SPOUSE">SPOUSE</SelectItem>
                  <SelectItem value="CHILD">CHILD</SelectItem>
                  <SelectItem value="OTHER">OTHER</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.gender"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Gender</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select gender" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="MALE">MALE</SelectItem>
                  <SelectItem value="FEMALE">FEMALE</SelectItem>
                  <SelectItem value="OTHER">OTHER</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.community"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Community</FormLabel>
              <FormControl>
                <Input placeholder="Enter community" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.aadharNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Aadhar Number</FormLabel>
              <FormControl>
                <Input placeholder="12-digit Aadhar number" {...field} maxLength={12} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.dateOfBirth"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Date of Birth</FormLabel>
              <Popover>
                <PopoverTrigger asChild>
                  <FormControl>
                    <Button
                      variant={'outline'}
                      className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                    >
                      {field.value ? format(new Date(field.value), 'PPP') : <span>Pick a date</span>}
                      <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                    </Button>
                  </FormControl>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <div className="p-2 border-b flex items-center justify-between">
                    <div className="flex gap-1">
                      <Button variant="outline" size="sm" onClick={goBackTenYears} title="Back 10 years">
                        <ChevronLeft className="h-4 w-4" />
                        <ChevronLeft className="h-4 w-4 -ml-2" />
                      </Button>
                      <Button variant="outline" size="sm" onClick={goToPreviousYear} title="Previous year">
                        <ChevronLeft className="h-4 w-4" />
                      </Button>
                    </div>
                    <div className="text-sm font-medium">{format(calendarDate, 'yyyy')}</div>
                    <div className="flex gap-1">
                      <Button variant="outline" size="sm" onClick={goToNextYear} title="Next year">
                        <ChevronRight className="h-4 w-4" />
                      </Button>
                      <Button variant="outline" size="sm" onClick={goForwardTenYears} title="Forward 10 years">
                        <ChevronRight className="h-4 w-4" />
                        <ChevronRight className="h-4 w-4 -ml-2" />
                      </Button>
                    </div>
                  </div>

                  <div className="p-2 border-b">
                    <div className="text-sm font-medium mb-2">Quick Select Year</div>
                    <div className="grid grid-cols-3 gap-1">
                      {quickYears.map(year => (
                        <Button
                          key={year}
                          variant="outline"
                          size="sm"
                          onClick={() => {
                            const newDate = new Date(calendarDate);
                            newDate.setFullYear(year);
                            setCalendarDate(newDate);
                          }}
                        >
                          {year}
                        </Button>
                      ))}
                    </div>
                  </div>

                  <Calendar
                    mode="single"
                    selected={field.value ? new Date(field.value) : undefined}
                    onSelect={date => field.onChange(date?.toISOString().split('T')[0] || '')}
                    disabled={date => date > new Date() || date < new Date('1900-01-01')}
                    month={calendarDate}
                    onMonthChange={setCalendarDate}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.age"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Age</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  placeholder="Auto-calculated from birth date"
                  {...field}
                  value={field.value || ''}
                  disabled
                  className="bg-muted"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="farmer.contactNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Contact Number</FormLabel>
              <FormControl>
                <Input placeholder="10-digit contact number" {...field} maxLength={10} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\documents-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { DocumentUploader } from '../upload/document-uploader';

export function DocumentsSection() {
  const { control } = useFormContext();

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-6">
        <FormField
          control={control}
          name="documents.profilePicUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="profilePicture"
                  label="Profile Picture"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="documents.aadharDocUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="aadharDocument"
                  label="Aadhar Document"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*,.pdf"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="documents.bankDocUrl"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <DocumentUploader
                  endpoint="bankDocument"
                  label="Bank Document"
                  value={field.value}
                  onChange={field.onChange}
                  accept="image/*,.pdf"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\review-section.tsx:
```
// components/farmer-form/review-section.tsx
'use client';

import { useFormContext } from 'react-hook-form';
import { Card, CardContent, CardHeader, CardTitle } from '@workspace/ui/components/card';
import { format } from 'date-fns';

export function ReviewSection() {
  const { watch } = useFormContext();
  const formValues = watch();
  const { farmer, bankDetails, documents, fields } = formValues;

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Personal Information</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Name</dt>
              <dd className="text-sm">{farmer.name || 'N/A'}</dd>
            </div>
            {/* <div>
							<dt className="text-sm font-medium text-muted-foreground">Survey Number</dt>
							<dd className="text-sm">{farmer.surveyNumber || 'N/A'}</dd>
						</div> */}
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Relationship</dt>
              <dd className="text-sm">{farmer.relationship || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Gender</dt>
              <dd className="text-sm">{farmer.gender || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Community</dt>
              <dd className="text-sm">{farmer.community || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Aadhar Number</dt>
              <dd className="text-sm">{farmer.aadharNumber || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Date of Birth</dt>
              <dd className="text-sm">{farmer.dateOfBirth ? format(new Date(farmer.dateOfBirth), 'PPP') : 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Age</dt>
              <dd className="text-sm">{farmer.age || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Contact Number</dt>
              <dd className="text-sm">{farmer.contactNumber || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Address Information</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">State</dt>
              <dd className="text-sm">{farmer.state || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">District</dt>
              <dd className="text-sm">{farmer.district || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Mandal</dt>
              <dd className="text-sm">{farmer.mandal || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Village</dt>
              <dd className="text-sm">{farmer.village || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Panchayath</dt>
              <dd className="text-sm">{farmer.panchayath || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Bank Details</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">IFSC Code</dt>
              <dd className="text-sm">{bankDetails?.ifscCode || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Name</dt>
              <dd className="text-sm">{bankDetails?.bankName || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Branch Name</dt>
              <dd className="text-sm">{bankDetails?.branchName || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Account Number</dt>
              <dd className="text-sm">{bankDetails?.accountNumber || 'N/A'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Code</dt>
              <dd className="text-sm">{bankDetails?.bankCode || 'N/A'}</dd>
            </div>
            <div className="sm:col-span-2">
              <dt className="text-sm font-medium text-muted-foreground">Bank Address</dt>
              <dd className="text-sm">{bankDetails?.address || 'N/A'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Documents</CardTitle>
        </CardHeader>
        <CardContent>
          <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Profile Picture</dt>
              <dd className="text-sm">{documents?.profilePicUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Aadhar Document</dt>
              <dd className="text-sm">{documents?.aadharDocUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
            <div>
              <dt className="text-sm font-medium text-muted-foreground">Bank Document</dt>
              <dd className="text-sm">{documents?.bankDocUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
            </div>
          </dl>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Fields</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {fields?.map((field: any, index: number) => (
              <Card key={index}>
                <CardHeader>
                  <CardTitle className="text-base">Field {index + 1}</CardTitle>
                </CardHeader>
                <CardContent>
                  <dl className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Area (Hectares)</dt>
                      <dd className="text-sm">{field.areaHa || 'N/A'}</dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Yield Estimate</dt>
                      <dd className="text-sm">{field.yieldEstimate || 'N/A'}</dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Location</dt>
                      <dd className="text-sm">
                        {field.location
                          ? `Lat: ${field.location.lat?.toFixed(6)}, Lng: ${field.location.lng?.toFixed(6)}`
                          : 'N/A'}
                      </dd>
                    </div>
                    <div>
                      <dt className="text-sm font-medium text-muted-foreground">Land Document</dt>
                      <dd className="text-sm">{field.landDocumentUrl ? 'Uploaded' : 'Not Uploaded'}</dd>
                    </div>
                  </dl>
                </CardContent>
              </Card>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

### apps\web\app\components\farmer-form\farmer-form.tsx:
```
'use client';

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { Button } from '@workspace/ui/components/button';
import { PersonalInfoSection } from './personal-info-section';
import { AddressSection } from './address-section';
import { BankDetailsSection } from './bank-details-section';
import { DocumentsSection } from './documents-section';
import { FieldsSection } from './fields-section';
import { ReviewSection } from './review-section';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import axios from 'axios';
import { useFarmerFormStore } from '@/app/stores/farmer-form';
import { FieldValues } from 'react-hook-form';
import { toast } from 'sonner';

interface FarmerFormProps {
  mode: 'add' | 'edit';
  open: boolean;
  onOpenChange: (open: boolean) => void;
  farmerId?: number;
}

export function FarmerForm({ mode, open, onOpenChange, farmerId }: FarmerFormProps) {
  const { activeTab, setActiveTab, goToNextTab, goToPreviousTab, form, isSubmitting, setIsSubmitting } =
    useFarmerFormStore();
  const title = mode === 'add' ? 'Add New Farmer' : 'Edit Farmer';

  const handleSubmit = async (data: FieldValues) => {
    setIsSubmitting(true);
    console.log('Submitting data:', JSON.stringify(data, null, 2));

    try {
      const axiosConfig = {
        withCredentials: true,
        headers: {
          'Content-Type': 'application/json',
        },
      };

      const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

      if (mode === 'add') {
        console.log('Doing a POST request to add a new farmer');
        const response = await axios.post(`${apiBaseUrl}/api/farmers`, data, axiosConfig);
        console.log('POST response:', response.data);
        toast.success('Farmer added successfully');
      } else {
        console.log('Doing a PUT request to update farmer', farmerId);
        const response = await axios.put(`${apiBaseUrl}/api/farmers/${farmerId}`, data, axiosConfig);
        console.log('PUT response:', response.data);
        toast.success('Farmer updated successfully');
      }

      const dataChangedEvent = new CustomEvent('farmerDataChanged');
      document.dispatchEvent(dataChangedEvent);
      console.log('Data changed event dispatched after successful form submission');

      onOpenChange(false);
    } catch (error: any) {
      console.error('Error submitting form:', error);
      console.error('Error response:', error.response?.data);

      if (error.response?.status === 401) {
        toast.error('Your session has expired. Please log in again.');
      } else {
        toast.error(`Error: ${error.response?.data?.error || error.message || 'Something went wrong'}`);
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        <Tabs value={activeTab} onValueChange={setActiveTab} className="mt-4">
          <TabsList className="grid w-full grid-cols-6">
            <TabsTrigger value="personal">Personal</TabsTrigger>
            <TabsTrigger value="address">Address</TabsTrigger>
            <TabsTrigger value="bank">Bank</TabsTrigger>
            <TabsTrigger value="documents">Documents</TabsTrigger>
            <TabsTrigger value="fields">Fields</TabsTrigger>
            <TabsTrigger value="review">Review</TabsTrigger>
          </TabsList>
          <TabsContent value="personal" className="space-y-4">
            <PersonalInfoSection />
          </TabsContent>
          <TabsContent value="address" className="space-y-4">
            <AddressSection />
          </TabsContent>
          <TabsContent value="bank" className="space-y-4">
            <BankDetailsSection />
          </TabsContent>
          <TabsContent value="documents" className="space-y-4">
            <DocumentsSection />
          </TabsContent>
          <TabsContent value="fields" className="space-y-4">
            <FieldsSection />
          </TabsContent>
          <TabsContent value="review" className="space-y-4">
            <ReviewSection />
          </TabsContent>
        </Tabs>
        <DialogFooter className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Button variant="outline" onClick={goToPreviousTab} disabled={activeTab === 'personal'}>
              Previous
            </Button>
            <Button variant="outline" onClick={goToNextTab} disabled={activeTab === 'review'}>
              Next
            </Button>
          </div>
          <div className="flex items-center gap-2">
            <Button variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            {activeTab === 'review' && (
              <Button
                type="button"
                onClick={async () => {
                  console.log('Submit button clicked, form exists:', !!form);
                  if (form) {
                    const values = form.getValues();
                    console.log('Current form values:', values);

                    const isValid = await form.trigger();
                    console.log('Form validation result:', isValid);

                    setTimeout(() => {
                      const errors = form.formState.errors;
                      console.log('Detailed errors:', JSON.stringify(errors, null, 2));

                      if (errors.farmer) console.log('Farmer field errors:', errors.farmer);
                      if (errors.bankDetails) console.log('Bank details errors:', errors.bankDetails);
                      if (errors.fields) console.log('Fields errors:', errors.fields);
                    }, 100);

                    if (isValid) {
                      handleSubmit(values);
                    } else {
                      toast.error('Form validation failed. Please check all tabs for errors.');
                    }
                  } else {
                    toast.error('Form data is not available. Please try again.');
                  }
                }}
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Saving...' : 'Save Farmer'}
              </Button>
            )}
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\components\farmer-form\bank-details-section.tsx:
```
'use client';

import { useFormContext } from 'react-hook-form';
import { Input } from '@workspace/ui/components/input';
import { FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Textarea } from '@workspace/ui/components/textarea';
import { useState } from 'react';
import { Loader2 } from 'lucide-react';
import { toast } from 'sonner';

export function BankDetailsSection() {
  const { control, setValue, setError, clearErrors } = useFormContext();
  const [loadingIFSC, setLoadingIFSC] = useState(false);

  const handleIFSCChange = async (ifscCode: string) => {
    if (!ifscCode || ifscCode.length !== 11) {
      return;
    }

    setLoadingIFSC(true);
    clearErrors('bankDetails.ifscCode');

    try {
      const response = await fetch(`https://ifsc.razorpay.com/${ifscCode}`);
      if (!response.ok) {
        setError('bankDetails.ifscCode', {
          type: 'manual',
          message: 'Failed to fetch IFSC details. Please check the code.',
        });
        toast.error('Failed to fetch IFSC details. Please verify the code.');
        return;
      }

      const data = await response.json();
      setValue('bankDetails.branchName', data.BRANCH || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.address', data.ADDRESS || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.bankName', data.BANK || '', {
        shouldValidate: true,
      });
      setValue('bankDetails.bankCode', data.BANKCODE || '', {
        shouldValidate: true,
      });
      toast.success('IFSC details fetched successfully.');
    } catch (error) {
      console.error('Error fetching IFSC details:', error);
      setError('bankDetails.ifscCode', {
        type: 'manual',
        message: 'Failed to fetch IFSC details due to a network error.',
      });
      toast.error('Network error while fetching IFSC details. Please try again later.');
    } finally {
      setLoadingIFSC(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <FormField
          control={control}
          name="bankDetails.ifscCode"
          render={({ field }) => (
            <FormItem>
              <FormLabel>IFSC Code</FormLabel>
              <div className="relative">
                <FormControl>
                  <Input
                    placeholder="Enter IFSC code"
                    {...field}
                    onChange={e => {
                      const value = e.target.value.toUpperCase();
                      field.onChange(value);
                      if (value.length === 11) {
                        handleIFSCChange(value);
                      }
                    }}
                    maxLength={11}
                    className={loadingIFSC ? 'pr-10' : ''}
                  />
                </FormControl>
                {loadingIFSC && (
                  <div className="absolute right-3 top-1/2 -translate-y-1/2">
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  </div>
                )}
              </div>
              <FormMessage />
              <p className="text-xs text-muted-foreground mt-1">Enter a valid IFSC code to auto-fill bank details</p>
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.bankName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Bank Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter bank name" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.branchName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Branch Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter branch name" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.accountNumber"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Account Number</FormLabel>
              <FormControl>
                <Input placeholder="Enter account number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.bankCode"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Bank Code</FormLabel>
              <FormControl>
                <Input placeholder="Enter bank code" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="bankDetails.address"
          render={({ field }) => (
            <FormItem className="sm:col-span-2">
              <FormLabel>Bank Address</FormLabel>
              <FormControl>
                <Textarea placeholder="Enter bank address" className="resize-none" {...field} disabled={loadingIFSC} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}

```

### apps\web\app\components\procurement-form\basic-info-section.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import { useFormContext, Controller, useWatch } from 'react-hook-form'; // Use useFormContext
import { z } from 'zod';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Combobox } from '@workspace/ui/components/combobox';
import axios from 'axios';
import { toast } from 'sonner';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form'; // Import the full form type

interface Farmer {
  id: number;
  name: string;
  village: string;
  mandal: string;
}

const CROP_OPTIONS = ['Turmeric', 'Coffee', 'Ginger', 'Pepper'] as const;
type CropType = (typeof CROP_OPTIONS)[number];

const PROCURED_FORMS_BY_CROP: Record<CropType, string[]> = {
  Turmeric: ['Fresh Finger', 'Fresh Bulb', 'Dried Finger', 'Dried Bulb'],
  Coffee: ['Fruit', 'Dry Cherry', 'Parchment'],
  Ginger: ['Fresh', 'Dried'],
  Pepper: ['Green Pepper', 'Black Pepper'],
};

export function BasicInfoSection() {
  const {
    control,
    formState: { errors },
    setValue,
    watch,
  } = useFormContext<ProcurementFullFormValues>(); // Use context

  const [farmers, setFarmers] = useState<Farmer[]>([]);
  const [isLoadingFarmers, setIsLoadingFarmers] = useState(false);

  const watchedCrop = watch('crop'); // Watch from the shared form context

  useEffect(() => {
    if (watchedCrop) {
      const currentProcuredFormsForNewCrop = PROCURED_FORMS_BY_CROP[watchedCrop as CropType] || [];
      const currentProcuredFormValue = control._formValues.procuredForm; // Access current value directly

      if (currentProcuredFormValue && !currentProcuredFormsForNewCrop.includes(currentProcuredFormValue)) {
        setValue('procuredForm', '', { shouldValidate: true });
      } else if (!currentProcuredFormValue && currentProcuredFormsForNewCrop.length > 0) {
        // If crop changes and procuredForm was empty, keep it empty unless logic dictates a default.
      }
    }
  }, [watchedCrop, setValue, control._formValues.procuredForm]);

  useEffect(() => {
    const fetchFarmers = async () => {
      setIsLoadingFarmers(true);
      try {
        const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';
        const response = await axios.get(`${apiBaseUrl}/api/farmers`, {
          params: { limit: 1000, isActive: true },
          withCredentials: true,
        });
        setFarmers(response.data.farmers);
      } catch (error) {
        console.error('Error fetching farmers:', error);
        toast.error('Failed to load farmers. Please try again.');
      } finally {
        setIsLoadingFarmers(false);
      }
    };
    fetchFarmers();
  }, []);

  const currentProcuredForms = watchedCrop ? PROCURED_FORMS_BY_CROP[watchedCrop as CropType] || [] : [];

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="farmerId">Farmer</Label>
            <Controller
              control={control}
              name="farmerId"
              render={({ field }) => (
                <Combobox
                  items={farmers.map(farmer => ({
                    label: `${farmer.name} (${farmer.village}, ${farmer.mandal})`,
                    value: farmer.id.toString(),
                  }))}
                  value={field.value ? field.value.toString() : ''}
                  onChange={val => field.onChange(val ? parseInt(val, 10) : undefined)}
                  placeholder="Select a farmer"
                  isLoading={isLoadingFarmers}
                />
              )}
            />
            {errors.farmerId && <p className="text-sm text-red-500 mt-1">{errors.farmerId.message}</p>}
          </div>
          <div>
            <Label htmlFor="crop">Crop</Label>
            <Controller
              control={control}
              name="crop"
              render={({ field }) => (
                <Select
                  onValueChange={field.onChange}
                  value={field.value || ''} // Ensure value is passed for controlled Select
                  // defaultValue={field.value} // Not needed if value is passed
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select crop" />
                  </SelectTrigger>
                  <SelectContent>
                    {CROP_OPTIONS.map(cropName => (
                      <SelectItem key={cropName} value={cropName}>
                        {cropName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.crop && <p className="text-sm text-red-500 mt-1">{errors.crop.message}</p>}
          </div>
          <div>
            <Label htmlFor="procuredForm">Procured Form</Label>
            <Controller
              control={control}
              name="procuredForm"
              render={({ field }) => (
                <Select
                  onValueChange={field.onChange}
                  value={field.value || ''} // Ensure value is passed
                  disabled={!watchedCrop || currentProcuredForms.length === 0}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select form (after choosing crop)" />
                  </SelectTrigger>
                  <SelectContent>
                    {currentProcuredForms.map(formName => (
                      <SelectItem key={formName} value={formName}>
                        {formName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.procuredForm && <p className="text-sm text-red-500 mt-1">{errors.procuredForm.message}</p>}
          </div>
          <div>
            <Label htmlFor="speciality">Speciality</Label>
            <Controller
              control={control}
              name="speciality"
              render={({ field }) => (
                <Select onValueChange={field.onChange} value={field.value || ''}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select speciality" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="Organic">Organic</SelectItem>
                    <SelectItem value="Non-GMO">Non-GMO</SelectItem>
                    <SelectItem value="Fair Trade">Fair Trade</SelectItem>
                    <SelectItem value="Standard">Standard</SelectItem>
                  </SelectContent>
                </Select>
              )}
            />
            {errors.speciality && <p className="text-sm text-red-500 mt-1">{errors.speciality.message}</p>}
          </div>
          <div>
            <Label htmlFor="quantity">Quantity (kg)</Label>
            <Controller
              control={control}
              name="quantity"
              render={({ field }) => (
                <Input
                  type="number"
                  step="0.01"
                  min="0"
                  {...field}
                  value={field.value === undefined ? '' : field.value}
                  onChange={e => field.onChange(e.target.value === '' ? undefined : parseFloat(e.target.value))}
                />
              )}
            />
            {errors.quantity && <p className="text-sm text-red-500 mt-1">{errors.quantity.message}</p>}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\details-section.tsx:
```
'use client';

import { useFormContext, Controller } from 'react-hook-form';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Button } from '@workspace/ui/components/button';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { format } from 'date-fns';
import { Calendar } from '@workspace/ui/components/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { CalendarIcon, Clock } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form';

export function DetailsSection() {
  const {
    control,
    register: formRegister,
    formState: { errors },
  } = useFormContext<ProcurementFullFormValues>();

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="date">Date</Label>
            <Controller
              control={control}
              name="date"
              render={({ field }) => (
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      className={cn(
                        'w-full justify-start text-left font-normal',
                        !field.value && 'text-muted-foreground'
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <Calendar
                      mode="single"
                      selected={field.value instanceof Date ? field.value : undefined}
                      onSelect={field.onChange}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              )}
            />
            {errors.date && <p className="text-sm text-red-500 mt-1">{errors.date.message}</p>}
          </div>

          <div>
            <Label htmlFor="time">Time</Label>
            <Controller
              control={control}
              name="time"
              render={({ field }) => (
                <div className="flex items-center">
                  <Input
                    type="time"
                    step="1"
                    className="flex-1"
                    {...field}
                    value={field.value ? field.value.substring(0, 8) : format(new Date(), 'HH:mm:ss')}
                    onChange={e => {
                      let timeValue = e.target.value;
                      if (timeValue.match(/^\d{2}:\d{2}$/)) {
                        timeValue += ':00';
                      } else if (!timeValue.match(/^\d{2}:\d{2}:\d{2}$/)) {
                        timeValue = field.value || format(new Date(), 'HH:mm:ss');
                      }
                      field.onChange(timeValue);
                    }}
                  />
                  <Clock className="ml-2 h-4 w-4 text-muted-foreground" />
                </div>
              )}
            />
            {errors.time && <p className="text-sm text-red-500 mt-1">{errors.time.message}</p>}
          </div>

          <div>
            <Label htmlFor="lotNo">Lot Number</Label>
            <Controller
              control={control}
              name="lotNo"
              render={({ field }) => (
                <Select onValueChange={value => field.onChange(Number.parseInt(value))} value={field.value?.toString()}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select lot number" />
                  </SelectTrigger>
                  <SelectContent>
                    {[1, 2, 3].map(num => (
                      <SelectItem key={num} value={num.toString()}>
                        {num}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            />
            {errors.lotNo && <p className="text-sm text-red-500 mt-1">{errors.lotNo.message}</p>}
          </div>

          <div>
            <Label htmlFor="procuredBy">Procured By</Label>
            <Input id="procuredBy" {...formRegister('procuredBy')} />
            {errors.procuredBy && <p className="text-sm text-red-500 mt-1">{errors.procuredBy.message}</p>}
          </div>

          <div>
            <Label htmlFor="vehicleNo">Vehicle Number (Optional)</Label>
            <Input id="vehicleNo" {...formRegister('vehicleNo')} />
            {errors.vehicleNo && <p className="text-sm text-red-500 mt-1">{errors.vehicleNo.message}</p>}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\review-section.tsx:
```
'use client';
import { useFormContext } from 'react-hook-form';
import { Card, CardContent } from '@workspace/ui/components/card';
import { Separator } from '@workspace/ui/components/separator';
import { format } from 'date-fns';
import type { ProcurementFullFormValues } from '@/app/stores/procurement-form';

export function ReviewSection() {
  const { getValues } = useFormContext<ProcurementFullFormValues>();
  const formValues = getValues();

  if (!formValues) {
    return (
      <Card>
        <CardContent className="pt-6">
          <p className="text-center text-muted-foreground">Form data not available for review.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold">Basic Information</h3>
            <Separator className="my-2" />
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <p className="text-sm font-medium">Farmer ID:</p>
                <p className="text-sm">{formValues.farmerId || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Crop:</p>
                <p className="text-sm">{formValues.crop || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Procured Form:</p>
                <p className="text-sm">{formValues.procuredForm || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Speciality:</p>
                <p className="text-sm">{formValues.speciality || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Quantity:</p>
                <p className="text-sm">{formValues.quantity !== undefined ? `${formValues.quantity} kg` : 'N/A'}</p>
              </div>
            </div>
          </div>

          <div>
            <h3 className="text-lg font-semibold">Procurement Details</h3>
            <Separator className="my-2" />
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <p className="text-sm font-medium">Date:</p>
                <p className="text-sm">
                  {formValues.date ? format(new Date(formValues.date), 'dd/MM/yyyy') : 'Not set'}
                </p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Time:</p>
                <p className="text-sm">{formValues.time || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Lot Number:</p>
                <p className="text-sm">{formValues.lotNo || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Procured By:</p>
                <p className="text-sm">{formValues.procuredBy || 'N/A'}</p>
              </div>
              <div className="space-y-1">
                <p className="text-sm font-medium">Vehicle Number:</p>
                <p className="text-sm">{formValues.vehicleNo || 'N/A'}</p>
              </div>
            </div>
          </div>

          <div className="rounded-md bg-muted p-4">
            <p className="text-sm text-muted-foreground">
              Please review the information above before submitting. A procurement number will be automatically
              generated.
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\components\procurement-form\procurement-form.tsx:
```
'use client';

import { useEffect } from 'react';
import { useForm, FormProvider, type FieldValues } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { Button } from '@workspace/ui/components/button';
import { BasicInfoSection } from './basic-info-section';
import { DetailsSection } from './details-section';
import { ReviewSection } from './review-section';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import axios from 'axios';
import {
  useProcurementFormStore,
  procurementFullFormSchema,
  type ProcurementFullFormValues,
  type TabType,
} from '@/app/stores/procurement-form';
import { toast } from 'sonner';
import { format } from 'date-fns';

interface ProcurementFormProps {
  mode: 'add' | 'edit';
  open: boolean;
  onOpenChange: (open: boolean) => void;
  procurementId?: number;
}

export function ProcurementForm({ mode, open, onOpenChange, procurementId }: ProcurementFormProps) {
  const {
    activeTab,
    setActiveTab,
    goToNextTab,
    goToPreviousTab,
    setForm: setZustandForm,
    isSubmitting,
    setIsSubmitting,
    initialData,
  } = useProcurementFormStore();

  const title = mode === 'add' ? 'Add New Procurement' : 'Edit Procurement';

  const methods = useForm<ProcurementFullFormValues>({
    resolver: zodResolver(procurementFullFormSchema),
    defaultValues:
      mode === 'edit' && initialData
        ? {
            farmerId: initialData.farmerId,
            crop: initialData.crop,
            procuredForm: initialData.procuredForm,
            speciality: initialData.speciality,
            quantity: initialData.quantity,
            date: initialData.date ? new Date(initialData.date) : new Date(),
            time: initialData.time ? format(new Date(initialData.time), 'HH:mm:ss') : format(new Date(), 'HH:mm:ss'),
            lotNo: initialData.lotNo,
            procuredBy: initialData.procuredBy,
            vehicleNo: initialData.vehicleNo || '',
          }
        : {
            farmerId: undefined,
            crop: '',
            procuredForm: '',
            speciality: '',
            quantity: undefined,
            date: new Date(),
            time: format(new Date(), 'HH:mm:ss'),
            lotNo: 1,
            procuredBy: '',
            vehicleNo: '',
          },
  });

  useEffect(() => {
    setZustandForm(methods);
    if (mode === 'edit' && initialData) {
      methods.reset({
        farmerId: initialData.farmerId,
        crop: initialData.crop,
        procuredForm: initialData.procuredForm,
        speciality: initialData.speciality,
        quantity: initialData.quantity,
        date: new Date(initialData.date),
        time: format(new Date(initialData.time), 'HH:mm:ss'),
        lotNo: initialData.lotNo,
        procuredBy: initialData.procuredBy,
        vehicleNo: initialData.vehicleNo || '',
      });
    } else if (mode === 'add') {
      methods.reset({
        farmerId: undefined,
        crop: '',
        procuredForm: '',
        speciality: '',
        quantity: undefined,
        date: new Date(),
        time: format(new Date(), 'HH:mm:ss'),
        lotNo: 1,
        procuredBy: '',
        vehicleNo: '',
      });
    }
  }, [setZustandForm, mode, initialData]);

  const processAndSubmitData = async (data: ProcurementFullFormValues) => {
    setIsSubmitting(true);

    const payload = {
      ...data,
      date: data.date instanceof Date ? data.date.toISOString().split('T')[0] : data.date,
    };

    console.log('Submitting data to backend:', JSON.stringify(payload, null, 2));

    try {
      const axiosConfig = {
        withCredentials: true,
        headers: {
          'Content-Type': 'application/json',
        },
      };
      const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

      if (mode === 'add') {
        await axios.post(`${apiBaseUrl}/api/procurements`, payload, axiosConfig);
        toast.success('Procurement added successfully');
      } else {
        await axios.put(`${apiBaseUrl}/api/procurements/${procurementId}`, payload, axiosConfig);
        toast.success('Procurement updated successfully');
      }

      document.dispatchEvent(new CustomEvent('procurementDataChanged'));
      onOpenChange(false);
      methods.reset();
      useProcurementFormStore.getState().initializeForm(null, 'add');
    } catch (error: any) {
      console.error('Error submitting form:', error.response?.data || error.message);
      const errorDetails = error.response?.data?.details;
      let errorMessage = error.response?.data?.error || error.message || 'Something went wrong';
      if (errorDetails && Array.isArray(errorDetails)) {
        errorMessage = errorDetails.map((detail: any) => `${detail.path.join('.')}: ${detail.message}`).join('; ');
      }
      toast.error(`Error: ${errorMessage}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog
      open={open}
      onOpenChange={isOpen => {
        onOpenChange(isOpen);
        if (!isOpen) {
          methods.reset();
          useProcurementFormStore.getState().initializeForm(null, 'add');
        }
      }}
    >
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        <FormProvider {...methods}>
          <form onSubmit={methods.handleSubmit(processAndSubmitData)}>
            <Tabs value={activeTab} onValueChange={value => setActiveTab(value as TabType)} className="mt-4">
              <TabsList className="grid w-full grid-cols-3">
                <TabsTrigger value="basic">Basic Info</TabsTrigger>
                <TabsTrigger value="details">Details</TabsTrigger>
                <TabsTrigger value="review">Review</TabsTrigger>
              </TabsList>
              <TabsContent value="basic" className="space-y-4">
                <BasicInfoSection />
              </TabsContent>
              <TabsContent value="details" className="space-y-4">
                <DetailsSection />
              </TabsContent>
              <TabsContent value="review" className="space-y-4">
                <ReviewSection />
              </TabsContent>
            </Tabs>
            <DialogFooter className="flex items-center justify-between pt-4">
              <div className="flex items-center gap-4">
                <Button type="button" variant="outline" onClick={goToPreviousTab} disabled={activeTab === 'basic'}>
                  Previous
                </Button>
                <Button type="button" variant="outline" onClick={goToNextTab} disabled={activeTab === 'review'}>
                  Next
                </Button>
              </div>
              <div className="flex items-center gap-2">
                <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                  Cancel
                </Button>
                {activeTab === 'review' && (
                  <Button type="submit" disabled={isSubmitting || (!methods.formState.isDirty && mode === 'edit')}>
                    {isSubmitting ? 'Saving...' : 'Save Procurement'}
                  </Button>
                )}
              </div>
            </DialogFooter>
          </form>
        </FormProvider>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\providers\auth-provider.tsx:
```
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { clearSidebarCache } from '../(dashboard)/farmers/lib/sidebar-cache';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  setUser: (user: User) => void;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  setUser: () => {},
  signOut: async () => {},
});

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const API_BASE_URL = 'http://localhost:5000';

  useEffect(() => {
    async function loadUserFromServer() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Data from server of user: ', data);
          setUser(data.user);
        } else {
          console.error('Failed to fetch user: ', response.statusText);
          if (response.status === 401) {
            router.push('/login');
          }
        }
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    }

    loadUserFromServer();
  }, [router]);

  const signOut = async () => {
    try {
      await fetch(`${API_BASE_URL}/api/auth/logout`, {
        method: 'POST',
        credentials: 'include',
      });

      setUser(null);

      clearSidebarCache();

      router.push('/login');
    } catch (error) {
      console.error('Failed to sign out:', error);
    }
  };

  return <AuthContext.Provider value={{ user, loading, setUser, signOut }}>{children}</AuthContext.Provider>;
}

export const useAuth = () => useContext(AuthContext);

```

### apps\web\app\providers\theme-provider.tsx:
```
'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';

export function ThemeProvider({ children, ...props }: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

```

### apps\web\app\providers\farmer-form-provider.tsx:
```
'use client';

import { useEffect } from 'react';
import { useForm, FormProvider } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FarmerWithRelations } from '../(dashboard)/farmers/lib/types';
import { createFarmerSchema } from '@chaya/shared';
import { useFarmerFormStore } from '../stores/farmer-form';

interface FarmerFormProviderProps {
  children: React.ReactNode;
  initialData?: FarmerWithRelations;
  mode?: 'add' | 'edit';
}

export function FarmerFormProvider({ children, initialData, mode = 'add' }: FarmerFormProviderProps) {
  const defaultValues = initialData
    ? {
        farmer: {
          name: initialData.name,
          relationship: initialData.relationship,
          gender: initialData.gender,
          community: initialData.community,
          aadharNumber: initialData.aadharNumber,
          dateOfBirth: initialData.dateOfBirth.toISOString().split('T')[0],
          age: initialData.age,
          contactNumber: initialData.contactNumber,
          state: initialData.state,
          district: initialData.district,
          mandal: initialData.mandal,
          village: initialData.village,
          panchayath: initialData.panchayath,
          isActive: initialData.isActive,
        },
        bankDetails: initialData.bankDetails || {
          ifscCode: '',
          bankName: '',
          branchName: '',
          accountNumber: '',
          address: '',
          bankCode: '',
        },
        documents: initialData.documents
          ? {
              profilePicUrl: initialData.documents.profilePicUrl,
              aadharDocUrl: initialData.documents.aadharDocUrl,
              bankDocUrl: initialData.documents.bankDocUrl,
            }
          : {
              profilePicUrl: '',
              aadharDocUrl: '',
              bankDocUrl: '',
            },
        fields:
          initialData.fields && initialData.fields.length > 0
            ? initialData.fields.map(
                (field: { areaHa: any; yieldEstimate: any; location: any; landDocumentUrl: any }) => ({
                  areaHa: field.areaHa,
                  yieldEstimate: field.yieldEstimate,
                  location: field.location,
                  landDocumentUrl: field.landDocumentUrl,
                })
              )
            : [
                {
                  areaHa: 0,
                  yieldEstimate: 0,
                  location: {
                    lat: 0,
                    lng: 0,
                    accuracy: 0,
                    altitude: null,
                    altitudeAccuracy: null,
                    timestamp: Date.now(),
                  },
                  landDocumentUrl: '',
                },
              ],
      }
    : {
        farmer: {
          name: '',
          relationship: 'SELF' as const,
          gender: 'MALE' as const,
          community: '',
          aadharNumber: '',
          dateOfBirth: '',
          age: 0,
          contactNumber: '',
          state: '',
          district: '',
          mandal: '',
          village: '',
          panchayath: '',
          isActive: true,
        },
        bankDetails: {
          ifscCode: '',
          bankName: '',
          branchName: '',
          accountNumber: '',
          address: '',
          bankCode: '',
        },
        documents: {
          profilePicUrl: '',
          aadharDocUrl: '',
          bankDocUrl: '',
        },
        fields: [
          {
            areaHa: 0,
            yieldEstimate: 0,
            location: {
              lat: 0,
              lng: 0,
              accuracy: 0,
              altitude: null,
              altitudeAccuracy: null,
              timestamp: Date.now(),
            },
            landDocumentUrl: '',
          },
        ],
      };

  const form = useForm({
    resolver: zodResolver(createFarmerSchema) as any,
    defaultValues: defaultValues as any,
    mode: 'onChange',
  });

  const setForm = useFarmerFormStore((state: { setForm: any }) => state.setForm);

  useEffect(() => {
    setForm(form);

    return () => {
      setForm(null);
    };
  }, [form, setForm]);

  return <FormProvider {...form}>{children}</FormProvider>;
}

```

### apps\web\app\providers\procurement-form-provider.tsx:
```
'use client';

import React, { createContext, useContext, useEffect, type ReactNode } from 'react';
import { useProcurementFormStore } from '../stores/procurement-form';
import type { ProcurementWithRelations } from '@/app/(dashboard)/procurements/lib/types';

interface ProcurementFormContextType {
  mode: 'add' | 'edit';
  initialData?: ProcurementWithRelations | null;
}

const ProcurementFormContext = createContext<ProcurementFormContextType | undefined>(undefined);

interface ProcurementFormProviderProps {
  children: ReactNode;
  initialData?: ProcurementWithRelations | null;
  mode: 'add' | 'edit';
}

export function ProcurementFormProvider({ children, initialData, mode }: ProcurementFormProviderProps) {
  const { initializeForm } = useProcurementFormStore();

  useEffect(() => {
    initializeForm(initialData, mode);
  }, [initialData, mode, initializeForm]);

  return <ProcurementFormContext.Provider value={{ mode, initialData }}>{children}</ProcurementFormContext.Provider>;
}

export function useProcurementFormContext() {
  const context = useContext(ProcurementFormContext);
  if (context === undefined) {
    throw new Error('useProcurementFormContext must be used within a ProcurementFormProvider');
  }
  return context;
}

```

### apps\web\app\api\sales\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// For creating a new Sale
export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/sales`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/sales:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

// For fetching sales (e.g., for a batch or stage, for admins)
export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const response = await fetch(`${BACKEND_URL}/api/sales?${searchParams.toString()}`, {
      method: 'GET',
      headers: { Cookie: `token=${token}` },
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/sales:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// For creating a new Processing Stage (P-next)
export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages`, {
      // Matches backend route for creating stages
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/processing-stages:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\[stageId]\drying\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// POST for adding a new drying entry
export async function POST(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/drying`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js POST /api/processing-stages/${stageId}/drying:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

// GET for fetching drying entries for a stage
export async function GET(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/drying`, {
      method: 'GET',
      headers: { Cookie: `token=${token}` },
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js GET /api/processing-stages/${stageId}/drying:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-stages\[stageId]\finalize\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function PUT(request: Request, { params }: { params: { stageId: string } }) {
  const { stageId } = params;
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;
    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const response = await fetch(`${BACKEND_URL}/api/processing-stages/${stageId}/finalize`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', Cookie: `token=${token}` },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return new NextResponse(JSON.stringify(data), { status: response.status });
  } catch (error) {
    console.error(`Error in Next.js PUT /api/processing-stages/${stageId}/finalize:`, error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-batches\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();

    const response = await fetch(`${BACKEND_URL}/api/processing-batches`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to create processing batch on backend', details: data.details }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js POST /api/processing-batches route:', error);
    if (error instanceof Response) {
      return error;
    }
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);

    const response = await fetch(`${BACKEND_URL}/api/processing-batches?${searchParams.toString()}`, {
      method: 'GET',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to fetch processing batches from backend' }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/processing-batches route:', error);
    if (error instanceof Response) {
      return error;
    }
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

```

### apps\web\app\api\processing-batches\[batchId]\route.ts:
```
// apps/web/app/api/processing-batches/[batchId]/route.ts
import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

// Define the expected shape of the context for params
interface RouteContext {
  params: {
    batchId: string;
  };
}

export async function GET(
  request: NextRequest,
  context: RouteContext // Use the defined interface
) {
  const { batchId } = context.params; // Destructure batchId from context.params

  // console.log('[Next.js API] Trying to fetch batchId:', batchId); // Keep for a moment if needed

  if (!batchId || typeof batchId !== 'string') {
    // console.error('[Next.js API] Error: Batch ID is missing or not a string. Received:', batchId);
    return new NextResponse(JSON.stringify({ error: 'Batch ID is missing or invalid.' }), { status: 400 });
  }

  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      // console.log('[Next.js API] Error: Authentication token not found.');
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const fetchURL = `${BACKEND_URL}/api/processing-batches/${batchId}`;
    // console.log('[Next.js API] Fetching URL:', fetchURL);

    const response = await fetch(fetchURL, {
      method: 'GET',
      headers: {
        Cookie: `token=${token}`,
      },
      cache: 'no-store',
    });

    // console.log(`[Next.js API] Backend response status for batch ${batchId}:`, response.status);

    const data = await response.json();

    if (!response.ok) {
      // console.error(`[Next.js API] Backend error for batch ${batchId} (${response.status}):`, data);
      return new NextResponse(
        JSON.stringify({
          error: data.error || `Failed to fetch processing batch ${batchId} from backend. Status: ${response.status}`,
        }),
        { status: response.status }
      );
    }

    // console.log(`[Next.js API] Successfully fetched batch ${batchId} data from backend.`);
    return NextResponse.json(data, { status: response.status });
  } catch (error: any) {
    // console.error(`[Next.js API Catch block error] GET /api/processing-batches/${batchId}:`, error.message, error.stack);
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API proxy.' }), { status: 500 });
  }
}

```

### apps\web\app\api\procurements\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to create procurement',
        }),
        { status: response.status }
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement POST route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get('query') || '';
    const page = searchParams.get('page') || '1';
    const limit = searchParams.get('limit') || '10';

    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';
    const response = await fetch(`${backendUrl}/api/procurements?search=${query}&page=${page}&limit=${limit}`, {
      headers: {
        Cookie: `token=${token}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch procurement data');
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement API route:', error);
    return new NextResponse(JSON.stringify({ error: 'Failed to fetch procurement data' }), { status: 500 });
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const body = await request.json();
    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements/${params.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        Cookie: `token=${token}`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to update procurement',
        }),
        { status: response.status }
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('Error in procurement PUT route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const backendUrl = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

    const response = await fetch(`${backendUrl}/api/procurements/${params.id}`, {
      method: 'DELETE',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return new NextResponse(
        JSON.stringify({
          error: errorData.error || 'Failed to delete procurement',
        }),
        { status: response.status }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error in procurement DELETE route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
  }
}

```

### apps\web\app\api\procurements\unbatched\route.ts:
```
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

const BACKEND_URL = process.env.API_URL || 'http://localhost:5000';

export async function GET(request: Request) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      return new NextResponse(JSON.stringify({ error: 'Authentication required' }), { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    // crop and lotNo are expected query parameters by the backend
    // searchParams will already contain them from the frontend request.

    const response = await fetch(`${BACKEND_URL}/api/procurements/unbatched?${searchParams.toString()}`, {
      method: 'GET',
      headers: {
        Cookie: `token=${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return new NextResponse(
        JSON.stringify({ error: data.error || 'Failed to fetch unbatched procurements from backend' }),
        { status: response.status }
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error('Error in Next.js GET /api/procurements/unbatched route:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal server error in Next.js API' }), { status: 500 });
  }
}

```

### apps\web\app\api\uploadthing\route.ts:
```
import { createRouteHandler } from 'uploadthing/next';
import { ourFileRouter } from './core';

export const { GET, POST } = createRouteHandler({
  router: ourFileRouter,
  config: {
    logLevel: 'Info',
  },
});

```

### apps\web\app\api\uploadthing\core.ts:
```
import { createUploadthing, type FileRouter } from 'uploadthing/next';
import imageCompression from 'browser-image-compression';

async function compressFile(file: File): Promise<File> {
  if (file.type.startsWith('image/')) {
    const options = {
      maxSizeMB: 0.15,
      maxWidthOrHeight: 1200,
      useWebWorker: true,
    };

    try {
      return await imageCompression(file, options);
    } catch (error) {
      console.error('Error compressing image:', error);
      return file;
    }
  } else if (file.type === 'application/pdf') {
    if (file.size <= 150 * 1024) {
      return file;
    }

    console.warn('PDF compression not supported directly. PDF exceeds 150KB limit:', file.name);
    return file;
  }

  return file;
}

const f = createUploadthing({
  errorFormatter: err => {
    console.log('Error uploading file', err.message);
    console.log('- Above error caused this: ', err.cause);
    return {
      message: err.message,
    };
  },
});

export const ourFileRouter: FileRouter = {
  profilePicture: f({ image: { maxFileSize: '1024KB', maxFileCount: 1 } })
    .middleware(async ({ req, files }) => {
      console.log('Middleware running for profilePicture');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Profile picture upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  aadharDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for aadharDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Aadhar document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  bankDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for bankDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Bank document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),

  landDocument: f({
    image: { maxFileSize: '1024KB', maxFileCount: 1 },
    pdf: { maxFileSize: '1024KB', maxFileCount: 1 },
  })
    .middleware(async () => {
      console.log('Middleware running for landDocument');
      return { timestamp: Date.now() };
    })
    .onUploadComplete(async ({ file }) => {
      console.log('Land document upload complete', file.ufsUrl);
      return { url: file.ufsUrl };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;

```

### apps\web\app\hooks\use-debounce.ts:
```
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

```

### apps\web\app\hooks\use-local-storage.ts:
```
import * as React from 'react';

export function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = React.useState<T>(() => {
    try {
      if (typeof window === 'undefined') return initialValue;

      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Error reading localStorage key:', error);
      return initialValue;
    }
  });

  const setValue = (value: T) => {
    try {
      setStoredValue(value);
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(value));
      }
    } catch (error) {
      console.error('Error setting localStorage key:', error);
    }
  };

  return [storedValue, setValue];
}

```

### apps\web\app\(auth)\layout.tsx:
```
import type React from 'react';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { ThemeProvider } from '../providers/theme-provider';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Login - Acme Inc.',
  description: 'Login to your Acme Inc. account',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

```

### apps\web\app\(auth)\login\page.tsx:
```
import { LoginForm } from '@/app/components/login-form';

export default function LoginPage() {
  return (
    <div className="grid min-h-screen lg:grid-cols-2">
      <div className="flex flex-col gap-6 p-6 md:p-10 bg-background">
        <div className="flex justify-center gap-2 md:justify-start">
          <a href="#" className="flex items-center gap-2 font-medium text-primary hover:underline">
            <span className="text-lg font-semibold">Chaya Inc</span>
          </a>
        </div>

        <div className="flex flex-1 items-center justify-center">
          <div className="w-full max-w-sm">
            <LoginForm />
          </div>
        </div>
      </div>

      <div className="relative hidden lg:block bg-muted">
        {/* Add any background image or content here if needed */}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\layout.tsx:
```
'use client';

import React, { useEffect } from 'react';
import { ThemeProvider } from '@/app/providers/theme-provider';
import { AuthProvider, useAuth } from '@/app/providers/auth-provider';
import { SidebarProvider } from '@workspace/ui/components/sidebar';
import { AppSidebar } from '../components/layout/app-sidebar';
import { FarmersCacheProvider } from './farmers/context/farmer-cache-context';
import { useRouter, usePathname } from 'next/navigation'; // Import usePathname
import { motion } from 'framer-motion';
import { Toaster } from 'sonner';

// Content that requires authentication and role checks
function AuthenticatedContent({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    if (!loading && !user) {
      // This case should ideally be handled by middleware redirecting to /login
      // but as a fallback.
      router.push('/login');
      return;
    }

    if (!loading && user) {
      // Staff-specific redirections
      if (user.role === 'STAFF') {
        if (pathname.startsWith('/staff') || pathname.startsWith('/dashboard')) {
          router.push('/farmers'); // Default page for staff
        }
      }
      // Admin specific: can access anything in dashboard layout.
    }
  }, [user, loading, router, pathname]);

  // Render null or a loading indicator if still loading or if user is null and redirecting
  if (loading || (!user && pathname !== '/login')) {
    return <div className="flex h-screen w-screen items-center justify-center">Loading application...</div>;
  }

  // If user is STAFF and tries to access restricted pages, they would have been redirected.
  // So, if we reach here, they are allowed (or an Admin).
  if (user?.role === 'STAFF' && (pathname.startsWith('/staff') || pathname.startsWith('/dashboard'))) {
    return null; // Or a specific "Access Denied" component for staff
  }

  return (
    <div className="flex h-screen overflow-hidden bg-gray-100">
      <SidebarProvider>
        <AppSidebar className="h-screen" />
        <motion.div
          className="flex flex-col flex-1 overflow-hidden"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.3 }}
        >
          <div className="flex flex-1 flex-col p-4 overflow-auto">{children}</div>
        </motion.div>
      </SidebarProvider>
    </div>
  );
}

export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem disableTransitionOnChange>
      <AuthProvider>
        <FarmersCacheProvider>
          <AuthenticatedContent>{children}</AuthenticatedContent>
        </FarmersCacheProvider>
      </AuthProvider>
      <Toaster richColors closeButton />
    </ThemeProvider>
  );
}

```

### apps\web\app\(dashboard)\farmers\page.tsx:
```
import { Suspense } from 'react';
import FarmersHeader from './components/farmers-header';
import Search from './components/search';
import FarmersTable from './components/farmers-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { FarmersCacheProvider } from './context/farmer-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
  }>;
}

export default async function FarmersPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;

  return (
    <FarmersCacheProvider>
      <div className="space-y-6 p-4">
        <FarmersHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Enter farmer name, batch code, village" />
        </div>

        <Suspense key={query + currentPage.toString()} fallback={<Loading />}>
          <FarmersTableWithCache query={query} currentPage={currentPage} />
        </Suspense>
      </div>
    </FarmersCacheProvider>
  );
}

async function FarmersTableWithCache({ query, currentPage }: { query: string; currentPage: number }) {
  return (
    <>
      <FarmersTable query={query} currentPage={currentPage} />
      <PaginationWithCache query={query} />
    </>
  );
}

async function PaginationWithCache({ query }: { query: string }) {
  return <Pagination query={query} />;
}

```

### apps\web\app\(dashboard)\farmers\loading.tsx:
```
import { Skeleton } from '@workspace/ui/components/skeleton';

export default function Loading() {
  return (
    <div className="w-full">
      {/* Header skeleton */}
      <div className="flex items-center justify-between">
        <Skeleton className="h-8 w-64" />
        <div className="flex gap-2">
          <Skeleton className="h-9 w-32" />
          <Skeleton className="h-9 w-32" />
        </div>
      </div>

      {/* Search skeleton */}
      <div className="mt-6 flex items-center justify-between gap-2">
        <Skeleton className="h-10 w-96" />
        <Skeleton className="h-9 w-28" />
      </div>

      {/* Table skeleton */}
      <div className="mt-6 space-y-4">
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4">
            <div className="flex h-full items-center">
              {Array.from({ length: 6 }).map((_, i) => (
                <Skeleton key={i} className="h-4 w-40 mx-4" />
              ))}
            </div>
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4">
              <div className="flex items-center">
                {Array.from({ length: 6 }).map((_, j) => (
                  <Skeleton key={j} className="h-4 w-40 mx-4" />
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Pagination skeleton */}
      <div className="mt-8 flex items-center justify-center gap-1">
        <Skeleton className="h-9 w-9" />
        {Array.from({ length: 5 }).map((_, i) => (
          <Skeleton key={i} className="h-9 w-9 mx-1" />
        ))}
        <Skeleton className="h-9 w-9" />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-details-dialog.tsx:
```
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@workspace/ui/components/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@workspace/ui/components/tabs';
import { formatDate } from '../lib/utils';
import { ExternalLink } from 'lucide-react';
import { FarmerWithRelations } from '../lib/types';

interface FarmerDetailsDialogProps {
  farmer: FarmerWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function FarmerDetailsDialog({ farmer, open, onOpenChange }: FarmerDetailsDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>Farmer Details: {farmer.name}</DialogTitle>
        </DialogHeader>

        <Tabs defaultValue="personal" className="mt-4">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="personal">Personal Info</TabsTrigger>
            <TabsTrigger value="bank">Bank Details</TabsTrigger>
            <TabsTrigger value="documents">Documents</TabsTrigger>
          </TabsList>

          {/* Personal Information Tab */}
          <TabsContent value="personal" className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <InfoItem label="Survey Number" value={farmer.surveyNumber} />
              <InfoItem label="Name" value={farmer.name} />
              <InfoItem label="Gender" value={farmer.gender} />
              <InfoItem label="Relationship" value={farmer.relationship} />
              <InfoItem label="Community" value={farmer.community} />
              <InfoItem label="Aadhar Number" value={farmer.aadharNumber} />
              <InfoItem label="Date of Birth" value={formatDate(farmer.dateOfBirth)} />
              <InfoItem label="Age" value={farmer.age.toString()} />
              <InfoItem label="Contact Number" value={farmer.contactNumber} />
              <InfoItem label="State" value={farmer.state} />
              <InfoItem label="District" value={farmer.district} />
              <InfoItem label="Mandal" value={farmer.mandal} />
              <InfoItem label="Village" value={farmer.village} />
              <InfoItem label="Panchayath" value={farmer.panchayath} />
            </div>
          </TabsContent>

          {/* Bank Details Tab */}
          <TabsContent value="bank" className="space-y-4">
            {farmer.bankDetails ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <InfoItem label="Bank Name" value={farmer.bankDetails.bankName} />
                <InfoItem label="Branch Name" value={farmer.bankDetails.branchName} />
                <InfoItem label="IFSC Code" value={farmer.bankDetails.ifscCode} />
                <InfoItem label="Account Number" value={farmer.bankDetails.accountNumber} />
                <InfoItem label="Bank Code" value={farmer.bankDetails.bankCode} />
                <InfoItem label="Address" value={farmer.bankDetails.address} />
              </div>
            ) : (
              <p className="text-muted-foreground text-center py-4">No bank details available</p>
            )}
          </TabsContent>

          {/* Documents Tab */}
          <TabsContent value="documents" className="space-y-4">
            {farmer.documents ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <DocumentLink label="Profile Picture" url={farmer.documents.profilePicUrl} />
                <DocumentLink label="Aadhar Document" url={farmer.documents.aadharDocUrl} />
                <DocumentLink label="Bank Document" url={farmer.documents.bankDocUrl} />

                {farmer.fields && farmer.fields.length > 0 && (
                  <div className="col-span-2 mt-4">
                    <h3 className="text-lg font-medium mb-2">Field Documents</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {farmer.fields.map((field, index) => (
                        <DocumentLink
                          key={field.id}
                          label={`Field ${index + 1} Document`}
                          url={field.landDocumentUrl}
                        />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <p className="text-muted-foreground text-center py-4">No documents available</p>
            )}
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}

// Helper component for info items
function InfoItem({ label, value }: { label: string; value: string }) {
  return (
    <div className="space-y-1">
      <p className="text-sm font-medium text-muted-foreground">{label}</p>
      <p className="text-sm">{value || 'N/A'}</p>
    </div>
  );
}

// Helper component for document links
function DocumentLink({ label, url }: { label: string; url: string }) {
  if (!url) return null;

  return (
    <div className="space-y-1">
      <p className="text-sm font-medium text-muted-foreground">{label}</p>
      <a
        href={url}
        target="_blank"
        rel="noopener noreferrer"
        className="text-sm text-blue-600 hover:underline flex items-center gap-1"
      >
        View Document <ExternalLink className="h-3 w-3" />
      </a>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\search.tsx:
```
'use client';

import { useSearchParams, usePathname, useRouter } from 'next/navigation';
import { useDebouncedCallback } from 'use-debounce';
import { Input } from '@workspace/ui/components/input';
import { Search as SearchIcon } from 'lucide-react';

export default function Search({ placeholder = 'Search farmers...' }: { placeholder?: string }) {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  const handleSearch = useDebouncedCallback((term: string) => {
    const params = new URLSearchParams(searchParams);

    params.set('page', '1');

    if (term) {
      params.set('query', term);
    } else {
      params.delete('query');
    }

    replace(`${pathname}?${params.toString()}`);
  }, 300);

  return (
    <div className="relative w-full">
      <SearchIcon className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
      <Input
        type="text"
        placeholder={placeholder}
        onChange={e => handleSearch(e.target.value)}
        defaultValue={searchParams.get('query')?.toString()}
        className="pl-9"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmers-table.tsx:
```
'use client';

import {
  flexRender,
  getCoreRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getPaginationRowModel,
  useReactTable,
} from '@tanstack/react-table';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { columns, defaultVisibleColumns } from '../lib/columns';
import { ColumnFilter } from './column-filter';
import { useState, useEffect } from 'react';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { useAuth } from '@/app/providers/auth-provider';
import { FarmerContextMenu } from './farmer-context-menu';
import { FarmerDetailsDialog } from './farmer-details-dialog';
import { FarmerFormDialog } from './farmer-form-dialog';
import { bulkDeleteFarmers } from '../lib/actions';
import { Button } from '@workspace/ui/components/button';
import { RefreshCw, TrashIcon } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { toast } from 'sonner';
import { useFarmersCache } from '../context/farmer-cache-context';
import { FarmerWithRelations } from '../lib/types';

interface FarmersTableProps {
  query: string;
  currentPage: number;
}

export default function FarmersTable({ query, currentPage }: FarmersTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchFarmers, prefetchPages, refreshCurrentPage } = useFarmersCache();

  const [farmers, setFarmers] = useState<FarmerWithRelations[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [viewingFarmer, setViewingFarmer] = useState<FarmerWithRelations | null>(null);
  const [editingFarmer, setEditingFarmer] = useState<FarmerWithRelations | null>(null);
  const [showViewDialog, setShowViewDialog] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showBulkDeleteDialog, setShowBulkDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const [rowSelection, setRowSelection] = useState({});

  const [columnVisibility, setColumnVisibility] = useState(() => {
    const initialVisibility: Record<string, boolean> = {};
    defaultVisibleColumns.forEach(col => {
      initialVisibility[col] = true;
    });
    return initialVisibility;
  });

  const loadData = async () => {
    setLoading(true);
    try {
      const data = await fetchFarmers(currentPage, query);
      setFarmers(data);

      const pagesToPrefetch = [];
      if (currentPage > 1) pagesToPrefetch.push(currentPage - 1);
      if (currentPage < 100) pagesToPrefetch.push(currentPage + 1);
      if (pagesToPrefetch.length > 0) {
        prefetchPages(Math.min(...pagesToPrefetch), Math.max(...pagesToPrefetch), query);
      }
    } catch (error) {
      toast.error("Failed to fetch farmers' data. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    if (refreshing) return;

    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPage(currentPage, query);
      setFarmers(freshData);
      toast.success('Data refreshed successfully');
      setRowSelection({});
    } catch (error) {
      toast.error('Failed to refresh data. Please try again.');
    } finally {
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadData();
  }, [fetchFarmers, prefetchPages, currentPage, query]);

  const table = useReactTable({
    data: farmers,
    columns,
    state: {
      columnVisibility,
      rowSelection,
    },
    enableRowSelection: isAdmin,
    onRowSelectionChange: setRowSelection,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  const handleViewDetails = (farmer: FarmerWithRelations) => {
    setViewingFarmer(farmer);
    setShowViewDialog(true);
  };

  const handleEditFarmer = (farmer: FarmerWithRelations) => {
    if (isAdmin) {
      setEditingFarmer(farmer);
      setShowEditDialog(true);
    } else {
      toast.error('You do not have permission to edit farmers.');
    }
  };

  const handleBulkDelete = async () => {
    setIsDeleting(true);
    try {
      const selectedFarmerIds = Object.keys(rowSelection)
        .map(index => {
          const idx = parseInt(index);
          return idx >= 0 && idx < farmers.length && farmers[idx] ? farmers[idx].id : null;
        })
        .filter((id): id is number => id !== null);

      if (selectedFarmerIds.length === 0) {
        toast.error('No farmers selected for deletion.');
        setShowBulkDeleteDialog(false);
        return;
      }

      const result = await bulkDeleteFarmers(selectedFarmerIds);

      if (result.success) {
        toast.success('Farmers deleted successfully.');
        await handleRefresh();
      } else {
        toast.error('Failed to delete farmers. Please try again.');
      }

      setShowBulkDeleteDialog(false);
    } catch (error) {
      toast.error('Failed to delete farmers. An unexpected error occurred.');
    } finally {
      setIsDeleting(false);
    }
  };

  useEffect(() => {
    const handleViewFarmerEvent = (e: CustomEvent<{ farmer: FarmerWithRelations }>) => {
      handleViewDetails(e.detail.farmer);
    };
    const handleDataChangeEvent = () => {
      handleRefresh();
    };

    document.addEventListener('viewFarmer', handleViewFarmerEvent as EventListener);
    document.addEventListener('farmerDataChanged', handleDataChangeEvent as EventListener);

    return () => {
      document.removeEventListener('viewFarmer', handleViewFarmerEvent as EventListener);
      document.removeEventListener('farmerDataChanged', handleDataChangeEvent as EventListener);
    };
  }, [currentPage, query]);

  const selectedCount = Object.keys(rowSelection).length;

  if (loading && farmers.length === 0) {
    return (
      <div className="mt-6 space-y-4">
        <div className="flex justify-between items-center">
          <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
          <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4 flex items-center">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4 flex items-center">
              {Array.from({ length: 6 }).map((_, j) => (
                <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
              ))}
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-2">
          {isAdmin && selectedCount > 0 && (
            <div className="flex items-center gap-2">
              <span className="text-sm text-muted-foreground">{selectedCount} selected</span>
              <Button variant="destructive" size="sm" onClick={() => setShowBulkDeleteDialog(true)} className="h-8">
                <TrashIcon className="mr-2 h-4 w-4" />
                Delete Selected
              </Button>
            </div>
          )}

          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={refreshing || loading}
            className="h-8 ml-2"
          >
            <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
            {refreshing ? 'Refreshing...' : 'Refresh'}
          </Button>
        </div>
        <ColumnFilter table={table} />
      </div>
      <div className="rounded-md border overflow-x-auto">
        <ScrollArea className="h-[calc(100vh-350px)] w-full">
          <Table className="min-w-max">
            <TableHeader className="sticky top-0 bg-secondary">
              {table.getHeaderGroups().map(headerGroup => (
                <TableRow key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <TableHead key={header.id}>
                      {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                    </TableHead>
                  ))}
                </TableRow>
              ))}
            </TableHeader>
            <TableBody>
              {table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map(row => (
                  <FarmerContextMenu
                    key={row.id}
                    farmer={row.original}
                    onEdit={() => handleEditFarmer(row.original)}
                    isAdmin={isAdmin}
                  >
                    <TableRow
                      data-state={row.getIsSelected() && 'selected'}
                      onDoubleClick={() => handleViewDetails(row.original)}
                      className="cursor-pointer hover:bg-muted/50"
                    >
                      {row.getVisibleCells().map(cell => (
                        <TableCell key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</TableCell>
                      ))}
                    </TableRow>
                  </FarmerContextMenu>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={columns.length} className="h-24 text-center">
                    {loading || refreshing ? 'Loading...' : 'No farmers found.'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </ScrollArea>
      </div>

      {viewingFarmer && (
        <FarmerDetailsDialog farmer={viewingFarmer} open={showViewDialog} onOpenChange={setShowViewDialog} />
      )}

      {isAdmin && editingFarmer && (
        <FarmerFormDialog mode="edit" farmer={editingFarmer} open={showEditDialog} onOpenChange={setShowEditDialog} />
      )}

      <AlertDialog open={showBulkDeleteDialog} onOpenChange={setShowBulkDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete these farmers?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete {selectedCount} farmer records and all their
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-form-dialog.tsx:
```
'use client';

import { FarmerFormProvider } from '@/app/providers/farmer-form-provider';
import { FarmerWithRelations } from '../lib/types';
import { FarmerForm } from '@/app/components/farmer-form/farmer-form';
import { useEffect } from 'react';

interface FarmerFormDialogProps {
  mode: 'add' | 'edit';
  farmer?: FarmerWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function FarmerFormDialog({ mode, farmer, open, onOpenChange }: FarmerFormDialogProps) {
  const handleFormSuccess = () => {
    const dataChangedEvent = new CustomEvent('farmerDataChanged');
    document.dispatchEvent(dataChangedEvent);
  };

  useEffect(() => {
    const handleFormSubmitSuccess = () => {
      handleFormSuccess();
    };
    document.addEventListener('farmerFormSubmitSuccess', handleFormSubmitSuccess);
    return () => {
      document.removeEventListener('farmerFormSubmitSuccess', handleFormSubmitSuccess);
    };
  }, []);

  return (
    <FarmerFormProvider initialData={farmer} mode={mode}>
      <FarmerForm mode={mode} open={open} onOpenChange={onOpenChange} farmerId={farmer?.id} />
    </FarmerFormProvider>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\pagination.tsx:
```
'use client';

import Link from 'next/link';
import { usePathname, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { generatePagination } from '../lib/utils';
import clsx from 'clsx';
import { useEffect, useState } from 'react';
import { useFarmersCache } from '../context/farmer-cache-context';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
}

export default function Pagination({ query }: PaginationProps) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const currentPage = Number(searchParams.get('page') || 1);
  const { fetchTotalPages } = useFarmersCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query]);

  const allPages = generatePagination(currentPage, totalPages);

  const createPageURL = (pageNumber: string | number) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `${pathname}?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-center gap-1 mt-8">
      <Button
        variant="outline"
        size="icon"
        className={clsx(currentPage <= 1 && 'opacity-50 cursor-not-allowed')}
        disabled={currentPage <= 1}
        asChild={currentPage > 1}
      >
        {currentPage > 1 ? (
          <Link href={createPageURL(currentPage - 1)}>
            <ChevronLeft className="h-4 w-4" />
          </Link>
        ) : (
          <span>
            <ChevronLeft className="h-4 w-4" />
          </span>
        )}
      </Button>

      <div className="flex gap-1">
        {allPages.map((page, index) => {
          if (page === '...') {
            return (
              <Button key={`ellipsis-${index}`} variant="outline" size="icon" disabled className="cursor-default">
                ...
              </Button>
            );
          }

          const isCurrentPage = page === currentPage;

          return (
            <Button
              key={`page-${page}`}
              variant={isCurrentPage ? 'default' : 'outline'}
              size="icon"
              asChild={!isCurrentPage}
              className={clsx('h-9 w-9')}
            >
              {isCurrentPage ? <span>{page}</span> : <Link href={createPageURL(page)}>{page}</Link>}
            </Button>
          );
        })}
      </div>

      <Button
        variant="outline"
        size="icon"
        className={clsx(currentPage >= totalPages && 'opacity-50 cursor-not-allowed')}
        disabled={currentPage >= totalPages}
        asChild={currentPage < totalPages}
      >
        {currentPage < totalPages ? (
          <Link href={createPageURL(currentPage + 1)}>
            <ChevronRight className="h-4 w-4" />
          </Link>
        ) : (
          <span>
            <ChevronRight className="h-4 w-4" />
          </span>
        )}
      </Button>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\column-filter.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { SlidersHorizontal } from 'lucide-react';
import { Table } from '@tanstack/react-table';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-9">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          Columns
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[200px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => column.getCanHide() && column.id !== 'select')
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id.replace(/([A-Z])/g, ' $1').toLowerCase()}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmer-context-menu.tsx:
```
'use client';

import React, { useState } from 'react';
import { Farmer } from '@chaya/shared';
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuSeparator,
  ContextMenuTrigger,
} from '@workspace/ui/components/context-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Eye, Pencil, Trash2 } from 'lucide-react';
import { deleteFarmer } from '../lib/actions';
import { toast } from 'sonner';

interface FarmerContextMenuProps {
  children: React.ReactNode;
  farmer: Farmer;
  onEdit: () => void;
  isAdmin: boolean;
}

export function FarmerContextMenu({ children, farmer, onEdit, isAdmin }: FarmerContextMenuProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    try {
      setIsDeleting(true);
      const result = await deleteFarmer(farmer.id);

      if (result.success) {
        toast.success('Farmer deleted', {
          description: `${farmer.name} has been successfully deleted.`,
        });

        const dataChangedEvent = new CustomEvent('farmerDataChanged');
        document.dispatchEvent(dataChangedEvent);
      } else {
        toast.error('Error', {
          description: result.error || 'Failed to delete farmer.',
        });
      }

      setShowDeleteDialog(false);
    } catch (error) {
      toast.error('Error', {
        description: 'An unexpected error occurred while deleting the farmer.',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <ContextMenu>
        <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>
        <ContextMenuContent className="w-48">
          <ContextMenuItem onClick={() => window.open(`/dashboard/farmers/${farmer.id}`, '_blank')}>
            <Eye className="mr-2 h-4 w-4" />
            View Details
          </ContextMenuItem>

          {isAdmin && (
            <>
              <ContextMenuSeparator />
              <ContextMenuItem onClick={onEdit}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit Farmer
              </ContextMenuItem>
              <ContextMenuItem
                onClick={() => setShowDeleteDialog(true)}
                className="text-destructive focus:text-destructive"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete Farmer
              </ContextMenuItem>
            </>
          )}
        </ContextMenuContent>
      </ContextMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete this farmer?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the farmer record and all associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

### apps\web\app\(dashboard)\farmers\components\farmers-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useState } from 'react';
import { FarmerFormDialog } from './farmer-form-dialog';
import { useAuth } from '@/app/providers/auth-provider';

export default function FarmersHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';

  const [showAddDialog, setShowAddDialog] = useState(false);

  const handleExport = () => {
    console.log('Export data clicked');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Farmer Dashboard</h1>
        <p className="text-gray-600">Manage and track farmer information</p>
      </div>

      <div className="flex items-center gap-2">
        {/* {isAdmin && (
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            className="h-9 bg-purple-500 text-white hover:bg-purple-600 hover:text-white"
          >
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )} */}

        <Button
          size="sm"
          onClick={() => setShowAddDialog(true)}
          className="h-9 bg-green-500 text-white hover:bg-green-600"
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Farmer
        </Button>

        <FarmerFormDialog mode="add" open={showAddDialog} onOpenChange={setShowAddDialog} />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\farmers\lib\actions.ts:
```
'use server';

import { revalidatePath } from 'next/cache';
import { Gender, Relationship, prisma } from '@chaya/shared';
import { ITEMS_PER_PAGE } from './constants';

interface FarmerFormData {
  surveyNumber: string;
  name: string;
  relationship: Relationship;
  gender: Gender;
  community: string;
  aadharNumber: string;
  state: string;
  district: string;
  mandal: string;
  village: string;
  panchayath: string;
  dateOfBirth: string;
  age: number;
  contactNumber: string;
  bankDetails?: {
    ifscCode: string;
    bankName: string;
    branchName: string;
    accountNumber: string;
    address: string;
    bankCode: string;
  };
  documents?: {
    profilePicUrl: string;
    aadharDocUrl: string;
    bankDocUrl: string;
  };
  fields?: {
    areaHa: number;
    yieldEstimate: number;
    location: Record<string, any>;
    landDocumentUrl: string;
  }[];
}

export async function createFarmer(userId: number, formData: FarmerFormData) {
  try {
    const { bankDetails, documents, fields, ...farmerData } = formData;
    const dateOfBirth = new Date(farmerData.dateOfBirth);

    await prisma.farmer.create({
      data: {
        ...farmerData,
        dateOfBirth,
        createdById: userId,
        updatedById: userId,
        ...(bankDetails && {
          bankDetails: {
            create: bankDetails,
          },
        }),
        ...(documents && {
          documents: {
            create: documents,
          },
        }),
        ...(fields && {
          fields: {
            create: fields,
          },
        }),
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to create farmer:', error);
    return { error: 'Failed to create farmer. Please try again.' };
  }
}

export async function updateFarmer(userId: number, farmerId: number, formData: Partial<FarmerFormData>) {
  try {
    const { bankDetails, documents, fields, ...farmerData } = formData;
    const dateOfBirth = farmerData.dateOfBirth ? new Date(farmerData.dateOfBirth) : undefined;

    await prisma.farmer.update({
      where: { id: farmerId },
      data: {
        ...farmerData,
        ...(dateOfBirth && { dateOfBirth }),
        updatedById: userId,
        ...(bankDetails && {
          bankDetails: {
            upsert: {
              create: bankDetails,
              update: bankDetails,
            },
          },
        }),
        ...(documents && {
          documents: {
            upsert: {
              create: documents,
              update: documents,
            },
          },
        }),
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to update farmer:', error);
    return { error: 'Failed to update farmer. Please try again.' };
  }
}

export async function deleteFarmer(farmerId: number) {
  try {
    await prisma.farmer.delete({
      where: { id: farmerId },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to delete farmer:', error);
    return { error: 'Failed to delete farmer. Please try again.' };
  }
}

export async function bulkDeleteFarmers(farmerIds: number[]) {
  try {
    await prisma.farmer.deleteMany({
      where: {
        id: { in: farmerIds },
      },
    });

    revalidatePath('/dashboard/farmers');
    return { success: true };
  } catch (error) {
    console.error('Failed to delete farmers:', error);
    return { error: 'Failed to delete farmers. Please try again.' };
  }
}

export async function exportFarmersData(query?: string) {
  try {
    const farmers = await prisma.farmer.findMany({
      where: query
        ? {
            OR: [
              { name: { contains: query, mode: 'insensitive' } },
              { aadharNumber: { contains: query, mode: 'insensitive' } },
              { surveyNumber: { contains: query, mode: 'insensitive' } },
            ],
          }
        : undefined,
      include: {
        bankDetails: true,
        fields: true,
      },
    });

    return {
      success: true,
      count: farmers.length,
      downloadUrl: `/api/export/farmers?timestamp=${Date.now()}`,
    };
  } catch (error) {
    console.error('Failed to export farmers data:', error);
    return { error: 'Failed to export farmers data. Please try again.' };
  }
}
//SelectedColumns is not used in the function, but it's included in the function signature for future use just adding for reference
export async function getFarmers({
  query = '',
  page = 1,
}: {
  query?: string;
  page?: number;
  selectedColumns?: string[];
}) {
  const offset = (page - 1) * ITEMS_PER_PAGE;

  try {
    const farmers = await prisma.farmer.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
      include: {
        bankDetails: true,
        documents: true,
        fields: true,
        createdBy: {
          select: {
            name: true,
          },
        },
      },
      take: ITEMS_PER_PAGE,
      skip: offset,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return farmers;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch farmers.');
  }
}

export async function getFarmerPages(query: string) {
  try {
    const count = await prisma.farmer.count({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
    });

    const totalPages = Math.ceil(count / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch total number of farmers.');
  }
}

```

### apps\web\app\(dashboard)\farmers\lib\data.ts:
```
import { prisma } from '@chaya/shared';

export const ITEMS_PER_PAGE = 10;

import { FarmerWithRelations } from './types';
//selectedColumns is not used in the function, but it is included in the function signature for future use
export async function getFarmers({
  query = '',
  page = 1,
}: {
  query?: string;
  page?: number;
  selectedColumns?: string[];
}): Promise<FarmerWithRelations[]> {
  const offset = (page - 1) * ITEMS_PER_PAGE;

  try {
    const farmers = await prisma.farmer.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
      include: {
        bankDetails: true,
        documents: true,
        fields: true,
        createdBy: {
          select: {
            name: true,
          },
        },
      },
      take: ITEMS_PER_PAGE,
      skip: offset,
      orderBy: {
        createdAt: 'desc',
      },
    });

    return farmers as FarmerWithRelations[];
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch farmers.');
  }
}
// Count total farmers matching the query

export async function getFarmerPages(query: string) {
  try {
    const count = await prisma.farmer.count({
      where: {
        OR: [
          { name: { contains: query, mode: 'insensitive' } },
          { aadharNumber: { contains: query, mode: 'insensitive' } },
          { surveyNumber: { contains: query, mode: 'insensitive' } },
          { contactNumber: { contains: query, mode: 'insensitive' } },
          { village: { contains: query, mode: 'insensitive' } },
          { district: { contains: query, mode: 'insensitive' } },
        ],
      },
    });

    const totalPages = Math.ceil(count / ITEMS_PER_PAGE);
    return totalPages;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch total number of farmers.');
  }
}

```

### apps\web\app\(dashboard)\farmers\lib\types.ts:
```
import { Farmer, BankDetails, FarmerDocuments, Field, User } from '@chaya/shared';

export interface FarmerWithRelations extends Farmer {
  bankDetails?: BankDetails | null;
  documents?: FarmerDocuments | null;
  fields?: Field[];
  createdBy?: Pick<User, 'name'>;
}

```

### apps\web\app\(dashboard)\farmers\lib\columns.tsx:
```
import { ColumnDef } from '@tanstack/react-table';
import { Checkbox } from '@workspace/ui/components/checkbox';
import { Button } from '@workspace/ui/components/button';
import { formatDate } from './utils';
import { Farmer } from '@chaya/shared';
import { Eye, FileUser } from 'lucide-react';

export const columns: ColumnDef<Farmer>[] = [
  {
    id: 'select',
    header: ({ table }) => {
      return (
        <Checkbox
          checked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && 'indeterminate')}
          onCheckedChange={value => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
        />
      );
    },
    cell: ({ row }) => {
      return (
        <Checkbox
          checked={row.getIsSelected()}
          onCheckedChange={value => row.toggleSelected(!!value)}
          aria-label="Select row"
        />
      );
    },
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: 'surveyNumber',
    header: 'Survey Number',
    cell: ({ row }) => <div>{row.getValue('surveyNumber')}</div>,
  },
  {
    accessorKey: 'name',
    header: 'Name',
    cell: ({ row }) => <div>{row.getValue('name')}</div>,
  },
  {
    accessorKey: 'gender',
    header: 'Gender',
    cell: ({ row }) => <div>{row.getValue('gender')}</div>,
  },
  {
    accessorKey: 'age',
    header: 'Age',
    cell: ({ row }) => <div>{row.getValue('age')}</div>,
  },
  {
    accessorKey: 'contactNumber',
    header: 'Contact',
    cell: ({ row }) => <div>{row.getValue('contactNumber')}</div>,
  },
  {
    accessorKey: 'aadharNumber',
    header: 'Aadhar Number',
    cell: ({ row }) => <div>{row.getValue('aadharNumber')}</div>,
  },
  {
    accessorKey: 'village',
    header: 'Village',
    cell: ({ row }) => <div>{row.getValue('village')}</div>,
  },
  {
    accessorKey: 'district',
    header: 'District',
    cell: ({ row }) => <div>{row.getValue('district')}</div>,
  },
  {
    accessorKey: 'state',
    header: 'State',
    cell: ({ row }) => <div>{row.getValue('state')}</div>,
  },
  {
    accessorKey: 'createdAt',
    header: 'Created At',
    cell: ({ row }) => <div>{formatDate(row.getValue('createdAt'))}</div>,
  },
  {
    id: 'actions',
    header: 'Documents',
    cell: ({ row }) => {
      const farmer = row.original;
      return (
        <div className="flex items-center justify-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0"
            onClick={e => {
              e.stopPropagation();
              const viewFarmerEvent = new CustomEvent('viewFarmer', {
                detail: { farmer },
              });
              document.dispatchEvent(viewFarmerEvent);
            }}
          >
            <span className="sr-only">View details</span>
            <FileUser className="h-4 w-4" />
          </Button>
        </div>
      );
    },
  },
];

export const defaultVisibleColumns = [
  'select',
  'surveyNumber',
  'name',
  'aadharNumber',
  'village',
  'district',
  'actions',
];

```

### apps\web\app\(dashboard)\farmers\lib\utils.ts:
```
import { Gender, Relationship } from '@prisma/client';

/**
 * Format a date object or string to a localized date string
 */
export function formatDate(date: Date | string): string {
  if (!date) return '';

  const d = typeof date === 'string' ? new Date(date) : date;

  return d.toLocaleDateString('en-IN', {
    day: 'numeric',
    month: 'short',
    year: 'numeric',
  });
}

/**
 * Generate pagination array for rendering page numbers
 */
export const generatePagination = (currentPage: number, totalPages: number) => {
  // If the total number of pages is 7 or less,
  // display all pages without any ellipsis
  if (totalPages <= 7) {
    return Array.from({ length: totalPages }, (_, i) => i + 1);
  }

  // If the current page is among the first 3 pages,
  // show the first 3, an ellipsis, and the last 2 pages
  if (currentPage <= 3) {
    return [1, 2, 3, '...', totalPages - 1, totalPages];
  }

  // If the current page is among the last 3 pages,
  // show the first 2, an ellipsis, and the last 3 pages
  if (currentPage >= totalPages - 2) {
    return [1, 2, '...', totalPages - 2, totalPages - 1, totalPages];
  }

  // If the current page is somewhere in the middle,
  // show the first page, an ellipsis, the current page and its neighbors,
  // another ellipsis, and the last page
  return [1, '...', currentPage - 1, currentPage, currentPage + 1, '...', totalPages];
};
export interface FarmerFormData {
  surveyNumber: string;
  name: string;
  relationship: Relationship;
  gender: Gender;
  community: string;
  aadharNumber: string;
  state: string;
  district: string;
  mandal: string;
  village: string;
  panchayath: string;
  dateOfBirth: string;
  age: number;
  contactNumber: string;
  bankDetails?: {
    ifscCode: string;
    bankName: string;
    branchName: string;
    accountNumber: string;
    address: string;
    bankCode: string;
  };
  documents?: {
    profilePicUrl: string;
    aadharDocUrl: string;
    bankDocUrl: string;
  };
  fields?: {
    areaHa: number;
    yieldEstimate: number;
    location: Record<string, object>;
    landDocumentUrl: string;
  }[];
}

```

### apps\web\app\(dashboard)\farmers\lib\constants.ts:
```
export const ITEMS_PER_PAGE = 10;

```

### apps\web\app\(dashboard)\farmers\lib\sidebar-cache.ts:
```
'use client';

import React from 'react';

const SIDEBAR_DATA_KEY = 'app_sidebar_data';
const SIDEBAR_TIMESTAMP_KEY = 'app_sidebar_timestamp';
const CACHE_TTL = 3600000; // 1 hour in milliseconds

export interface SidebarCacheItem {
  data: object;
  timestamp: number;
}

// Helper to check if we're in the browser
const isBrowser = typeof window !== 'undefined';

// Get sidebar data from cache
export function getSidebarCache<T>(): T | null {
  if (!isBrowser) return null;

  try {
    const cachedData = localStorage.getItem(SIDEBAR_DATA_KEY);
    const timestamp = localStorage.getItem(SIDEBAR_TIMESTAMP_KEY);

    if (!cachedData || !timestamp) return null;

    const parsedTimestamp = parseInt(timestamp);
    const now = Date.now();

    // Check if cache is still valid
    if (now - parsedTimestamp > CACHE_TTL) {
      clearSidebarCache();
      return null;
    }

    return JSON.parse(cachedData) as T;
  } catch (error) {
    console.error('Error reading sidebar cache:', error);
    return null;
  }
}

// Set sidebar data to cache
export function setSidebarCache<T>(data: T): void {
  if (!isBrowser) return;

  try {
    localStorage.setItem(SIDEBAR_DATA_KEY, JSON.stringify(data));
    localStorage.setItem(SIDEBAR_TIMESTAMP_KEY, Date.now().toString());
  } catch (error) {
    console.error('Error setting sidebar cache:', error);
  }
}

// Clear sidebar cache (used on logout)
export function clearSidebarCache(): void {
  if (!isBrowser) return;

  try {
    localStorage.removeItem(SIDEBAR_DATA_KEY);
    localStorage.removeItem(SIDEBAR_TIMESTAMP_KEY);
  } catch (error) {
    console.error('Error clearing sidebar cache:', error);
  }
}

// Custom hook for sidebar cache
export function useSidebarCache<T>(fetchFn: () => Promise<T>) {
  const [data, setData] = React.useState<T | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<Error | null>(null);

  React.useEffect(() => {
    async function loadData() {
      setLoading(true);

      try {
        // Try to get data from cache first
        const cachedData = getSidebarCache<T>();

        if (cachedData) {
          setData(cachedData);
          setLoading(false);
          return;
        }

        // If no cache, fetch fresh data
        const freshData = await fetchFn();
        setData(freshData);

        // Cache the new data
        setSidebarCache(freshData);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('An error occurred'));
      } finally {
        setLoading(false);
      }
    }

    loadData();
  }, [fetchFn]);

  return { data, loading, error };
}

```

### apps\web\app\(dashboard)\farmers\context\farmer-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import { getFarmers, getFarmerPages } from '../lib/actions';
import { FarmerWithRelations } from '../lib/types';
import { toast } from 'sonner';

interface FarmersCacheContextType {
  farmers: Record<string, FarmerWithRelations[]>;
  totalPages: Record<string, number>;
  fetchFarmers: (page: number, query: string) => Promise<FarmerWithRelations[]>;
  fetchTotalPages: (query: string) => Promise<number>;
  clearCache: () => void;
  prefetchPages: (startPage: number, endPage: number, query: string) => Promise<void>;
  refreshCurrentPage: (page: number, query: string) => Promise<FarmerWithRelations[]>;
}

const FarmersCacheContext = createContext<FarmersCacheContextType | undefined>(undefined);

export function FarmersCacheProvider({ children }: { children: React.ReactNode }) {
  const [farmers, setFarmers] = useState<Record<string, FarmerWithRelations[]>>({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});

  const createKey = useCallback((page: number, query: string) => `${query}:${page}`, []);

  const fetchFarmers = useCallback(
    async (page: number, query: string): Promise<FarmerWithRelations[]> => {
      const key = createKey(page, query);

      if (farmers[key]) {
        console.log(`Using cached data for page ${page}, query "${query}"`);
        return farmers[key];
      }

      console.log(`Fetching page ${page}, query "${query}" from server`);
      try {
        const data = (await getFarmers({ page, query })) as FarmerWithRelations[];
        setFarmers(prev => ({
          ...prev,
          [key]: data,
        }));
        return data;
      } catch (error) {
        toast.error('Failed to fetch farmers data from server.');
        throw error;
      }
    },
    [farmers, createKey]
  );

  const fetchTotalPages = useCallback(
    async (query: string): Promise<number> => {
      if (totalPages[query] !== undefined) {
        return totalPages[query];
      }

      try {
        const pages = await getFarmerPages(query);
        setTotalPages(prev => ({
          ...prev,
          [query]: pages,
        }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        throw error;
      }
    },
    [totalPages]
  );

  const prefetchPages = useCallback(
    async (startPage: number, endPage: number, query: string) => {
      console.log(`Prefetching pages ${startPage}-${endPage} for query "${query}"`);

      for (let page = startPage; page <= endPage; page++) {
        const key = createKey(page, query);

        if (farmers[key]) continue;

        try {
          const data = (await getFarmers({
            page,
            query,
          })) as FarmerWithRelations[];
          setFarmers(prev => ({
            ...prev,
            [key]: data,
          }));
        } catch (error) {
          console.error(`Error prefetching page ${page}:`, error);
          toast.error(`Failed to prefetch data for page ${page}.`);
        }
      }
    },
    [farmers, createKey]
  );

  const refreshCurrentPage = useCallback(
    async (page: number, query: string): Promise<FarmerWithRelations[]> => {
      const key = createKey(page, query);

      console.log(`Force refreshing page ${page}, query "${query}" from server`);
      try {
        const data = (await getFarmers({
          page,
          query,
        })) as FarmerWithRelations[];
        setFarmers(prev => ({
          ...prev,
          [key]: data,
        }));
        fetchTotalPages(query);
        return data;
      } catch (error) {
        console.error(`Error refreshing page ${page}:`, error);
        toast.error(`Failed to refresh data for page ${page}.`);
        throw error;
      }
    },
    [createKey, fetchTotalPages]
  );

  const clearCache = useCallback(() => {
    setFarmers({});
    setTotalPages({});
    toast.success('Cache cleared successfully.');
  }, []);

  const value = {
    farmers,
    totalPages,
    fetchFarmers,
    fetchTotalPages,
    clearCache,
    prefetchPages,
    refreshCurrentPage,
  };

  return <FarmersCacheContext.Provider value={value}>{children}</FarmersCacheContext.Provider>;
}

export function useFarmersCache() {
  const context = useContext(FarmersCacheContext);

  if (context === undefined) {
    throw new Error('useFarmersCache must be used within a FarmersCacheProvider');
  }

  return context;
}

```

### apps\web\app\(dashboard)\dashboard\page.tsx:
```
'use client';

import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell, Legend } from 'recharts';

const lineGraphData = [
  { name: 'Sep', value: 80 },
  { name: 'Oct', value: 100 },
  { name: 'Nov', value: 108 },
  { name: 'Dec', value: 95 },
  { name: 'Jan', value: 90 },
  { name: 'Feb', value: 92 },
];

const pieChartData = [
  { name: 'Ginger', value: 15 },
  { name: 'Coffee', value: 30 },
  { name: 'Turmeric', value: 25 },
  { name: 'Your Files', value: 63 },
];

const COLORS = ['#FFB703', '#FB8500', '#219EBC', '#8ECAE6'];

export default function DashboardPage() {
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="space-y-2">
        <h1 className="text-2xl font-semibold">Farmer Details</h1>
        <p className="text-gray-600">Manage and track crop procurement information</p>
      </div>

      {/* Analytics Section */}
      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        {/* Procurement Section */}
        <div className="p-4 bg-white rounded shadow">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-bold">Procurement</h2>
            <button className="text-sm text-gray-500 hover:underline">Month</button>
          </div>
          <p className="text-2xl font-bold text-green-600">2000.00 kg</p>
          <div className="mt-4">
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={lineGraphData}>
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="value" stroke="#4CAF50" strokeWidth={2} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Crop Section */}
        <div className="p-4 bg-white rounded shadow">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-bold">Crop</h2>
            <button className="text-sm text-gray-500 hover:underline">Month</button>
          </div>
          <div className="mt-4">
            <ResponsiveContainer width="100%" height={200}>
              <PieChart>
                <Pie
                  data={pieChartData}
                  dataKey="value"
                  nameKey="name"
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#8884d8"
                >
                  {pieChartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Legend />
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Top Performing Staff Section */}
      <div className="p-4 bg-white rounded shadow">
        <h2 className="text-lg font-bold">Top Performing Staff</h2>
        {/* Table remains unchanged */}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\page.tsx:
```
import { Suspense } from 'react';
import ProcessingBatchesHeader from './components/processing-batches-header';
import Search from './components/search';
import ProcessingBatchesTable from './components/processing-batches-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { ProcessingBatchCacheProvider } from './context/processing-batch-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
    status?: string; // For filtering by latest stage status
  }>;
}

export default async function ProcessingBatchesPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;
  const status = params?.status || '';

  return (
    <ProcessingBatchCacheProvider>
      <div className="space-y-6 p-4">
        <ProcessingBatchesHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Search by Batch Code, Crop..." />
        </div>
        <Suspense key={query + currentPage.toString() + status} fallback={<Loading />}>
          <ProcessingBatchesTable query={query} currentPage={currentPage} statusFilter={status} />
          <Pagination query={query} statusFilter={status} />
        </Suspense>
      </div>
    </ProcessingBatchCacheProvider>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\loading.tsx:
```
export default function Loading() {
  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
        <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
      </div>
      <div className="rounded-md border">
        <div className="h-12 border-b bg-secondary px-4 flex items-center">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
          ))}
        </div>
        {Array.from({ length: 10 }).map((_, i) => (
          <div key={i} className="border-b px-4 py-4 flex items-center">
            {Array.from({ length: 6 }).map((_, j) => (
              <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\search.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Input } from '@workspace/ui/components/input';
import { useEffect, useState } from 'react';
import { useDebounce } from '@/app/hooks/use-debounce';

interface SearchProps {
  placeholder?: string;
}

export default function Search({ placeholder }: SearchProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [searchTerm, setSearchTerm] = useState(searchParams.get('query') || '');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    const params = new URLSearchParams(searchParams);

    if (debouncedSearchTerm) {
      params.set('query', debouncedSearchTerm);
    } else {
      params.delete('query');
    }

    params.set('page', '1');
    router.push(`?${params.toString()}`);
  }, [debouncedSearchTerm, router, searchParams]);

  return (
    <div className="relative w-full md:w-80">
      <Input
        placeholder={placeholder || 'Search...'}
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        className="w-full"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\processing-batches-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';

export default function ProcessingBatchesHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const router = useRouter();

  const handleExport = () => {
    // TODO: Implement export functionality for processing batches
    console.log('Export processing batches data clicked');
    toast.info('Export functionality for processing batches is not yet implemented.');
  };

  const handleAddBatch = () => {
    router.push('/processing-batches/add');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Processing Batches</h1>
        <p className="text-gray-600">Manage and track multi-stage crop processing batches.</p>
      </div>

      <div className="flex items-center gap-2">
        {isAdmin && (
          <Button variant="outline" size="sm" onClick={handleExport} className="h-9">
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )}
        <Button size="sm" onClick={handleAddBatch} className="h-9 bg-green-500 text-white hover:bg-green-600">
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Processing Batch
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\pagination.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { useProcessingBatchCache } from '../context/processing-batch-cache-context';
import { useEffect, useState } from 'react';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
  statusFilter: string;
}

export default function Pagination({ query, statusFilter }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { fetchTotalPages } = useProcessingBatchCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  const currentPage = Number(searchParams.get('page') || '1');

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query, statusFilter);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query, statusFilter]);

  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-between px-2 mt-4">
      <div className="text-sm text-muted-foreground">
        Page {currentPage} of {totalPages}
      </div>
      <div className="flex items-center space-x-2">
        <Button variant="outline" size="icon" onClick={() => router.push(createPageURL(1))} disabled={currentPage <= 1}>
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage - 1))}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage + 1))}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(totalPages))}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\column-filter.tsx:
```
'use client';

import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { Button } from '@workspace/ui/components/button';
import { SlidersHorizontal } from 'lucide-react';
import type { Table } from '@tanstack/react-table';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-8">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          View
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[180px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => typeof column.accessorFn !== 'undefined' && column.getCanHide())
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\processing-batches-table.tsx:
```
'use client';

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  ColumnFiltersState,
  getFilteredRowModel,
  SortingState,
  getSortedRowModel,
} from '@tanstack/react-table';
import { batchColumns, defaultVisibleBatchColumns } from '../lib/columns-batch';
import type { ProcessingBatchWithSummary } from '../lib/types';
import { useProcessingBatchCache } from '../context/processing-batch-cache-context';

import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Button } from '@workspace/ui/components/button';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { toast } from 'sonner';
import { RefreshCw, Eye, Wind, CheckSquare, ShoppingCart, Layers, Trash2, ArrowUpDown } from 'lucide-react';
import { useAuth } from '@/app/providers/auth-provider';
import { ColumnFilter } from './column-filter';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import axios from 'axios';

// Import Dialogs
import { BatchDetailsDialog } from './dialogs/batch-details-dialog'; // Ensure this is correctly imported
import { AddDryingDialog } from './dialogs/add-drying-dialog';
import { FinalizeStageDialog } from './dialogs/finalize-stage-dialog';
import { StartNextStageDialog } from './dialogs/start-next-stage-dialog';
import { RecordSaleDialog } from './dialogs/record-sale-dialog';
import { Skeleton } from '@workspace/ui/components/skeleton';

interface ProcessingBatchesTableProps {
  query: string;
  currentPage: number;
  statusFilter: string;
}

export default function ProcessingBatchesTable({ query, currentPage, statusFilter }: ProcessingBatchesTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchProcessingBatchesSummary, refreshCurrentPageSummary, clearBatchDetailCache } = useProcessingBatchCache();

  const [records, setRecords] = useState<ProcessingBatchWithSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [sorting, setSorting] = React.useState<SortingState>([{ id: 'createdAt', desc: true }]);
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);

  const [columnVisibility, setColumnVisibility] = useState(() => {
    const initialVisibility: Record<string, boolean> = {};
    defaultVisibleBatchColumns.forEach(colId => {
      // Use imported default columns
      initialVisibility[colId] = true;
    });
    // Ensure all columns from batchColumns are in visibility state
    batchColumns.forEach(col => {
      if (col.id && initialVisibility[col.id] === undefined && col.enableHiding !== false) {
        initialVisibility[col.id] = true; // Default to visible if not in defaultVisible and hideable
      }
    });
    return initialVisibility;
  });

  const [selectedBatchForAction, setSelectedBatchForAction] = useState<ProcessingBatchWithSummary | null>(null);
  const [showDetailsDialog, setShowDetailsDialog] = useState(false); // This controls the BatchDetailsDialog
  const [showAddDryingDialog, setShowAddDryingDialog] = useState(false);
  const [showFinalizeStageDialog, setShowFinalizeStageDialog] = useState(false);
  const [showStartNextStageDialog, setShowStartNextStageDialog] = useState(false);
  const [showRecordSaleDialog, setShowRecordSaleDialog] = useState(false);
  const [showDeleteBatchDialog, setShowDeleteBatchDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const fetchData = useCallback(
    async (page: number, q: string, status: string) => {
      setLoading(true);
      try {
        const data = await fetchProcessingBatchesSummary(page, q, status);
        setRecords(data);
      } catch (error) {
        toast.error('Failed to load processing batches.');
      } finally {
        setLoading(false);
      }
    },
    [fetchProcessingBatchesSummary]
  );

  const handleRefresh = useCallback(async () => {
    if (refreshing) return;
    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPageSummary(currentPage, query, statusFilter);
      setRecords(freshData);
      toast.success('Data refreshed successfully');
      if (selectedBatchForAction) {
        // When refreshing, if a detail dialog *might* be open for this batch,
        // its data could be stale. Clearing its specific cache forces a re-fetch
        // if the dialog is opened again or if it re-fetches on open.
        clearBatchDetailCache(selectedBatchForAction.id);
      }
    } catch (error) {
      toast.error('Failed to refresh data.');
    } finally {
      setRefreshing(false);
    }
  }, [
    refreshing,
    currentPage,
    query,
    statusFilter,
    refreshCurrentPageSummary,
    selectedBatchForAction, // Dependency for clearBatchDetailCache
    clearBatchDetailCache,
  ]);

  useEffect(() => {
    fetchData(currentPage, query, statusFilter);
  }, [fetchData, currentPage, query, statusFilter]);

  useEffect(() => {
    const handleDataChange = () => handleRefresh();
    // Listen to this event which should be dispatched after ANY CUD operation on batches/stages/sales
    document.addEventListener('processingBatchDataChanged', handleDataChange);
    return () => document.removeEventListener('processingBatchDataChanged', handleDataChange);
  }, [handleRefresh]);

  const table = useReactTable({
    data: records,
    columns: batchColumns,
    state: { sorting, columnFilters, columnVisibility },
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    manualPagination: true,
  });

  const openDialog = (
    dialogSetter: React.Dispatch<React.SetStateAction<boolean>>,
    batch: ProcessingBatchWithSummary // This is correct for table rows
  ) => {
    setSelectedBatchForAction(batch); // Keep this for other dialogs and delete
    dialogSetter(true);
  };

  const confirmDeleteBatch = async () => {
    if (!selectedBatchForAction) return;
    setIsDeleting(true);
    try {
      await axios.delete(`/api/processing-batches/${selectedBatchForAction.id}`, { withCredentials: true });
      toast.success(`Batch ${selectedBatchForAction.batchCode} deleted.`);
      setShowDeleteBatchDialog(false);
      handleRefresh();
      // After deletion, the specific batch detail cache (if any) is no longer relevant.
      // It will naturally be gone if `handleRefresh` leads to its ID not being in the list.
    } catch (error: any) {
      toast.error(error.response?.data?.error || 'Failed to delete batch.');
    } finally {
      setIsDeleting(false);
    }
  };

  const renderTableSkeleton = () => (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <Skeleton className="h-8 w-24" />
        <Skeleton className="h-8 w-20" />
      </div>
      <ScrollArea className="rounded-md border h-[calc(100vh-350px)] w-full">
        <Table>
          <TableHeader className="sticky top-0 bg-secondary z-10">
            <TableRow>
              {batchColumns.map((col, idx) => (
                <TableHead key={`skel-head-${idx}`}>
                  <Skeleton className="h-4 w-20" />
                </TableHead>
              ))}
              <TableHead className="sticky right-0 bg-secondary z-10 text-center">
                <Skeleton className="h-4 w-16 mx-auto" />
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {Array.from({ length: 5 }).map((_, i) => (
              <TableRow key={`skel-row-${i}`}>
                {batchColumns.map((col, j) => (
                  <TableCell key={`skel-cell-${i}-${j}`}>
                    <Skeleton className="h-4 w-full" />
                  </TableCell>
                ))}
                <TableCell className="sticky right-0 bg-background z-0 flex items-center justify-center gap-1 py-1.5">
                  <Skeleton className="h-7 w-7" /> <Skeleton className="h-7 w-7" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </ScrollArea>
    </div>
  );

  if (loading && records.length === 0) {
    return renderTableSkeleton();
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <Button variant="outline" size="sm" onClick={handleRefresh} disabled={refreshing || loading} className="h-8">
          <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
          {refreshing ? 'Refreshing...' : 'Refresh'}
        </Button>
        <ColumnFilter table={table} />
      </div>
      <ScrollArea className="rounded-md border h-[calc(100vh-350px)] w-full">
        <Table>
          <TableHeader className="sticky top-0 bg-secondary z-10">
            {table.getHeaderGroups().map(headerGroup => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map(header => (
                  <TableHead key={header.id} className="whitespace-nowrap">
                    {header.isPlaceholder ? null : (
                      <div
                        className={header.column.getCanSort() ? 'cursor-pointer select-none flex items-center' : ''}
                        onClick={header.column.getToggleSortingHandler()}
                      >
                        {flexRender(header.column.columnDef.header, header.getContext())}
                        {header.column.getCanSort() && <ArrowUpDown className="ml-2 h-4 w-4 opacity-50" />}
                      </div>
                    )}
                  </TableHead>
                ))}
                <TableHead className="sticky right-0 bg-secondary z-10 text-center">Actions</TableHead>
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map(row => {
                const batchSummary = row.original; // Type is ProcessingBatchWithSummary
                const latestStage = batchSummary.latestStageSummary;
                // Ensure canPerformStageActions correctly checks for non-terminal statuses for stage-specific actions
                const canPerformStageActions =
                  latestStage && latestStage.status !== 'SOLD_OUT' && latestStage.status !== 'CANCELLED';

                return (
                  <TableRow key={row.id} data-state={row.getIsSelected() && 'selected'}>
                    {row.getVisibleCells().map(cell => (
                      <TableCell key={cell.id} className="whitespace-nowrap">
                        {flexRender(cell.column.columnDef.cell, cell.getContext())}
                      </TableCell>
                    ))}
                    <TableCell className="sticky right-0 bg-background z-0 flex items-center justify-center gap-1 py-1.5">
                      {/* Pass batchSummary.id to BatchDetailsDialog */}
                      <Button
                        variant="ghost"
                        size="icon" // Make it an icon button for consistency
                        onClick={() => {
                          setSelectedBatchForAction(batchSummary); // Keep this for delete/other actions
                          setShowDetailsDialog(true); // This specific state controls BatchDetailsDialog
                        }}
                        title="View Details"
                      >
                        <Eye className="h-4 w-4" />
                      </Button>

                      {/* Action buttons logic */}
                      {canPerformStageActions && latestStage.status === 'IN_PROGRESS' && (
                        <>
                          <Button
                            variant="outline"
                            size="icon"
                            onClick={() => openDialog(setShowAddDryingDialog, batchSummary)}
                            title="Add Drying Data"
                          >
                            {' '}
                            <Wind className="h-4 w-4" />{' '}
                          </Button>
                          <Button
                            variant="outline"
                            size="icon"
                            onClick={() => openDialog(setShowFinalizeStageDialog, batchSummary)}
                            title="Finalize Stage"
                          >
                            {' '}
                            <CheckSquare className="h-4 w-4" />{' '}
                          </Button>
                        </>
                      )}
                      {canPerformStageActions && latestStage.status === 'FINISHED' && (
                        <>
                          <Button
                            variant="outline"
                            size="icon"
                            onClick={() => openDialog(setShowStartNextStageDialog, batchSummary)}
                            title="Start Next Stage"
                            disabled={batchSummary.netAvailableQuantity <= 0}
                          >
                            {' '}
                            <Layers className="h-4 w-4" />{' '}
                          </Button>
                          <Button
                            variant="outline"
                            size="icon"
                            onClick={() => openDialog(setShowRecordSaleDialog, batchSummary)}
                            title="Record Sale"
                            disabled={batchSummary.netAvailableQuantity <= 0}
                          >
                            {' '}
                            <ShoppingCart className="h-4 w-4" />{' '}
                          </Button>
                        </>
                      )}
                      {isAdmin && (
                        <Button
                          variant="destructive"
                          size="icon"
                          onClick={() => openDialog(setShowDeleteBatchDialog, batchSummary)}
                          title="Delete Batch"
                        >
                          {' '}
                          <Trash2 className="h-4 w-4" />{' '}
                        </Button>
                      )}
                    </TableCell>
                  </TableRow>
                );
              })
            ) : (
              <TableRow>
                <TableCell colSpan={batchColumns.length + 1} className="h-24 text-center">
                  No batches found.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </ScrollArea>

      {/* Batch Details Dialog uses selectedBatchForAction.id if selectedBatchForAction is not null */}
      {selectedBatchForAction && showDetailsDialog && (
        <BatchDetailsDialog
          batchId={selectedBatchForAction.id}
          open={showDetailsDialog}
          onOpenChange={setShowDetailsDialog}
        />
      )}

      {/* Other Action Dialogs */}
      {selectedBatchForAction && selectedBatchForAction.latestStageSummary && showAddDryingDialog && (
        <AddDryingDialog
          processingStageId={selectedBatchForAction.latestStageSummary.id}
          batchCode={selectedBatchForAction.batchCode}
          processingCount={selectedBatchForAction.latestStageSummary.processingCount}
          open={showAddDryingDialog}
          onOpenChange={setShowAddDryingDialog}
          onSuccess={handleRefresh}
        />
      )}
      {selectedBatchForAction && selectedBatchForAction.latestStageSummary && showFinalizeStageDialog && (
        <FinalizeStageDialog
          processingStageId={selectedBatchForAction.latestStageSummary.id}
          batchCode={selectedBatchForAction.batchCode}
          processingCount={selectedBatchForAction.latestStageSummary.processingCount}
          currentInitialQuantity={selectedBatchForAction.latestStageSummary.initialQuantity}
          open={showFinalizeStageDialog}
          onOpenChange={setShowFinalizeStageDialog}
          onSuccess={handleRefresh}
        />
      )}
      {selectedBatchForAction &&
        selectedBatchForAction.latestStageSummary &&
        showStartNextStageDialog &&
        selectedBatchForAction.latestStageSummary.status === 'FINISHED' && (
          <StartNextStageDialog
            processingBatchId={selectedBatchForAction.id}
            batchCode={selectedBatchForAction.batchCode}
            previousStageId={selectedBatchForAction.latestStageSummary.id}
            previousProcessingCount={selectedBatchForAction.latestStageSummary.processingCount}
            previousStageYield={selectedBatchForAction.netAvailableQuantity} // Correctly uses net from this stage
            open={showStartNextStageDialog}
            onOpenChange={setShowStartNextStageDialog}
            onSuccess={handleRefresh}
          />
        )}
      {selectedBatchForAction &&
        selectedBatchForAction.latestStageSummary &&
        showRecordSaleDialog &&
        selectedBatchForAction.latestStageSummary.status === 'FINISHED' && (
          <RecordSaleDialog
            processingBatchId={selectedBatchForAction.id}
            processingStage={{
              id: selectedBatchForAction.latestStageSummary.id,
              processingCount: selectedBatchForAction.latestStageSummary.processingCount,
              quantityAfterProcess: selectedBatchForAction.latestStageSummary.quantityAfterProcess,
              status: selectedBatchForAction.latestStageSummary.status, // Pass the dynamic status
            }}
            batchCode={selectedBatchForAction.batchCode}
            availableForSaleFromStage={selectedBatchForAction.netAvailableQuantity} // net available from this finished stage
            open={showRecordSaleDialog}
            onOpenChange={setShowRecordSaleDialog}
            onSuccess={handleRefresh}
          />
        )}

      <AlertDialog open={showDeleteBatchDialog} onOpenChange={setShowDeleteBatchDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Batch: {selectedBatchForAction?.batchCode}?</AlertDialogTitle>
            <AlertDialogDescription>
              This action is irreversible. All associated data will be affected.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              className="bg-destructive hover:bg-destructive/90"
              onClick={confirmDeleteBatch}
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete Batch'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\add-drying-dialog.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { createDryingEntrySchema, type CreateDryingEntryInput, type Drying } from '@chaya/shared';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';
import axios from 'axios';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';

interface AddDryingDialogProps {
  processingStageId: number;
  batchCode: string;
  processingCount: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function AddDryingDialog({
  processingStageId,
  batchCode,
  processingCount,
  open,
  onOpenChange,
  onSuccess,
}: AddDryingDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [existingDryingEntries, setExistingDryingEntries] = useState<Drying[]>([]);
  const [isLoadingEntries, setIsLoadingEntries] = useState(false);

  const form = useForm<CreateDryingEntryInput>({
    resolver: zodResolver(createDryingEntrySchema),
    defaultValues: {
      processingStageId: processingStageId,
      day: 1,
      temperature: 25,
      humidity: 60,
      pH: 7,
      moisturePercentage: 15,
      currentQuantity: 0,
    },
  });

  useEffect(() => {
    if (open && processingStageId) {
      form.setValue('processingStageId', processingStageId);
      const fetchExistingEntries = async () => {
        setIsLoadingEntries(true);
        try {
          const response = await axios.get<{ dryingEntries: Drying[] }>(
            `/api/processing-stages/${processingStageId}/drying`,
            { withCredentials: true }
          );
          setExistingDryingEntries(response.data.dryingEntries);
          const nextDay =
            response.data.dryingEntries.length > 0 ? Math.max(...response.data.dryingEntries.map(d => d.day)) + 1 : 1;
          form.setValue('day', nextDay);
          const lastEntry = response.data.dryingEntries.sort((a, b) => b.day - a.day)[0];
          form.setValue('currentQuantity', lastEntry ? lastEntry.currentQuantity : 0);
        } catch (error) {
          toast.error('Failed to load existing drying entries.');
        } finally {
          setIsLoadingEntries(false);
        }
      };
      fetchExistingEntries();
    }
  }, [open, processingStageId, form]);

  const onSubmit = async (data: CreateDryingEntryInput) => {
    setIsSubmitting(true);
    try {
      await axios.post(`/api/processing-stages/${processingStageId}/drying`, data, { withCredentials: true });
      toast.success(`Drying data for Day ${data.day} added successfully.`);
      onSuccess();
      onOpenChange(false);
      const nextDay = data.day + 1;
      form.reset({
        ...form.formState.defaultValues,
        day: nextDay,
        processingStageId,
        currentQuantity: data.currentQuantity,
      });
    } catch (error: any) {
      console.error('Error adding drying data:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to add drying data'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-2xl">
        <DialogHeader>
          <DialogTitle>
            Add Drying Data for Batch {batchCode} - P{processingCount}
          </DialogTitle>
          <DialogDescription>Enter the drying parameters for the specified day.</DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="day"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Day Number</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        {...field}
                        onChange={e => field.onChange(parseInt(e.target.value, 10) || 0)}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="temperature"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Temperature (°C)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="humidity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Humidity (%)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="pH"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>pH Level</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="moisturePercentage"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Moisture (%)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.1"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="currentQuantity"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Current Quantity (kg)</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.5"
                        {...field}
                        onChange={e => field.onChange(parseFloat(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting || isLoadingEntries}>
                {isSubmitting ? 'Adding...' : 'Add Entry'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
        {isLoadingEntries && <p className="text-sm text-center py-4">Loading existing entries...</p>}
        {!isLoadingEntries && existingDryingEntries.length > 0 && (
          <div className="mt-6">
            <h4 className="text-md font-semibold mb-2">Previous Drying Entries (P{processingCount})</h4>
            <ScrollArea className="h-[200px] border rounded-md">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Day</TableHead>
                    <TableHead>Temp</TableHead>
                    <TableHead>Hum</TableHead>
                    <TableHead>pH</TableHead>
                    <TableHead>Moist%</TableHead>
                    <TableHead>Qty(kg)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {existingDryingEntries.map(entry => (
                    <TableRow key={entry.id}>
                      <TableCell>{entry.day}</TableCell>
                      <TableCell>{entry.temperature}°C</TableCell>
                      <TableCell>{entry.humidity}%</TableCell>
                      <TableCell>{entry.pH}</TableCell>
                      <TableCell>{entry.moisturePercentage}%</TableCell>
                      <TableCell>{entry.currentQuantity}kg</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\finalize-stage-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  type FinalizeProcessingStageInput as BackendFinalizeProcessingStageInputType,
  type Drying,
} from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { toast } from 'sonner';
import axios from 'axios';

const finalizeStageFormSchema = z.object({
  dateOfCompletion: z.date({
    required_error: 'Date of Completion is required',
    invalid_type_error: "That's not a valid date!",
  }),
  quantityAfterProcess: z.coerce
    .number({
      required_error: 'Final quantity is required',
      invalid_type_error: 'Final quantity must be a number',
    })
    .positive('Final quantity must be a positive number'),
});

type FinalizeStageFormValues = z.infer<typeof finalizeStageFormSchema>;

interface FinalizeStageDialogProps {
  processingStageId: number;
  batchCode: string;
  processingCount: number;
  currentInitialQuantity: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function FinalizeStageDialog({
  processingStageId,
  batchCode,
  processingCount,
  currentInitialQuantity,
  open,
  onOpenChange,
  onSuccess,
}: FinalizeStageDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoadingDrying, setIsLoadingDrying] = useState(false);

  const form = useForm<FinalizeStageFormValues>({
    resolver: zodResolver(finalizeStageFormSchema),
    defaultValues: {
      dateOfCompletion: new Date(),
      quantityAfterProcess: undefined,
    },
  });

  useEffect(() => {
    if (open && processingStageId) {
      setIsLoadingDrying(true);
      axios
        .get<{ dryingEntries: Drying[] }>(`/api/processing-stages/${processingStageId}/drying`, {
          withCredentials: true,
        })
        .then(response => {
          const dryingEntries = response.data.dryingEntries;
          const latestDryingEntry = dryingEntries?.sort((a, b) => b.day - a.day)[0];
          const autoFillQuantity = latestDryingEntry?.currentQuantity ?? currentInitialQuantity;

          form.reset({
            dateOfCompletion: new Date(),
            quantityAfterProcess: parseFloat(autoFillQuantity.toFixed(2)) || undefined,
          });
        })
        .catch(err => {
          toast.error('Could not load latest drying quantity for autofill.');
          console.error('Error fetching drying entries for autofill:', err);
          form.reset({
            dateOfCompletion: new Date(),
            quantityAfterProcess: parseFloat(currentInitialQuantity.toFixed(2)) || undefined,
          });
        })
        .finally(() => {
          setIsLoadingDrying(false);
        });
    }
  }, [open, processingStageId, form, currentInitialQuantity]);

  const onSubmit = async (data: FinalizeStageFormValues) => {
    setIsSubmitting(true);
    try {
      const payload: BackendFinalizeProcessingStageInputType = {
        dateOfCompletion: data.dateOfCompletion,
        quantityAfterProcess: data.quantityAfterProcess,
      };
      await axios.put(`/api/processing-stages/${processingStageId}/finalize`, payload, { withCredentials: true });
      toast.success(`Stage P${processingCount} for Batch ${batchCode} finalized successfully.`);
      onSuccess();
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error finalizing stage:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to finalize stage'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            Finalize Stage P{processingCount} for Batch {batchCode}
          </DialogTitle>
          <DialogDescription>
            Enter the completion details. Initial quantity for this stage was {currentInitialQuantity.toFixed(2)}kg.
            {isLoadingDrying && ' Fetching latest drying quantity...'}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="dateOfCompletion"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Date of Completion</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="quantityAfterProcess"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Quantity After Process (kg)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      step="0.01"
                      placeholder="Enter final yield for this stage"
                      {...field}
                      disabled={isLoadingDrying}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
                disabled={isSubmitting || isLoadingDrying}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting || isLoadingDrying}>
                {isSubmitting ? 'Finalizing...' : 'Finalize Stage'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\record-sale-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  createSaleFormSchema,
  type CreateSaleInput as BackendCreateSaleInputType,
  ProcessingStageStatus,
} from '@chaya/shared';
// Removed unused type ProcessingStage, import ProcessingStageStatus instead
// import type { ProcessingStage } from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon, Clock } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns'; // Removed unused 'parse'
import { toast } from 'sonner';
import axios from 'axios';
import { z } from 'zod';

type SaleFormDialogValues = z.infer<typeof createSaleFormSchema>;

interface ProcessingStageInfoForSaleDialog {
  id: number;
  processingCount: number;
  quantityAfterProcess: number | null; // Yield of the stage
  status: typeof ProcessingStageStatus | 'SOLD_OUT' | 'NO_STAGES' | 'IN_PROGRESS' | 'FINISHED' | 'CANCELLED'; // For display
}

interface RecordSaleDialogProps {
  processingBatchId: number;
  processingStage: ProcessingStageInfoForSaleDialog; // Use refined type
  batchCode: string;
  availableForSaleFromStage: number; // This is the key dynamic value: stage_yield - sales_from_stage
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function RecordSaleDialog({
  processingBatchId,
  processingStage,
  batchCode,
  availableForSaleFromStage,
  open,
  onOpenChange,
  onSuccess,
}: RecordSaleDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<SaleFormDialogValues>({
    resolver: zodResolver(createSaleFormSchema),
    defaultValues: {
      quantitySold: undefined, // Keep as undefined
      dateOfSaleInput: new Date(),
      timeOfSaleInput: format(new Date(), 'HH:mm:ss'),
    },
  });

  useEffect(() => {
    if (open) {
      form.reset({
        quantitySold: undefined,
        dateOfSaleInput: new Date(),
        timeOfSaleInput: format(new Date(), 'HH:mm:ss'),
      });
    }
  }, [open, form]);

  const onSubmit = async (data: SaleFormDialogValues) => {
    setIsSubmitting(true);
    // Explicitly coerce quantitySold to number before comparison
    const quantityToSell = Number(data.quantitySold);

    if (quantityToSell > availableForSaleFromStage) {
      toast.error(
        `Cannot sell ${quantityToSell}kg. Only ${availableForSaleFromStage.toFixed(2)}kg available from P${processingStage.processingCount}.`
      );
      setIsSubmitting(false);
      return;
    }

    const datePartStr = format(data.dateOfSaleInput, 'yyyy-MM-dd');
    const timePartStr = data.timeOfSaleInput; // Already HH:mm:ss
    const combinedDateTime = new Date(`${datePartStr}T${timePartStr}`);
    if (isNaN(combinedDateTime.getTime())) {
      toast.error('Invalid date or time for sale.');
      setIsSubmitting(false);
      return;
    }

    const payload: BackendCreateSaleInputType = {
      quantitySold: quantityToSell, // Use coerced number
      dateOfSale: combinedDateTime,
      processingBatchId,
      processingStageId: processingStage.id,
    };
    try {
      await axios.post(`/api/sales`, payload, { withCredentials: true });
      toast.success(
        `Sale of ${payload.quantitySold}kg for Batch ${batchCode} (from P${processingStage.processingCount}) recorded.`
      );
      onSuccess(); // This should trigger a refresh in the table
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error recording sale:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to record sale'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>
            Record Sale from Batch {batchCode} - Stage P{processingStage.processingCount}
          </DialogTitle>
          <DialogDescription>
            Stage Yield: {(processingStage.quantityAfterProcess || 0).toFixed(2)}kg. Available from this stage:{' '}
            {availableForSaleFromStage.toFixed(2)}kg.
            {processingStage.status !== 'FINISHED' &&
              processingStage.status !== 'SOLD_OUT' &&
              " Note: This stage is not marked 'FINISHED' or 'SOLD_OUT'."}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 pt-4">
            <FormField
              control={form.control}
              name="quantitySold"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Quantity Sold (kg)</FormLabel>
                  <FormControl>
                    <Input
                      type="number"
                      step="0.01"
                      min="0.01"
                      placeholder={`Max ${availableForSaleFromStage.toFixed(2)}`}
                      {...field}
                      // value={field.value === undefined ? '' : field.value} // Keep for controlled component
                      onChange={e => field.onChange(e.target.value === '' ? undefined : parseFloat(e.target.value))}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="dateOfSaleInput"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Date of Sale</FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant="outline"
                            className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                          >
                            {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="timeOfSaleInput"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Time of Sale</FormLabel>
                    <div className="flex items-center">
                      <FormControl>
                        <Input
                          type="time"
                          step="1" // Allow seconds input
                          className="flex-1"
                          {...field}
                          value={field.value || format(new Date(), 'HH:mm:ss')} // Default to current time if empty
                          onChange={e => {
                            let timeValue = e.target.value;
                            // Basic attempt to ensure HH:mm:ss format on blur or partial input.
                            // More robust validation is via Zod.
                            if (timeValue.match(/^\d{2}:\d{2}$/)) {
                              // If user enters HH:mm
                              timeValue += ':00';
                            } else if (!timeValue.match(/^\d{2}:\d{2}:\d{2}$/)) {
                              // If not HH:mm and not HH:mm:ss, might be invalid.
                              // Revert to field value or current if completely off.
                              timeValue = field.value || format(new Date(), 'HH:mm:ss');
                            }
                            field.onChange(timeValue);
                          }}
                        />
                      </FormControl>
                      <Clock className="ml-2 h-4 w-4 text-muted-foreground" />
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={isSubmitting || availableForSaleFromStage <= 0 || processingStage.status !== 'FINISHED'}
              >
                {isSubmitting ? 'Recording...' : 'Record Sale'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\start-next-stage-dialog.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { type CreateProcessingStageInput as BackendCreateProcessingStageInputType } from '@chaya/shared';

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Button } from '@workspace/ui/components/button';
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { toast } from 'sonner';
import axios from 'axios';

const nextStageFormStepSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z.date({
    required_error: 'Date of Processing is required',
    invalid_type_error: "That's not a valid date!",
  }),
  doneBy: z.string().min(1, 'Person responsible is required'),
});

type NextStageFormValues = z.infer<typeof nextStageFormStepSchema>;

interface StartNextStageDialogProps {
  processingBatchId: number;
  batchCode: string;
  previousStageId: number;
  previousProcessingCount: number;
  previousStageYield: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
}

export function StartNextStageDialog({
  processingBatchId,
  batchCode,
  previousStageId,
  previousProcessingCount,
  previousStageYield,
  open,
  onOpenChange,
  onSuccess,
}: StartNextStageDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const nextProcessingCount = previousProcessingCount + 1;

  const form = useForm<NextStageFormValues>({
    resolver: zodResolver(nextStageFormStepSchema),
    defaultValues: {
      processMethod: 'wet',
      dateOfProcessing: new Date(),
      doneBy: '',
    },
  });

  useEffect(() => {
    if (open) {
      form.reset({
        processMethod: 'wet',
        dateOfProcessing: new Date(),
        doneBy: '',
      });
    }
  }, [open, form]);

  const onSubmit = async (data: NextStageFormValues) => {
    setIsSubmitting(true);
    try {
      const payload: BackendCreateProcessingStageInputType = {
        processMethod: data.processMethod,
        dateOfProcessing: data.dateOfProcessing,
        doneBy: data.doneBy,
        processingBatchId,
        previousStageId,
      };
      await axios.post(`/api/processing-stages`, payload, { withCredentials: true });
      toast.success(`Stage P${nextProcessingCount} for Batch ${batchCode} started successfully.`);
      onSuccess();
      onOpenChange(false);
    } catch (error: any) {
      console.error('Error starting next stage:', error);
      toast.error(`Error: ${error.response?.data?.error || 'Failed to start next stage'}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>
            Start Next Stage (P{nextProcessingCount}) for Batch {batchCode}
          </DialogTitle>
          <DialogDescription>
            Stage P{previousProcessingCount} finished with a yield of {previousStageYield.toFixed(2)}kg. The new stage P
            {nextProcessingCount} will start with the quantity remaining after any sales from P{previousProcessingCount}
            .
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 pt-4">
            <FormField
              control={form.control}
              name="processMethod"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Process Method (P{nextProcessingCount})</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select method" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="wet">Wet</SelectItem>
                      <SelectItem value="dry">Dry</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="dateOfProcessing"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Date of Processing (P{nextProcessingCount})</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="doneBy"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Done By (P{nextProcessingCount})</FormLabel>
                  <FormControl>
                    <Input placeholder="Responsible person/team" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)} disabled={isSubmitting}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Starting Stage...' : `Start P${nextProcessingCount}`}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\components\dialogs\batch-details-dialog.tsx:
```
'use client';

import { useEffect, useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@workspace/ui/components/dialog';
import type {
  ProcessingBatchWithDetails,
  ExtendedProcessingStageStatus,
  ProcessingStageWithDetails,
} from '../../lib/types';
import { useProcessingBatchCache } from '../../context/processing-batch-cache-context';
import { Separator } from '@workspace/ui/components/separator';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Badge } from '@workspace/ui/components/badge';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { format } from 'date-fns';
import { Button } from '@workspace/ui/components/button';
import { Skeleton } from '@workspace/ui/components/skeleton';

interface BatchDetailsDialogProps {
  batchId: number | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function BatchDetailsDialog({ batchId, open, onOpenChange }: BatchDetailsDialogProps) {
  const { getBatchDetails } = useProcessingBatchCache();
  const [batch, setBatch] = useState<ProcessingBatchWithDetails | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (open && batchId) {
      setIsLoading(true);
      setBatch(null);
      getBatchDetails(batchId)
        .then(data => {
          if (data) {
            setBatch(data);
          } else {
            console.error(`BatchDetailsDialog: Batch data for ID ${batchId} not found or failed to load.`);
          }
        })
        .catch(err => {
          console.error('Error fetching batch details for dialog:', err);
          setBatch(null);
        })
        .finally(() => setIsLoading(false));
    } else if (!open) {
      setBatch(null);
    }
  }, [open, batchId, getBatchDetails]);

  const getStatusBadgeVariant = (
    status?: ExtendedProcessingStageStatus
  ): 'default' | 'secondary' | 'destructive' | 'outline' => {
    if (!status) return 'outline';
    switch (status) {
      case 'IN_PROGRESS':
        return 'secondary';
      case 'FINISHED':
      case 'SOLD_OUT':
        return 'default';
      case 'CANCELLED':
        return 'destructive';
      case 'NO_STAGES':
      default:
        return 'outline';
    }
  };

  const displayedOverallStatus = batch?.latestStageSummary?.status || 'NO_STAGES';

  const renderSkeleton = () => (
    <>
      <DialogHeader className="p-6 pb-4 border-b">
        {' '}
        {/* Ensure header is always present */}
        <DialogTitle>
          <Skeleton className="h-7 w-3/5 mb-1" />
        </DialogTitle>
        <DialogDescription>
          <Skeleton className="h-4 w-full mb-1" />
          <Skeleton className="h-4 w-4/5" />
        </DialogDescription>
      </DialogHeader>
      <ScrollArea className="flex-grow overflow-y-auto px-6 py-4">
        <div className="space-y-5">
          <div>
            <h3 className="text-md font-semibold mb-1.5">
              <Skeleton className="h-5 w-1/4" />
            </h3>
            <Separator className="my-1" />
            <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mt-2 p-3 border rounded-md bg-muted/20">
              <div>
                <Skeleton className="h-4 w-20 mb-1" />
                <Skeleton className="h-5 w-16" />
              </div>
              <div>
                <Skeleton className="h-4 w-24 mb-1" />
                <Skeleton className="h-5 w-16" />
              </div>
              <div>
                <Skeleton className="h-4 w-28 mb-1" />
                <Skeleton className="h-5 w-16" />
              </div>
            </div>
          </div>
          <div>
            <h3 className="text-md font-semibold mb-1.5">
              <Skeleton className="h-5 w-1/3" />
            </h3>
            <Separator className="my-1" />
            <div className="mt-2 border rounded-md max-h-48 overflow-y-auto p-2 space-y-2">
              <Skeleton className="h-5 w-full" />
              <Skeleton className="h-5 w-full" />
              <Skeleton className="h-5 w-full" />
            </div>
          </div>
          <div>
            <h3 className="text-md font-semibold mb-1.5">
              <Skeleton className="h-5 w-1/4" />
            </h3>
            <Separator className="my-1" />
            <div className="mt-2.5 border p-3 rounded-md bg-card shadow-sm space-y-2">
              <Skeleton className="h-4 w-1/2 mb-1" />
              <Skeleton className="h-3 w-3/4 mb-1" />
              <Skeleton className="h-3 w-1/2 mb-1" />
              <div className="border rounded-md max-h-32 overflow-y-auto p-2 space-y-1">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-full" />
              </div>
            </div>
          </div>
        </div>
      </ScrollArea>
      <DialogFooter className="p-6 pt-4 border-t">
        <Button variant="outline" onClick={() => onOpenChange(false)} disabled>
          Close
        </Button>
      </DialogFooter>
    </>
  );

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col p-0">
        {isLoading || (!batch && open) ? (
          renderSkeleton()
        ) : !batch ? (
          <>
            <DialogHeader className="p-6 pb-2">
              <DialogTitle>Error Loading Batch</DialogTitle> {/* Always provide a title */}
              <DialogDescription>Could not load batch details. Please try again.</DialogDescription>
            </DialogHeader>
            <DialogFooter className="p-6 pt-2 border-t">
              <Button variant="outline" onClick={() => onOpenChange(false)}>
                Close
              </Button>
            </DialogFooter>
          </>
        ) : (
          <>
            <DialogHeader className="p-6 pb-4 border-b">
              <DialogTitle>Batch Details: {batch.batchCode}</DialogTitle>
              <DialogDescription className="flex items-center flex-wrap gap-x-2 gap-y-1 text-sm pt-1">
                <span>
                  Crop: <span className="font-semibold">{batch.crop}</span>
                </span>
                <Separator orientation="vertical" className="h-4" />
                <span>
                  Lot No: <span className="font-semibold">{batch.lotNo}</span>
                </span>
                <Separator orientation="vertical" className="h-4" />
                <span>
                  Created By: <span className="font-semibold">{batch.createdBy.name}</span>
                </span>
                <Separator orientation="vertical" className="h-4" />
                <span>
                  On: <span className="font-semibold">{format(new Date(batch.createdAt), 'PP')}</span>
                </span>
                <Separator orientation="vertical" className="h-4" />
                <span>Overall Status:</span>
                <Badge variant={getStatusBadgeVariant(displayedOverallStatus)} className="ml-1">
                  {displayedOverallStatus.toString().replace(/_/g, ' ')}
                </Badge>
              </DialogDescription>
            </DialogHeader>

            <ScrollArea className="flex-grow overflow-y-auto px-6 py-4">
              <div className="space-y-5">
                {/* Key Figures Section */}
                <div>
                  <h3 className="text-md font-semibold mb-1.5">Key Figures</h3>
                  <Separator />
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mt-2 text-sm p-3 border rounded-md bg-muted/20">
                    <div>
                      <span className="text-xs text-muted-foreground block">Initial Batch Qty:</span>{' '}
                      {/* Use span or div instead of p */}
                      <span className="font-semibold block">{batch.initialBatchQuantity.toFixed(2)} kg</span>
                    </div>
                    <div>
                      <span className="text-xs text-muted-foreground block">Total Sold from Batch:</span>
                      <span className="font-semibold block">{batch.totalQuantitySoldFromBatch.toFixed(2)} kg</span>
                    </div>
                    <div>
                      <span className="text-xs text-muted-foreground block">Net Available (latest stage):</span>
                      <span className="font-bold text-green-600 block">{batch.netAvailableQuantity.toFixed(2)} kg</span>
                    </div>
                  </div>
                </div>

                {/* Procurements Section */}
                <div>
                  <h3 className="text-md font-semibold mb-1.5">
                    Procurements Included ({batch.procurements?.length || 0})
                  </h3>
                  <Separator />
                  {batch.procurements && batch.procurements.length > 0 ? (
                    <div className="mt-2 border rounded-md max-h-48 overflow-y-auto">
                      <Table className="text-xs">
                        <TableHeader className="sticky top-0 bg-muted/50 z-10">
                          <TableRow>
                            <TableHead className="py-1.5">Proc. No.</TableHead>
                            <TableHead className="py-1.5">Farmer</TableHead>
                            <TableHead className="py-1.5">Village</TableHead>
                            <TableHead className="text-right py-1.5">Qty (kg)</TableHead>
                          </TableRow>
                        </TableHeader>
                        <TableBody>
                          {batch.procurements.map(p => (
                            <TableRow key={p.id}>
                              <TableCell className="font-medium py-1.5">{p.procurementNumber}</TableCell>
                              <TableCell className="py-1.5">{p.farmer.name}</TableCell>
                              <TableCell className="py-1.5">{p.farmer.village || 'N/A'}</TableCell>
                              <TableCell className="text-right py-1.5">{p.quantity.toFixed(2)}</TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    </div>
                  ) : (
                    <div className="text-sm text-muted-foreground mt-2 text-center py-3">No procurements linked.</div> // Use div
                  )}
                </div>

                {/* Processing Stages Section */}
                <div>
                  <h3 className="text-md font-semibold mb-1.5">
                    Processing Stages ({batch.processingStages?.length || 0})
                  </h3>
                  <Separator />
                  {batch.processingStages && batch.processingStages.length > 0 ? (
                    batch.processingStages.map((stage: ProcessingStageWithDetails) => (
                      <div key={stage.id} className="mt-2.5 border p-3 rounded-md bg-card shadow-sm">
                        <div className="flex justify-between items-start mb-1">
                          <div>
                            <h4 className="font-semibold text-sm">
                              Stage P{stage.processingCount}
                              <Badge
                                variant={getStatusBadgeVariant(stage.status as ExtendedProcessingStageStatus)}
                                className="ml-2 text-xs px-1.5 py-0.5"
                              >
                                {stage.status.replace(/_/g, ' ')}
                              </Badge>
                            </h4>
                            <div className="text-xs text-muted-foreground">
                              Method: {stage.processMethod.toUpperCase()} | By: {stage.doneBy}
                            </div>{' '}
                            {/* Use div */}
                          </div>
                          <div className="text-xs text-muted-foreground text-right">
                            <div>Started: {format(new Date(stage.dateOfProcessing), 'dd/MM/yy HH:mm')}</div>{' '}
                            {/* Use div */}
                            {stage.dateOfCompletion ? (
                              <div>Completed: {format(new Date(stage.dateOfCompletion), 'dd/MM/yy HH:mm')}</div>
                            ) : (
                              ''
                            )}
                          </div>
                        </div>
                        <div className="grid grid-cols-2 gap-x-3 text-xs mb-1.5">
                          <div>
                            <span className="text-muted-foreground">Initial Qty:</span>{' '}
                            {stage.initialQuantity.toFixed(2)}kg
                          </div>{' '}
                          {/* Use div */}
                          {stage.quantityAfterProcess !== null && (
                            <div>
                              <span className="text-muted-foreground">Stage Yield:</span>{' '}
                              {stage.quantityAfterProcess.toFixed(2)}kg
                            </div>
                          )}
                        </div>

                        {stage.dryingEntries?.length > 0 && (
                          <div className="mt-1.5">
                            <div className="text-xs font-medium mb-0.5">
                              Drying Entries ({stage.dryingEntries.length}):
                            </div>{' '}
                            {/* Use div */}
                            <div className="border rounded-md max-h-32 overflow-y-auto">
                              <Table className="text-xs">
                                <TableHeader className="sticky top-0 bg-muted/50 z-10">
                                  <TableRow>
                                    <TableHead className="py-1">Day</TableHead>
                                    <TableHead className="py-1">Temp</TableHead>
                                    <TableHead className="py-1">Humid</TableHead>
                                    <TableHead className="py-1">pH</TableHead>
                                    <TableHead className="py-1">Moist%</TableHead>
                                    <TableHead className="text-right py-1">Qty(kg)</TableHead>
                                  </TableRow>
                                </TableHeader>
                                <TableBody>
                                  {stage.dryingEntries.map(d => (
                                    <TableRow key={d.id}>
                                      <TableCell className="py-1">{d.day}</TableCell>
                                      <TableCell className="py-1">{d.temperature}°C</TableCell>
                                      <TableCell className="py-1">{d.humidity}%</TableCell>
                                      <TableCell className="py-1">{d.pH}</TableCell>
                                      <TableCell className="py-1">{d.moisturePercentage}%</TableCell>
                                      <TableCell className="text-right py-1">{d.currentQuantity.toFixed(2)}</TableCell>
                                    </TableRow>
                                  ))}
                                </TableBody>
                              </Table>
                            </div>
                          </div>
                        )}
                        {(!stage.dryingEntries || stage.dryingEntries.length === 0) &&
                          stage.status === 'IN_PROGRESS' && (
                            <div className="text-xs text-muted-foreground mt-1 text-center py-1.5">
                              No drying entries for this stage.
                            </div> // Use div
                          )}

                        {stage.sales?.length > 0 && (
                          <div className="mt-1.5">
                            <div className="text-xs font-medium mb-0.5">
                              Sales from P{stage.processingCount} ({stage.sales.length}):
                            </div>{' '}
                            {/* Use div */}
                            <div className="border rounded-md max-h-28 overflow-y-auto">
                              <Table className="text-xs">
                                <TableHeader className="sticky top-0 bg-muted/50 z-10">
                                  <TableRow>
                                    <TableHead className="py-1">Sale Date</TableHead>
                                    <TableHead className="text-right py-1">Qty Sold</TableHead>
                                  </TableRow>
                                </TableHeader>
                                <TableBody>
                                  {stage.sales.map(s => (
                                    <TableRow key={s.id}>
                                      <TableCell className="py-1">{format(new Date(s.dateOfSale), 'PP')}</TableCell>
                                      <TableCell className="text-right py-1">{s.quantitySold.toFixed(2)}kg</TableCell>
                                    </TableRow>
                                  ))}
                                </TableBody>
                              </Table>
                            </div>
                          </div>
                        )}
                      </div>
                    ))
                  ) : (
                    <div className="text-sm text-muted-foreground mt-2 text-center py-3">
                      No processing stages recorded yet.
                    </div> // Use div
                  )}
                </div>

                {/* All Sales Section */}
                <div>
                  <h3 className="text-md font-semibold mb-1.5">All Sales From Batch ({batch.sales?.length || 0})</h3>
                  <Separator />
                  {batch.sales && batch.sales.length > 0 ? (
                    <div className="mt-2 border rounded-md max-h-32 overflow-y-auto">
                      <Table className="text-xs">
                        <TableHeader className="sticky top-0 bg-muted/50 z-10">
                          <TableRow>
                            <TableHead className="py-1.5">Sale Date</TableHead>
                            <TableHead className="py-1.5">From Stage</TableHead>
                            <TableHead className="text-right py-1.5">Qty Sold (kg)</TableHead>
                          </TableRow>
                        </TableHeader>
                        <TableBody>
                          {batch.sales.map(s => (
                            <TableRow key={s.id}>
                              <TableCell className="py-1.5">{format(new Date(s.dateOfSale), 'PP')}</TableCell>
                              <TableCell className="py-1.5">P{s.processingStage.processingCount}</TableCell>
                              <TableCell className="text-right py-1.5">{s.quantitySold.toFixed(2)}</TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    </div>
                  ) : (
                    <div className="text-sm text-muted-foreground mt-2 text-center py-3">
                      No sales recorded for this batch yet.
                    </div> // Use div
                  )}
                </div>
              </div>
            </ScrollArea>

            <DialogFooter className="p-6 pt-4 border-t">
              <Button variant="outline" onClick={() => onOpenChange(false)}>
                Close
              </Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\lib\columns-batch.tsx:
```
'use client';

import type { ColumnDef } from '@tanstack/react-table';
import type { ProcessingBatchWithSummary, ExtendedProcessingStageStatus } from './types';
import { Badge } from '@workspace/ui/components/badge';
import { format } from 'date-fns';

export const defaultVisibleBatchColumns = [
  'batchCode',
  'crop',
  'lotNo',
  'latestStageStatus', // Changed from latestStage.status to this
  'latestStageCount',
  'netAvailableQuantity',
  // 'totalQuantitySoldFromBatch', // Often this is less relevant in summary than net from stage
  'createdAt',
];

export const batchColumns: ColumnDef<ProcessingBatchWithSummary>[] = [
  {
    accessorKey: 'batchCode',
    header: 'Batch Code',
    cell: ({ row }) => <div className="font-medium">{row.original.batchCode}</div>,
  },
  {
    accessorKey: 'crop',
    header: 'Crop',
    cell: ({ row }) => row.original.crop,
  },
  {
    accessorKey: 'lotNo',
    header: 'Lot No.',
    cell: ({ row }) => row.original.lotNo,
  },
  {
    accessorKey: 'latestStageCount',
    header: 'Stage (P#)',
    cell: ({ row }) =>
      row.original.latestStageSummary ? `P${row.original.latestStageSummary.processingCount}` : 'N/A',
  },
  {
    accessorKey: 'latestStageStatus', // This now comes directly from summary
    header: 'Current Status',
    cell: ({ row }) => {
      const status: ExtendedProcessingStageStatus | undefined = row.original.latestStageSummary?.status;
      if (!status) return <Badge variant="outline">No Stages</Badge>;

      let displayStatus = status.toString().replace(/_/g, ' ');
      let variant: 'default' | 'secondary' | 'destructive' | 'outline' = 'outline';

      switch (status) {
        case 'IN_PROGRESS':
          variant = 'secondary';
          displayStatus = 'In Progress';
          break;
        case 'FINISHED':
          variant = 'default'; // Assuming green/blue for default is "good"
          break;
        case 'SOLD_OUT':
          variant = 'default'; // Visually similar to finished, or choose another like outline with specific text
          displayStatus = 'Sold Out';
          break;
        case 'CANCELLED':
          variant = 'destructive';
          break;
        case 'NO_STAGES': // Should be covered by !status check already
        default:
          variant = 'outline';
          break;
      }
      return <Badge variant={variant}>{displayStatus}</Badge>;
    },
  },
  {
    accessorKey: 'netAvailableQuantity', // This is now "Net Available from Latest Stage"
    header: 'Avail. from Stage (kg)', // Renamed header for clarity
    cell: ({ row }) => <div className="text-right">{row.original.netAvailableQuantity.toFixed(2)}</div>,
  },
  // { // This can be added back if needed, but might clutter the summary view
  //   accessorKey: 'totalQuantitySoldFromBatch',
  //   header: 'Total Batch Sold (kg)',
  //   cell: ({ row }) => <div className="text-right">{row.original.totalQuantitySoldFromBatch.toFixed(2)}</div>,
  // },
  {
    accessorKey: 'initialBatchQuantity',
    header: 'Initial Batch (kg)',
    cell: ({ row }) => <div className="text-right">{row.original.initialBatchQuantity.toFixed(2)}</div>,
  },
  {
    accessorKey: 'createdAt',
    header: 'Created On',
    cell: ({ row }) => format(new Date(row.original.createdAt), 'dd/MM/yyyy'),
  },
];

```

### apps\web\app\(dashboard)\processing-batches\lib\types.ts:
```
import type {
  ProcessingBatch,
  Procurement,
  ProcessingStage,
  Drying,
  Sale,
  User,
  ProcessingStageStatus as PrismaProcessingStageStatus,
} from '@chaya/shared';

export type ExtendedProcessingStageStatus = PrismaProcessingStageStatus | 'SOLD_OUT' | 'NO_STAGES';

export interface ProcessingBatchWithSummary
  extends Omit<ProcessingBatch, 'processingStages' | 'procurements' | 'sales'> {
  latestStageSummary: {
    id: number;
    processingCount: number;
    status: ExtendedProcessingStageStatus;
    processMethod: string;
    dateOfProcessing: Date;
    doneBy: string;
    initialQuantity: number;
    quantityAfterProcess: number | null;
    lastDryingQuantity: number | null;
  } | null;
  totalQuantitySoldFromBatch: number;
  netAvailableQuantity: number;
}

export interface SaleSummaryForStage extends Pick<Sale, 'id' | 'quantitySold' | 'dateOfSale'> {}

export interface ProcessingStageWithDetails extends ProcessingStage {
  dryingEntries: Drying[];
  sales: SaleSummaryForStage[]; // Add sales here
}

export interface SaleWithStageInfo extends Sale {
  processingStage: Pick<ProcessingStage, 'processingCount'>;
}

export interface ProcessingBatchWithDetails extends ProcessingBatch {
  procurements: (Procurement & { farmer: Pick<User, 'name'> & { village?: string } })[];
  processingStages: ProcessingStageWithDetails[]; // Use the updated type here
  sales: SaleWithStageInfo[]; // Overall sales for the batch, with stage info
  createdBy: Pick<User, 'id' | 'name'>;
  totalQuantitySoldFromBatch: number;
  netAvailableQuantity: number; // Net available from the latest stage
  latestStageSummary: {
    id: number;
    processingCount: number;
    status: ExtendedProcessingStageStatus;
    processMethod: string;
    dateOfProcessing: Date;
    doneBy: string;
    initialQuantity: number;
    quantityAfterProcess: number | null;
    lastDryingQuantity: number | null;
  } | null;
}

```

### apps\web\app\(dashboard)\processing-batches\context\processing-batch-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import type { ProcessingBatchWithSummary, ProcessingBatchWithDetails } from '../lib/types';
import { toast } from 'sonner';
import axios from 'axios';

interface ProcessingBatchCacheContextType {
  processingBatchesSummary: Record<string, ProcessingBatchWithSummary[]>;
  totalPages: Record<string, number>;
  fetchProcessingBatchesSummary: (
    page: number,
    query: string,
    statusFilter: string
  ) => Promise<ProcessingBatchWithSummary[]>;
  fetchTotalPages: (query: string, statusFilter: string) => Promise<number>;
  clearCache: () => void;
  refreshCurrentPageSummary: (
    page: number,
    query: string,
    statusFilter: string
  ) => Promise<ProcessingBatchWithSummary[]>;
  getBatchDetails: (batchId: number) => Promise<ProcessingBatchWithDetails | null>;
  clearBatchDetailCache: (batchId: number) => void;
}

const ProcessingBatchCacheContext = createContext<ProcessingBatchCacheContextType | undefined>(undefined);

export function ProcessingBatchCacheProvider({ children }: { children: React.ReactNode }) {
  const [processingBatchesSummary, setProcessingBatchesSummary] = useState<
    Record<string, ProcessingBatchWithSummary[]>
  >({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});
  const [batchDetailsCache, setBatchDetailsCache] = useState<Record<number, ProcessingBatchWithDetails>>({});

  const createListKey = useCallback((page: number, query: string, status: string) => `${query}:${status}:${page}`, []);

  const fetchProcessingBatchesSummary = useCallback(
    async (page: number, query: string, statusFilter: string): Promise<ProcessingBatchWithSummary[]> => {
      const key = createListKey(page, query, statusFilter);
      if (processingBatchesSummary[key]) {
        return processingBatchesSummary[key];
      }
      try {
        const params = new URLSearchParams({ page: page.toString(), limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const data = response.data;

        setProcessingBatchesSummary(prev => ({ ...prev, [key]: data.processingBatches }));
        setTotalPages(prev => ({ ...prev, [`${query}:${statusFilter}`]: data.pagination.totalPages }));
        return data.processingBatches;
      } catch (error) {
        toast.error('Failed to fetch processing batches summary.');
        throw error;
      }
    },
    [processingBatchesSummary]
  );

  const fetchTotalPages = useCallback(
    async (query: string, statusFilter: string): Promise<number> => {
      const key = `${query}:${statusFilter}`;
      if (totalPages[key] !== undefined) {
        return totalPages[key];
      }
      try {
        const params = new URLSearchParams({ page: '1', limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const pages = response.data.pagination.totalPages;
        setTotalPages(prev => ({ ...prev, [key]: pages }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        return 1; // Default to 1 page on error
      }
    },
    [totalPages]
  );

  const refreshCurrentPageSummary = useCallback(
    async (page: number, query: string, statusFilter: string): Promise<ProcessingBatchWithSummary[]> => {
      const key = createListKey(page, query, statusFilter);
      try {
        const params = new URLSearchParams({ page: page.toString(), limit: '10', search: query });
        if (statusFilter) params.set('status', statusFilter);

        const response = await axios.get(`/api/processing-batches?${params.toString()}`, { withCredentials: true });
        const data = response.data;

        setProcessingBatchesSummary(prev => ({ ...prev, [key]: data.processingBatches }));
        setTotalPages(prev => ({ ...prev, [`${query}:${statusFilter}`]: data.pagination.totalPages })); // refresh total pages too
        return data.processingBatches;
      } catch (error) {
        toast.error(`Failed to refresh batches data for page ${page}.`);
        throw error;
      }
    },
    []
  );

  const getBatchDetails = useCallback(
    async (batchId: number): Promise<ProcessingBatchWithDetails | null> => {
      if (batchDetailsCache[batchId]) {
        return batchDetailsCache[batchId];
      }
      try {
        const response = await axios.get<ProcessingBatchWithDetails>(`/api/processing-batches/${batchId}`, {
          withCredentials: true,
        });
        setBatchDetailsCache(prev => ({ ...prev, [batchId]: response.data }));
        return response.data;
      } catch (error) {
        toast.error(`Failed to fetch details for batch ID ${batchId}.`);
        return null;
      }
    },
    [batchDetailsCache]
  );

  const clearBatchDetailCache = useCallback((batchId: number) => {
    setBatchDetailsCache(prev => {
      const newState = { ...prev };
      delete newState[batchId];
      return newState;
    });
  }, []);

  const clearCache = useCallback(() => {
    setProcessingBatchesSummary({});
    setTotalPages({});
    setBatchDetailsCache({});
    toast.info('Processing batches cache cleared.');
  }, []);

  return (
    <ProcessingBatchCacheContext.Provider
      value={{
        processingBatchesSummary,
        totalPages,
        fetchProcessingBatchesSummary,
        fetchTotalPages,
        clearCache,
        refreshCurrentPageSummary,
        getBatchDetails,
        clearBatchDetailCache,
      }}
    >
      {children}
    </ProcessingBatchCacheContext.Provider>
  );
}

export function useProcessingBatchCache() {
  const context = useContext(ProcessingBatchCacheContext);
  if (context === undefined) {
    throw new Error('useProcessingBatchCache must be used within a ProcessingBatchCacheProvider');
  }
  return context;
}

```

### apps\web\app\(dashboard)\processing-batches\add\page.tsx:
```
'use client';

import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Button } from '@workspace/ui/components/button';
import { Progress } from '@workspace/ui/components/progress';
import { useEffect } from 'react';

import { SelectCriteriaStep } from './components/select-criteria-step';
import { SelectProcurementsStep } from './components/select-procurements-step';
import { FirstStageDetailsStep } from './components/first-stage-details-step';
import { ReviewAndSubmitStep } from './components/review-submit-step';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import axios from 'axios';
import type { FieldError, FieldErrorsImpl, Merge } from 'react-hook-form'; // Import types for error messages

export default function AddProcessingBatchPage() {
  const router = useRouter();
  const {
    activeStep,
    goToNextStep,
    goToPreviousTab,
    setInitialCriteria,
    initialCrop, // Use initial for criteria step
    initialLotNo, // Use initial for criteria step
    selectedProcurementIds,
    firstStageDetails,
    isSubmitting,
    setIsSubmitting,
    resetForm,
    form: currentStepForm,
    lockedCrop, // Use locked values for submission and later steps
    lockedLotNo,
    lockedProcuredForm,
  } = useProcessingBatchFormStore();

  useEffect(() => {
    return () => {
      // resetForm(); // Consider if this is desired on unmount
    };
  }, [resetForm]);

  const steps = [
    { id: 'selectCriteria', title: 'Select Criteria', progress: 25 },
    { id: 'selectProcurements', title: 'Select Procurements', progress: 50 },
    { id: 'firstStageDetails', title: 'First Stage Details (P1)', progress: 75 },
    { id: 'review', title: 'Review & Submit', progress: 100 },
  ];

  const currentStepConfig = steps.find(s => s.id === activeStep);

  const getFirstErrorMessage = (errors: Partial<Readonly<FieldErrorsImpl<any>>>): string | undefined => {
    if (errors.crop && typeof errors.crop.message === 'string') return errors.crop.message;
    if (errors.lotNo && typeof errors.lotNo.message === 'string') return errors.lotNo.message;
    // Check for schema level refine error (which might not have a specific field path if path is ["_error"] or just one path is given in refine)
    const refineErrorKey = Object.keys(errors).find(
      key => errors[key] && typeof errors[key]?.message === 'string' && !errors[key]?.ref
    );
    if (refineErrorKey && errors[refineErrorKey] && typeof errors[refineErrorKey]?.message === 'string') {
      return errors[refineErrorKey]?.message as string;
    }
    return undefined;
  };

  const handleNext = async () => {
    if (activeStep === 'selectCriteria') {
      if (currentStepForm) {
        const isValid = await currentStepForm.trigger();
        if (!isValid) {
          const firstError = getFirstErrorMessage(currentStepForm.formState.errors);
          toast.error(firstError || 'Please provide valid criteria (at least Crop or Lot No).'); // Updated message
          return;
        }
        const criteriaValues = currentStepForm.getValues();
        // criteriaValues.crop and criteriaValues.lotNo can be null/undefined here
        setInitialCriteria({
          crop: criteriaValues.crop || null,
          lotNo: typeof criteriaValues.lotNo === 'number' ? criteriaValues.lotNo : null,
        });
      } else {
        // This case should ideally not be hit if setForm works correctly
        setInitialCriteria({ crop: null, lotNo: null });
      }
    }
    if (activeStep === 'selectProcurements' && selectedProcurementIds.length === 0) {
      toast.error('Please select at least one procurement to form the batch.');
      return;
    }

    if (activeStep === 'firstStageDetails' && currentStepForm) {
      const isValid = await currentStepForm.trigger();
      if (!isValid) {
        toast.error(
          getFirstErrorMessage(currentStepForm.formState.errors) || 'Please fill in all required P1 details.'
        );
        return;
      }
      useProcessingBatchFormStore.getState().setFirstStageDetails(currentStepForm.getValues());
    }
    goToNextStep();
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      const p1Date = firstStageDetails.dateOfProcessing;
      let p1DateString: string | undefined = undefined;

      if (p1Date instanceof Date) {
        p1DateString = p1Date.toISOString();
      } else if (typeof p1Date === 'string') {
        try {
          p1DateString = new Date(p1Date).toISOString();
        } catch (e) {
          /* will be caught below */
        }
      }

      if (!p1DateString) {
        toast.error('P1 Date of Processing is missing or invalid.');
        setIsSubmitting(false);
        return;
      }
      if (!firstStageDetails.processMethod) {
        toast.error('P1 Process Method is missing.');
        setIsSubmitting(false);
        return;
      }
      if (!firstStageDetails.doneBy) {
        toast.error('P1 Done By is missing.');
        setIsSubmitting(false);
        return;
      }
      if (!lockedCrop || typeof lockedLotNo !== 'number' || !lockedProcuredForm) {
        toast.error(
          'Batch criteria (Crop, Lot No, Procured Form) are not fully determined. Please select procurements.'
        );
        setIsSubmitting(false);
        return;
      }

      const payload = {
        crop: lockedCrop,
        lotNo: lockedLotNo, // Already ensured it's a number in previous step's logic if it came from form
        procurementIds: selectedProcurementIds,
        firstStageDetails: {
          processMethod: firstStageDetails.processMethod,
          dateOfProcessing: p1DateString,
          doneBy: firstStageDetails.doneBy,
        },
      };

      const response = await axios.post('/api/processing-batches', payload, { withCredentials: true });

      if (response.status === 201) {
        toast.success('Processing Batch created successfully!');
        const dataChangedEvent = new CustomEvent('processingBatchDataChanged');
        document.dispatchEvent(dataChangedEvent);
        resetForm();
        router.push('/processing-batches');
      } else {
        throw new Error(response.data.error || 'Failed to create processing batch');
      }
    } catch (error: any) {
      console.error('Error creating processing batch:', error);
      const errorMsg =
        error.response?.data?.details?.[0]?.message ||
        error.response?.data?.error ||
        error.message ||
        'Something went wrong';
      toast.error(`Error: ${errorMsg}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handlePrevious = () => {
    goToPreviousTab();
  };

  return (
    <div className="p-4 md:p-6 max-w-4xl mx-auto space-y-6">
      <h1 className="text-2xl font-bold">Add New Processing Batch</h1>
      <Progress value={currentStepConfig?.progress || 0} className="w-full" />
      <p className="text-sm text-muted-foreground">Step: {currentStepConfig?.title}</p>
      <div className="mt-6">
        {activeStep === 'selectCriteria' && <SelectCriteriaStep />}
        {activeStep === 'selectProcurements' && <SelectProcurementsStep />}
        {activeStep === 'firstStageDetails' && <FirstStageDetailsStep />}
        {activeStep === 'review' && <ReviewAndSubmitStep />}
      </div>
      <div className="flex justify-between mt-8">
        <Button variant="outline" onClick={handlePrevious} disabled={activeStep === 'selectCriteria' || isSubmitting}>
          Previous
        </Button>
        {activeStep !== 'review' ? (
          <Button onClick={handleNext} disabled={isSubmitting}>
            Next
          </Button>
        ) : (
          <Button onClick={handleSubmit} disabled={isSubmitting}>
            {isSubmitting ? 'Submitting...' : 'Create Batch & Start P1'}
          </Button>
        )}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\select-criteria-step.tsx:
```
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Form, FormControl, FormField, FormItem, FormMessage } from '@workspace/ui/components/form';
import { useEffect } from 'react';

const CROP_OPTIONS = ['Turmeric', 'Coffee', 'Ginger', 'Pepper'] as const;

const criteriaSchema = z
  .object({
    crop: z.string().optional().nullable(),
    lotNo: z.coerce
      .number()
      .int()
      .min(1, 'Lot number must be a positive integer')
      .max(3, 'Only 1, 2, 3 Lot Numbers are available')
      .optional()
      .nullable(),
  })
  .refine(data => !!data.crop || (typeof data.lotNo === 'number' && !isNaN(data.lotNo)), {
    message: 'Either Crop or Lot Number (or both) must be provided.',
    path: ['crop'],
  });

type CriteriaFormValues = z.infer<typeof criteriaSchema>;

export function SelectCriteriaStep() {
  const { initialCrop, initialLotNo, setForm } = useProcessingBatchFormStore();

  const form = useForm<CriteriaFormValues>({
    resolver: zodResolver(criteriaSchema),
    defaultValues: {
      crop: initialCrop || null,
      lotNo: initialLotNo || null,
    },
  });

  useEffect(() => {
    if (setForm) {
      setForm(form as any);
    }
    return () => {
      if (setForm) {
        setForm(null);
      }
    };
  }, [form, setForm]);

  useEffect(() => {
    form.reset({
      crop: initialCrop || null,
      lotNo: initialLotNo || null,
    });
  }, [initialCrop, initialLotNo, form]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 1: Select Initial Criteria (Optional)</CardTitle>
        <CardDescription>
          Specify Crop and/or Lot Number to pre-filter procurements. If both are left blank, you'll define criteria
          based on your first procurement choice in the next step. To pre-filter, at least one field must be entered.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form className="space-y-6">
            <FormField
              control={form.control}
              name="crop"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="crop">Crop Name (Optional)</Label>
                  <Select
                    onValueChange={value => field.onChange(value === 'NONE_SELECTED_VALUE' ? null : value)}
                    value={field.value || undefined} // Pass undefined for placeholder
                  >
                    <FormControl>
                      <SelectTrigger id="crop">
                        <SelectValue placeholder="Select a crop (optional)" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {CROP_OPTIONS.map(cropName => (
                        <SelectItem key={cropName} value={cropName}>
                          {cropName}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                  {/* The refine error (if path is "crop") will show via FormMessage if crop field itself also has an error.
                      If only refine fails, FormMessage for crop might not show it if crop field input is valid on its own.
                      The parent page's toast error for this step is a more reliable way to show the refine error.
                  */}
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="lotNo"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="lotNo">Lot Number (Optional)</Label>
                  <FormControl>
                    <Input
                      id="lotNo"
                      type="number"
                      placeholder="Enter lot number (optional)"
                      value={field.value === null || field.value === undefined ? '' : String(field.value)}
                      onChange={e => {
                        const val = e.target.value;
                        field.onChange(val === '' ? null : isNaN(parseInt(val, 4)) ? null : parseInt(val, 4));
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            {/* Displaying the refine error specifically if it's attached to form.formState.errors.crop 
                and there's no other message from the field's own validators.
                This logic can be tricky. The toast in the parent is often clearer for overall step validation.
            */}
            {form.formState.errors.crop &&
              form.formState.errors.crop.type === 'manual' && ( // refine errors often appear as 'manual'
                <p className="text-sm text-red-500 mt-1">{form.formState.errors.crop.message}</p>
              )}
            {/* Or more generally, if the refine error is the *only* error for crop: */}
            {form.formState.errors.crop &&
              Object.keys(form.formState.errors.crop).length === 1 &&
              form.formState.errors.crop.message && (
                <p className="text-sm text-red-500 mt-1">{form.formState.errors.crop.message}</p>
              )}
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\first-stage-details-step.tsx:
```
'use client';

import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Label } from '@workspace/ui/components/label';
import { Input } from '@workspace/ui/components/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Form, FormControl, FormField, FormItem, FormMessage } from '@workspace/ui/components/form'; // Assuming FormLabel is part of this
import { Popover, PopoverContent, PopoverTrigger } from '@workspace/ui/components/popover';
import { Button } from '@workspace/ui/components/button';
import { Calendar } from '@workspace/ui/components/calendar';
import { CalendarIcon } from 'lucide-react';
import { cn } from '@workspace/ui/lib/utils';
import { format } from 'date-fns';
import { useEffect } from 'react';

const firstStageFormStepSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z.date({
    required_error: 'Date of Processing is required',
    invalid_type_error: "That's not a valid date!",
  }),
  doneBy: z.string().min(1, 'Person responsible for P1 is required'),
});

type FirstStageFormValues = z.infer<typeof firstStageFormStepSchema>;

export function FirstStageDetailsStep() {
  const { firstStageDetails, setFirstStageDetails, form: zustandForm, setForm } = useProcessingBatchFormStore();

  const form = useForm<FirstStageFormValues>({
    resolver: zodResolver(firstStageFormStepSchema),
    defaultValues: {
      processMethod: firstStageDetails.processMethod || 'wet',
      dateOfProcessing:
        firstStageDetails.dateOfProcessing instanceof Date
          ? firstStageDetails.dateOfProcessing
          : firstStageDetails.dateOfProcessing
            ? new Date(firstStageDetails.dateOfProcessing as string)
            : new Date(),
      doneBy: firstStageDetails.doneBy || '',
    },
  });

  useEffect(() => {
    if (zustandForm !== form) {
      setForm(form as any);
    }
    const zustandDate = firstStageDetails.dateOfProcessing;
    form.reset({
      processMethod: firstStageDetails.processMethod || 'wet',
      dateOfProcessing:
        zustandDate instanceof Date ? zustandDate : zustandDate ? new Date(zustandDate as string) : new Date(),
      doneBy: firstStageDetails.doneBy || '',
    });
  }, [firstStageDetails, form, zustandForm, setForm]);

  const handleValueChangeAndSyncToZustand = () => {
    const values = form.getValues();
    setFirstStageDetails(values);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 3: First Processing Stage (P1) Details</CardTitle>
        <CardDescription>Enter the details for the initial processing stage of this batch.</CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onChange={handleValueChangeAndSyncToZustand} className="space-y-6">
            <FormField
              control={form.control}
              name="processMethod"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="processMethod">Process Method</Label>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger id="processMethod">
                        <SelectValue placeholder="Select process method" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="wet">Wet</SelectItem>
                      <SelectItem value="dry">Dry</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="dateOfProcessing"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <Label htmlFor="dateOfProcessing">Date of Processing (P1)</Label>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          id="dateOfProcessing"
                          variant="outline"
                          className={cn('w-full pl-3 text-left font-normal', !field.value && 'text-muted-foreground')}
                        >
                          {field.value ? format(field.value, 'PPP') : <span>Pick a date</span>}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar mode="single" selected={field.value} onSelect={field.onChange} initialFocus />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="doneBy"
              render={({ field }) => (
                <FormItem>
                  <Label htmlFor="doneBy">Done By (Responsible Person/Team)</Label>
                  <FormControl>
                    <Input id="doneBy" placeholder="Enter name or team" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\select-procurements-step.tsx:
```
'use client';

import { useEffect, useState, useMemo } from 'react';
import axios from 'axios';
import { useProcessingBatchFormStore, type ProcurementWithFarmerForStore } from '@/app/stores/processing-batch-form'; // Import the type
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Checkbox } from '@workspace/ui/components/checkbox';
import { Input } from '@workspace/ui/components/input';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { toast } from 'sonner';
import { format } from 'date-fns';
import { Badge } from '@workspace/ui/components/badge';

interface DisplayProcurement extends ProcurementWithFarmerForStore {
  isSelectableBasedOnLock: boolean;
  matchesSearchTerm: boolean;
}

export function SelectProcurementsStep() {
  const {
    initialCrop,
    initialLotNo,
    availableProcurements, // Now ProcurementWithFarmerForStore[] from Zustand
    selectedProcurementIds,
    setAvailableProcurements,
    toggleSelectedProcurement,
    lockedCrop,
    lockedLotNo,
    lockedProcuredForm,
    filterCriteriaLocked,
  } = useProcessingBatchFormStore();

  const [isLoading, setIsLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    const fetchProcurements = async () => {
      setIsLoading(true);
      try {
        const params: any = {};
        if (initialCrop) params.crop = initialCrop;
        if (initialLotNo) params.lotNo = initialLotNo;

        // The backend response should match ProcurementWithFarmerForStore structure for the farmer field
        const response = await axios.get<{ procurements: ProcurementWithFarmerForStore[] }>(
          `/api/procurements/unbatched`,
          { params, withCredentials: true }
        );
        setAvailableProcurements(response.data.procurements);
      } catch (error) {
        console.error('Error fetching unbatched procurements:', error);
        toast.error('Failed to load unbatched procurements.');
        setAvailableProcurements([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchProcurements();
  }, [initialCrop, initialLotNo, setAvailableProcurements]);

  const displayListItems = useMemo((): DisplayProcurement[] => {
    const lowerSearchTerm = searchTerm.trim().toLowerCase();

    return availableProcurements.map((p: ProcurementWithFarmerForStore) => {
      // Explicitly type 'p'
      let isSelectableBasedOnLock = true;
      if (filterCriteriaLocked) {
        if (lockedCrop && p.crop !== lockedCrop) isSelectableBasedOnLock = false;
        if (lockedLotNo && p.lotNo !== lockedLotNo) isSelectableBasedOnLock = false;
        if (lockedProcuredForm && p.procuredForm !== lockedProcuredForm) isSelectableBasedOnLock = false;
      }

      let matchesSearchTerm = true;
      if (lowerSearchTerm) {
        matchesSearchTerm =
          p.farmer.name.toLowerCase().includes(lowerSearchTerm) || // Safe now
          p.procurementNumber.toLowerCase().includes(lowerSearchTerm) ||
          p.id.toString().includes(lowerSearchTerm) ||
          p.crop.toLowerCase().includes(lowerSearchTerm) ||
          p.procuredForm.toLowerCase().includes(lowerSearchTerm);
      }

      // p already includes the farmer object, so the spread is fine.
      return { ...p, isSelectableBasedOnLock, matchesSearchTerm };
    });
  }, [availableProcurements, searchTerm, filterCriteriaLocked, lockedCrop, lockedLotNo, lockedProcuredForm]);

  const itemsToRender = useMemo(() => {
    return displayListItems.filter(
      item => selectedProcurementIds.includes(item.id) || (item.isSelectableBasedOnLock && item.matchesSearchTerm)
    );
  }, [displayListItems, selectedProcurementIds]);

  const totalSelectedQuantity = useMemo(() => {
    return availableProcurements
      .filter(p => selectedProcurementIds.includes(p.id))
      .reduce((sum, p) => sum + p.quantity, 0);
  }, [availableProcurements, selectedProcurementIds]);

  const handleToggleSelection = (procurement: ProcurementWithFarmerForStore) => {
    // Expect the correct type
    toggleSelectedProcurement(procurement);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 2: Select Procurements</CardTitle>
        <CardDescription>
          {filterCriteriaLocked
            ? `Select procurements for batch: Crop: ${lockedCrop}, Lot: ${lockedLotNo}, Form: ${lockedProcuredForm}.`
            : initialCrop || initialLotNo
              ? `Showing initial procurements for: ${initialCrop || 'Any Crop'}, Lot: ${initialLotNo || 'Any Lot'}. First selection will lock full criteria.`
              : `Select your first procurement to set the Crop, Lot No, and Procured Form for this batch.`}
        </CardDescription>
        {filterCriteriaLocked && (
          <div className="mt-2 flex flex-wrap gap-2">
            <Badge variant="secondary">Crop: {lockedCrop}</Badge>
            <Badge variant="secondary">Lot: {lockedLotNo}</Badge>
            <Badge variant="secondary">Form: {lockedProcuredForm}</Badge>
          </div>
        )}
        {totalSelectedQuantity > 0 && (
          <p className="text-sm font-medium mt-2">Total Selected Quantity: {totalSelectedQuantity.toFixed(2)} kg</p>
        )}
      </CardHeader>
      <CardContent>
        <div className="mb-4">
          <Input
            placeholder="Filter list by Farmer, Proc. No., etc..."
            value={searchTerm}
            onChange={e => setSearchTerm(e.target.value)}
          />
        </div>
        {isLoading && <p className="text-center py-4">Loading procurements...</p>}
        {!isLoading && itemsToRender.length === 0 && (
          <p className="text-muted-foreground text-center py-4">
            No unbatched procurements found matching the criteria.
          </p>
        )}
        {!isLoading && itemsToRender.length > 0 && (
          <ScrollArea className="h-[300px] border rounded-md">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[50px]">Select</TableHead>
                  <TableHead>Proc. No.</TableHead>
                  <TableHead>Farmer</TableHead>
                  <TableHead>Crop</TableHead>
                  <TableHead>Proc. Form</TableHead>
                  <TableHead>Lot No.</TableHead>
                  <TableHead>Qty (kg)</TableHead>
                  <TableHead>Date</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {itemsToRender.map(proc => {
                  // proc is now DisplayProcurement, which includes farmer
                  const isChecked = selectedProcurementIds.includes(proc.id);
                  const isDisabledForSelection = filterCriteriaLocked && !proc.isSelectableBasedOnLock && !isChecked;

                  return (
                    <TableRow
                      key={proc.id}
                      data-state={isChecked && 'selected'}
                      className={isDisabledForSelection ? 'opacity-50' : ''}
                    >
                      <TableCell>
                        <Checkbox
                          id={`proc-${proc.id}`}
                          checked={isChecked}
                          onCheckedChange={() => handleToggleSelection(proc)}
                          disabled={isDisabledForSelection}
                        />
                      </TableCell>
                      <TableCell className="font-medium">{proc.procurementNumber}</TableCell>
                      <TableCell>{proc.farmer.name}</TableCell> {/* Safe now */}
                      <TableCell>{proc.crop}</TableCell>
                      <TableCell>{proc.procuredForm}</TableCell>
                      <TableCell>{proc.lotNo}</TableCell>
                      <TableCell className="text-right">{proc.quantity.toFixed(2)}</TableCell>
                      <TableCell>{format(new Date(proc.date), 'dd/MM/yyyy')}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </ScrollArea>
        )}
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\processing-batches\add\components\review-submit-step.tsx:
```
'use client';

import { useProcessingBatchFormStore } from '@/app/stores/processing-batch-form';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@workspace/ui/components/card';
import { Separator } from '@workspace/ui/components/separator';
import { useMemo } from 'react';
import { format } from 'date-fns';
import type { Procurement } from '@chaya/shared';

interface ProcurementWithFarmerForReview extends Procurement {
  farmer?: { name?: string };
}

export function ReviewAndSubmitStep() {
  const {
    lockedCrop, // Use locked values for review
    lockedLotNo,
    lockedProcuredForm,
    availableProcurements,
    selectedProcurementIds,
    firstStageDetails,
  } = useProcessingBatchFormStore();

  const selectedProcsDetails = useMemo(() => {
    return availableProcurements.filter(p => selectedProcurementIds.includes(p.id));
  }, [availableProcurements, selectedProcurementIds]);

  const totalInitialQuantity = useMemo(() => {
    return selectedProcsDetails.reduce((sum, p) => sum + p.quantity, 0);
  }, [selectedProcsDetails]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Step 4: Review and Submit</CardTitle>
        <CardDescription>
          Please review all details before creating the processing batch and its first stage (P1).
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div>
          <h3 className="text-lg font-semibold">Batch Criteria (Locked)</h3>
          <Separator className="my-2" />
          <div className="grid grid-cols-2 gap-2">
            <p className="font-medium">Crop:</p>
            <p>{lockedCrop || 'Not Set'}</p>
            <p className="font-medium">Lot Number:</p>
            <p>{lockedLotNo || 'Not Set'}</p>
            <p className="font-medium">Procured Form:</p>
            <p>{lockedProcuredForm || 'Not Set'}</p>
          </div>
        </div>

        <div>
          <h3 className="text-lg font-semibold">Selected Procurements ({selectedProcurementIds.length})</h3>
          <Separator className="my-2" />
          {selectedProcsDetails.length > 0 ? (
            <ul className="list-disc list-inside space-y-1 text-sm max-h-40 overflow-y-auto">
              {selectedProcsDetails.map(p => (
                <li key={p.id}>
                  Proc. No: {p.procurementNumber} - {p.quantity}kg - Farmer:{' '}
                  {(p as ProcurementWithFarmerForReview).farmer?.name || 'N/A'}
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-muted-foreground">No procurements selected.</p>
          )}
          <p className="font-semibold mt-2">Total Initial Batch Quantity: {totalInitialQuantity.toFixed(2)} kg</p>
        </div>

        <div>
          <h3 className="text-lg font-semibold">First Stage (P1) Details</h3>
          <Separator className="my-2" />
          <div className="grid grid-cols-2 gap-2">
            <p className="font-medium">Process Method:</p>
            <p>{firstStageDetails.processMethod}</p>
            <p className="font-medium">Date of Processing:</p>
            <p>
              {firstStageDetails.dateOfProcessing
                ? format(new Date(firstStageDetails.dateOfProcessing), 'PPP')
                : 'Not set'}
            </p>
            <p className="font-medium">Done By:</p>
            <p>{firstStageDetails.doneBy}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

### apps\web\app\(dashboard)\procurements\page.tsx:
```
import { Suspense } from 'react';
import ProcurementsHeader from './components/procurements-header';
import Search from './components/search';
import ProcurementsTable from './components/procurements-table';
import Pagination from './components/pagination';
import Loading from './loading';
import { ProcurementsCacheProvider } from './context/procurement-cache-context';

interface PageProps {
  searchParams?: Promise<{
    query?: string;
    page?: string;
  }>;
}

export default async function ProcurementsPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const query = params?.query || '';
  const currentPage = Number(params?.page) || 1;

  return (
    <ProcurementsCacheProvider>
      <div className="space-y-6 p-4">
        <ProcurementsHeader />

        <div className="flex items-center justify-between gap-2">
          <Search placeholder="Enter Proc. No., crop, farmer name" />
        </div>

        <Suspense key={query + currentPage.toString()} fallback={<Loading />}>
          <ProcurementsTableWithCache query={query} currentPage={currentPage} />
        </Suspense>
      </div>
    </ProcurementsCacheProvider>
  );
}

async function ProcurementsTableWithCache({ query, currentPage }: { query: string; currentPage: number }) {
  return (
    <>
      <ProcurementsTable query={query} currentPage={currentPage} />
      <PaginationWithCache query={query} />
    </>
  );
}

async function PaginationWithCache({ query }: { query: string }) {
  return <Pagination query={query} />;
}

```

### apps\web\app\(dashboard)\procurements\loading.tsx:
```
export default function Loading() {
  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
        <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
      </div>
      <div className="rounded-md border">
        <div className="h-12 border-b bg-secondary px-4 flex items-center">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
          ))}
        </div>
        {Array.from({ length: 10 }).map((_, i) => (
          <div key={i} className="border-b px-4 py-4 flex items-center">
            {Array.from({ length: 6 }).map((_, j) => (
              <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-form-dialog.tsx:
```
'use client';

import { ProcurementFormProvider } from '@/app/providers/procurement-form-provider';
import type { ProcurementWithRelations } from '../lib/types';
import { ProcurementForm } from '@/app/components/procurement-form/procurement-form';

interface ProcurementFormDialogProps {
  mode: 'add' | 'edit';
  procurement?: ProcurementWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function ProcurementFormDialog({ mode, procurement, open, onOpenChange }: ProcurementFormDialogProps) {
  return (
    <ProcurementFormProvider initialData={procurement} mode={mode}>
      <ProcurementForm mode={mode} open={open} onOpenChange={onOpenChange} procurementId={procurement?.id} />
    </ProcurementFormProvider>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\search.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Input } from '@workspace/ui/components/input';
import { useEffect, useState } from 'react';
import { useDebounce } from '@/app/hooks/use-debounce';

interface SearchProps {
  placeholder?: string;
}

export default function Search({ placeholder }: SearchProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [searchTerm, setSearchTerm] = useState(searchParams.get('query') || '');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    const params = new URLSearchParams(searchParams);

    if (debouncedSearchTerm) {
      params.set('query', debouncedSearchTerm);
    } else {
      params.delete('query');
    }

    params.set('page', '1'); // Reset to first page on search
    // router.push(`?${params.toString()}`);
  }, [debouncedSearchTerm, router, searchParams]);

  return (
    <div className="relative w-full md:w-80">
      <Input
        placeholder={placeholder || 'Search...'}
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        className="w-full"
      />
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-context-menu.tsx:
```
'use client';

import React, { useState } from 'react';
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuSeparator,
  ContextMenuTrigger,
} from '@workspace/ui/components/context-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Eye, Pencil, Trash2 } from 'lucide-react';
import { toast } from 'sonner';
import type { ProcurementWithRelations } from '../lib/types';
import { deleteProcurement } from '../lib/actions';

interface ProcurementContextMenuProps {
  children: React.ReactNode;
  procurement: ProcurementWithRelations;
  onEdit: () => void;
  isAdmin: boolean;
}

export function ProcurementContextMenu({ children, procurement, onEdit, isAdmin }: ProcurementContextMenuProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleView = () => {
    const event = new CustomEvent('viewProcurement', {
      detail: { procurement },
    });
    document.dispatchEvent(event);
  };

  const handleDelete = async () => {
    try {
      setIsDeleting(true);
      const result = await deleteProcurement(procurement.id);

      if (result.success) {
        toast.success('Procurement deleted', {
          description: `Proc. No. ${procurement.procurementNumber} has been successfully deleted.`,
        });

        const dataChangedEvent = new CustomEvent('procurementDataChanged');
        document.dispatchEvent(dataChangedEvent);
      } else {
        toast.error('Error', {
          description: result.error || 'Failed to delete procurement.',
        });
      }

      setShowDeleteDialog(false);
    } catch (error) {
      toast.error('Error', {
        description: 'An unexpected error occurred while deleting the procurement.',
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <ContextMenu>
        <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>
        <ContextMenuContent className="w-48">
          <ContextMenuItem onClick={handleView}>
            <Eye className="mr-2 h-4 w-4" />
            View Details
          </ContextMenuItem>

          {isAdmin && (
            <>
              <ContextMenuSeparator />
              <ContextMenuItem onClick={onEdit}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit Procurement
              </ContextMenuItem>
              <ContextMenuItem
                onClick={() => setShowDeleteDialog(true)}
                className="text-destructive focus:text-destructive"
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete Procurement
              </ContextMenuItem>
            </>
          )}
        </ContextMenuContent>
      </ContextMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete this procurement?</AlertDialogTitle>
            <AlertDialogDescription>
              {`This action cannot be undone. This will permanently delete procurement ${procurement.procurementNumber}.`}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\pagination.tsx:
```
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { Button } from '@workspace/ui/components/button';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { useProcurementsCache } from '../context/procurement-cache-context';
import { useEffect, useState } from 'react';
import { toast } from 'sonner';

interface PaginationProps {
  query: string;
}

export default function Pagination({ query }: PaginationProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { fetchTotalPages } = useProcurementsCache();

  const [totalPages, setTotalPages] = useState(1);
  const [loading, setLoading] = useState(true);

  const currentPage = Number(searchParams.get('page') || '1');

  useEffect(() => {
    async function loadTotalPages() {
      setLoading(true);
      try {
        const pages = await fetchTotalPages(query);
        setTotalPages(pages);
      } catch (error) {
        toast.error('Failed to load pagination data. Please try again.');
      } finally {
        setLoading(false);
      }
    }

    loadTotalPages();
  }, [fetchTotalPages, query]);

  const createPageURL = (pageNumber: number | string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', pageNumber.toString());
    return `?${params.toString()}`;
  };

  if (loading) {
    return (
      <div className="flex justify-center mt-8 space-x-2">
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
        <div className="h-10 w-10 rounded-md bg-gray-200 animate-pulse"></div>
      </div>
    );
  }

  if (totalPages <= 1) {
    return null;
  }

  return (
    <div className="flex items-center justify-between px-2 mt-4">
      <div className="text-sm text-muted-foreground">
        Page {currentPage} of {totalPages}
      </div>
      <div className="flex items-center space-x-2">
        <Button variant="outline" size="icon" onClick={() => router.push(createPageURL(1))} disabled={currentPage <= 1}>
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage - 1))}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(currentPage + 1))}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => router.push(createPageURL(totalPages))}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\column-filter.tsx:
```
'use client';

import type { Table } from '@tanstack/react-table';
import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import { SlidersHorizontal } from 'lucide-react';

interface ColumnFilterProps<TData> {
  table: Table<TData>;
}

export function ColumnFilter<TData>({ table }: ColumnFilterProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className="h-8">
          <SlidersHorizontal className="mr-2 h-4 w-4" />
          View
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[180px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(column => typeof column.accessorFn !== 'undefined' && column.getCanHide())
          .map(column => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={value => column.toggleVisibility(!!value)}
              >
                {column.id}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurements-header.tsx:
```
'use client';

import { Button } from '@workspace/ui/components/button';
import { FileDown, PlusCircle } from 'lucide-react';
import { useState } from 'react';
import { ProcurementFormDialog } from './procurement-form-dialog';
import { useAuth } from '@/app/providers/auth-provider';

export default function ProcurementsHeader() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';

  const [showAddDialog, setShowAddDialog] = useState(false);

  const handleExport = () => {
    console.log('Export data clicked');
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Procurement Dashboard</h1>
        <p className="text-gray-600">Manage and track crop procurements</p>
      </div>

      <div className="flex items-center gap-2">
        {isAdmin && (
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            className="h-9 bg-purple-500 text-white hover:bg-purple-600 hover:text-white"
          >
            <FileDown className="mr-2 h-4 w-4" />
            Export Data
          </Button>
        )}

        <Button
          size="sm"
          onClick={() => setShowAddDialog(true)}
          className="h-9 bg-green-500 text-white hover:bg-green-600"
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          Add Procurement
        </Button>

        <ProcurementFormDialog mode="add" open={showAddDialog} onOpenChange={setShowAddDialog} />
      </div>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurement-details-dialog.tsx:
```
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import { Button } from '@workspace/ui/components/button';
import type { ProcurementWithRelations } from '../lib/types';
import { format } from 'date-fns';
import { Separator } from '@workspace/ui/components/separator';
import { ScrollArea } from '@workspace/ui/components/scroll-area';

interface ProcurementDetailsDialogProps {
  procurement: ProcurementWithRelations;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function ProcurementDetailsDialog({ procurement, open, onOpenChange }: ProcurementDetailsDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
        <DialogHeader>
          <DialogTitle>Procurement Details - {procurement.procurementNumber}</DialogTitle>
        </DialogHeader>

        <ScrollArea className="flex-grow mt-4 pr-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
            <div className="space-y-4">
              <div>
                <h3 className="text-lg font-semibold">Item Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Procurement No.:</span>
                  <span>{procurement.procurementNumber}</span>
                  <span className="font-medium text-muted-foreground">Crop:</span>
                  <span>{procurement.crop}</span>
                  <span className="font-medium text-muted-foreground">Procured Form:</span>
                  <span>{procurement.procuredForm}</span>
                  <span className="font-medium text-muted-foreground">Speciality:</span>
                  <span>{procurement.speciality}</span>
                  <span className="font-medium text-muted-foreground">Quantity:</span>
                  <span>{procurement.quantity} kg</span>
                  <span className="font-medium text-muted-foreground">Lot Number:</span>
                  <span>{procurement.lotNo}</span>
                </div>
              </div>

              <div>
                <h3 className="text-lg font-semibold mt-4">Procurement Details</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Date:</span>
                  <span>{format(new Date(procurement.date), 'dd/MM/yyyy')}</span>
                  <span className="font-medium text-muted-foreground">Time:</span>
                  <span>{format(new Date(procurement.time), 'hh:mm a')}</span>
                  <span className="font-medium text-muted-foreground">Procured By:</span>
                  <span>{procurement.procuredBy}</span>
                  <span className="font-medium text-muted-foreground">Vehicle Number:</span>
                  <span>{procurement.vehicleNo || 'N/A'}</span>
                </div>
              </div>
            </div>
            <div className="space-y-4">
              <div>
                <h3 className="text-lg font-semibold">Farmer Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Name:</span>
                  <span>{procurement.farmer.name}</span>
                  <span className="font-medium text-muted-foreground">Village:</span>
                  <span>{procurement.farmer.village}</span>
                  <span className="font-medium text-muted-foreground">Panchayath:</span>
                  <span>{procurement.farmer.panchayath}</span>
                  <span className="font-medium text-muted-foreground">Mandal:</span>
                  <span>{procurement.farmer.mandal}</span>
                </div>
              </div>

              <div>
                <h3 className="text-lg font-semibold mt-4">System Information</h3>
                <Separator className="my-2" />
                <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                  <span className="font-medium text-muted-foreground">Created At:</span>
                  <span>{format(new Date(procurement.createdAt), 'dd/MM/yyyy hh:mm a')}</span>
                  <span className="font-medium text-muted-foreground">Last Updated:</span>
                  <span>{format(new Date(procurement.updatedAt), 'dd/MM/yyyy hh:mm a')}</span>
                </div>
              </div>
            </div>
          </div>
        </ScrollArea>
        <DialogFooter className="mt-auto pt-4">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\procurements\components\procurements-table.tsx:
```
'use client';

import {
  flexRender,
  getCoreRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getPaginationRowModel,
  useReactTable,
} from '@tanstack/react-table';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { columns, defaultVisibleColumns } from '../lib/columns';
import { ColumnFilter } from './column-filter';
import { useState, useEffect } from 'react';
import { ScrollArea } from '@workspace/ui/components/scroll-area';
import { useAuth } from '@/app/providers/auth-provider';
import { ProcurementContextMenu } from './procurement-context-menu';
import { ProcurementDetailsDialog } from './procurement-details-dialog';
import { ProcurementFormDialog } from './procurement-form-dialog';
import { bulkDeleteProcurements } from '../lib/actions';
import { Button } from '@workspace/ui/components/button';
import { RefreshCw, TrashIcon } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { toast } from 'sonner';
import { useProcurementsCache } from '../context/procurement-cache-context';
import type { ProcurementWithRelations } from '../lib/types';

interface ProcurementsTableProps {
  query: string;
  currentPage: number;
}

export default function ProcurementsTable({ query, currentPage }: ProcurementsTableProps) {
  const { user } = useAuth();
  const isAdmin = user?.role === 'ADMIN';
  const { fetchProcurements, prefetchPages, refreshCurrentPage } = useProcurementsCache();

  const [procurements, setProcurements] = useState<ProcurementWithRelations[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [viewingProcurement, setViewingProcurement] = useState<ProcurementWithRelations | null>(null);
  const [editingProcurement, setEditingProcurement] = useState<ProcurementWithRelations | null>(null);
  const [showViewDialog, setShowViewDialog] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showBulkDeleteDialog, setShowBulkDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const [rowSelection, setRowSelection] = useState({});

  const [columnVisibility, setColumnVisibility] = useState(() => {
    const initialVisibility: Record<string, boolean> = {};
    defaultVisibleColumns.forEach(col => {
      initialVisibility[col] = true;
    });
    return initialVisibility;
  });

  const loadData = async () => {
    setLoading(true);
    try {
      const data = await fetchProcurements(currentPage, query);
      setProcurements(data);

      const pagesToPrefetch = [];
      if (currentPage > 1) pagesToPrefetch.push(currentPage - 1);
      if (currentPage < 100) pagesToPrefetch.push(currentPage + 1);
      if (pagesToPrefetch.length > 0) {
        prefetchPages(Math.min(...pagesToPrefetch), Math.max(...pagesToPrefetch), query);
      }
    } catch (error) {
      toast.error("Failed to fetch procurements' data. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    if (refreshing) return;

    setRefreshing(true);
    try {
      const freshData = await refreshCurrentPage(currentPage, query);
      setProcurements(freshData);
      toast.success('Data refreshed successfully');
      setRowSelection({});
    } catch (error) {
      toast.error('Failed to refresh data. Please try again.');
    } finally {
      setRefreshing(false);
    }
  };

  useEffect(() => {
    loadData();
  }, [fetchProcurements, prefetchPages, currentPage, query]);

  const table = useReactTable({
    data: procurements,
    columns,
    state: {
      columnVisibility,
      rowSelection,
    },
    enableRowSelection: isAdmin,
    onRowSelectionChange: setRowSelection,
    onColumnVisibilityChange: setColumnVisibility,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  const handleViewDetails = (procurement: ProcurementWithRelations) => {
    setViewingProcurement(procurement);
    setShowViewDialog(true);
  };

  const handleEditProcurement = (procurement: ProcurementWithRelations) => {
    if (isAdmin) {
      setEditingProcurement(procurement);
      setShowEditDialog(true);
    } else {
      toast.error('You do not have permission to edit procurements.');
    }
  };

  const handleBulkDelete = async () => {
    setIsDeleting(true);
    try {
      const selectedProcurementIds = Object.keys(rowSelection)
        .map(index => {
          const idx = parseInt(index);
          return idx >= 0 && idx < procurements.length && procurements[idx] ? procurements[idx].id : null;
        })
        .filter((id): id is number => id !== null);

      if (selectedProcurementIds.length === 0) {
        toast.error('No procurements selected for deletion.');
        setShowBulkDeleteDialog(false);
        return;
      }

      const result = await bulkDeleteProcurements(selectedProcurementIds);

      if (result.success) {
        toast.success('Procurements deleted successfully.');
        await handleRefresh();
      } else {
        toast.error('Failed to delete procurements. Please try again.');
      }

      setShowBulkDeleteDialog(false);
    } catch (error) {
      toast.error('Failed to delete procurements. An unexpected error occurred.');
    } finally {
      setIsDeleting(false);
    }
  };

  useEffect(() => {
    const handleViewProcurementEvent = (e: CustomEvent<{ procurement: ProcurementWithRelations }>) => {
      handleViewDetails(e.detail.procurement);
    };
    const handleDataChangeEvent = () => {
      handleRefresh();
    };

    document.addEventListener('viewProcurement', handleViewProcurementEvent as EventListener);
    document.addEventListener('procurementDataChanged', handleDataChangeEvent as EventListener);

    return () => {
      document.removeEventListener('viewProcurement', handleViewProcurementEvent as EventListener);
      document.removeEventListener('procurementDataChanged', handleDataChangeEvent as EventListener);
    };
  }, [currentPage, query]);

  const selectedCount = Object.keys(rowSelection).length;

  if (loading && procurements.length === 0) {
    return (
      <div className="mt-6 space-y-4">
        <div className="flex justify-between items-center">
          <div className="w-24 h-8 bg-gray-200 rounded animate-pulse"></div>
          <div className="w-28 h-8 bg-gray-200 rounded animate-pulse"></div>
        </div>
        <div className="rounded-md border">
          <div className="h-12 border-b bg-secondary px-4 flex items-center">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
            ))}
          </div>
          {Array.from({ length: 10 }).map((_, i) => (
            <div key={i} className="border-b px-4 py-4 flex items-center">
              {Array.from({ length: 6 }).map((_, j) => (
                <div key={j} className="h-4 bg-gray-200 rounded w-32 mx-4 animate-pulse"></div>
              ))}
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="mt-6 space-y-4">
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-2">
          {isAdmin && selectedCount > 0 && (
            <div className="flex items-center gap-2">
              <span className="text-sm text-muted-foreground">{selectedCount} selected</span>
              <Button variant="destructive" size="sm" onClick={() => setShowBulkDeleteDialog(true)} className="h-8">
                <TrashIcon className="mr-2 h-4 w-4" />
                Delete Selected
              </Button>
            </div>
          )}

          <Button
            variant="outline"
            size="sm"
            onClick={handleRefresh}
            disabled={refreshing || loading}
            className="h-8 ml-2"
          >
            <RefreshCw className={`mr-2 h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
            {refreshing ? 'Refreshing...' : 'Refresh'}
          </Button>
        </div>
        <ColumnFilter table={table} />
      </div>
      <div className="rounded-md border overflow-x-auto">
        <ScrollArea className="h-[calc(100vh-350px)] w-full">
          <Table className="min-w-max">
            <TableHeader className="sticky top-0 bg-secondary">
              {table.getHeaderGroups().map(headerGroup => (
                <TableRow key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <TableHead key={header.id}>
                      {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                    </TableHead>
                  ))}
                </TableRow>
              ))}
            </TableHeader>
            <TableBody>
              {table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map(row => (
                  <ProcurementContextMenu
                    key={row.id}
                    procurement={row.original}
                    onEdit={() => handleEditProcurement(row.original)}
                    isAdmin={isAdmin}
                  >
                    <TableRow
                      data-state={row.getIsSelected() && 'selected'}
                      onDoubleClick={() => handleViewDetails(row.original)}
                      className="cursor-pointer hover:bg-muted/50"
                    >
                      {row.getVisibleCells().map(cell => (
                        <TableCell key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</TableCell>
                      ))}
                    </TableRow>
                  </ProcurementContextMenu>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={columns.length} className="h-24 text-center">
                    {loading || refreshing ? 'Loading...' : 'No procurements found.'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </ScrollArea>
      </div>

      {viewingProcurement && (
        <ProcurementDetailsDialog
          procurement={viewingProcurement}
          open={showViewDialog}
          onOpenChange={setShowViewDialog}
        />
      )}

      {isAdmin && editingProcurement && (
        <ProcurementFormDialog
          mode="edit"
          procurement={editingProcurement}
          open={showEditDialog}
          onOpenChange={setShowEditDialog}
        />
      )}

      <AlertDialog open={showBulkDeleteDialog} onOpenChange={setShowBulkDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to delete these procurements?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete {selectedCount} procurement records and all
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              className="bg-destructive hover:bg-destructive/90"
              disabled={isDeleting}
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\procurements\lib\actions.ts:
```
'use server';

import axios from 'axios';
import { cookies } from 'next/headers';

const API_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:5000';

interface GetProcurementsParams {
  page?: number;
  query?: string;
}

export async function getProcurements({ page = 1, query = '' }: GetProcurementsParams) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.get(`${API_URL}/api/procurements`, {
      headers: {
        Cookie: `token=${token}`,
      },
      params: {
        page,
        limit: 10,
        search: query,
      },
      withCredentials: true,
    });

    return response.data.procurements;
  } catch (error) {
    console.error('Error fetching procurements:', error);
    throw error;
  }
}

export async function getProcurementPages(query = '') {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.get(`${API_URL}/api/procurements`, {
      headers: {
        Cookie: `token=${token}`,
      },
      params: {
        page: 1,
        limit: 10,
        search: query,
      },
      withCredentials: true,
    });

    const totalCount = response.data.pagination.totalCount;
    const totalPages = Math.ceil(totalCount / 10);
    return totalPages;
  } catch (error) {
    console.error('Error fetching procurement count:', error);
    throw error;
  }
}

export async function bulkDeleteProcurements(ids: number[]) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.delete(`${API_URL}/api/procurements/bulk`, {
      headers: {
        Cookie: `token=${token}`,
      },
      data: { ids },
      withCredentials: true,
    });

    return { success: true };
  } catch (error) {
    console.error('Error deleting procurements:', error);
    return { success: false };
  }
}

export async function deleteProcurement(id: number) {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('token')?.value;

    if (!token) {
      throw new Error('Authentication token not found');
    }

    const response = await axios.delete(`${API_URL}/api/procurements/${id}`, {
      headers: {
        Cookie: `token=${token}`,
      },
      withCredentials: true,
    });

    return { success: true };
  } catch (error) {
    console.error('Error deleting procurement:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

```

### apps\web\app\(dashboard)\procurements\lib\types.ts:
```
import type { Procurement, Farmer } from '@chaya/shared';

export interface ProcurementWithRelations extends Procurement {
  farmer: Pick<Farmer, 'name' | 'village' | 'panchayath' | 'mandal'>;
}

```

### apps\web\app\(dashboard)\procurements\lib\columns.tsx:
```
'use client';

import type { ColumnDef } from '@tanstack/react-table';
import { Checkbox } from '@workspace/ui/components/checkbox';
import type { ProcurementWithRelations } from './types';
import { format } from 'date-fns';

export const defaultVisibleColumns = [
  'select',
  'procurementNumber',
  'crop',
  'farmerName',
  'quantity',
  'date',
  'procuredBy',
];

export const columns: ColumnDef<ProcurementWithRelations>[] = [
  {
    id: 'select',
    header: ({ table }) => (
      <Checkbox
        checked={table.getIsAllPageRowsSelected() || (table.getIsSomePageRowsSelected() && 'indeterminate')}
        onCheckedChange={value => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={value => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: 'procurementNumber',
    header: 'Proc. Number',
    cell: ({ row }) => <div className="font-medium">{row.getValue('procurementNumber')}</div>,
  },
  {
    accessorKey: 'crop',
    header: 'Crop',
    cell: ({ row }) => <div>{row.getValue('crop')}</div>,
  },
  {
    accessorKey: 'farmerName',
    header: 'Farmer',
    cell: ({ row }) => <div>{row.original.farmer.name}</div>,
  },
  {
    accessorKey: 'procuredForm',
    header: 'Form',
    cell: ({ row }) => <div>{row.getValue('procuredForm')}</div>,
  },
  {
    accessorKey: 'speciality',
    header: 'Speciality',
    cell: ({ row }) => <div>{row.getValue('speciality')}</div>,
  },
  {
    accessorKey: 'quantity',
    header: 'Quantity',
    cell: ({ row }) => <div>{row.getValue('quantity')} kg</div>,
  },
  {
    accessorKey: 'date',
    header: 'Date',
    cell: ({ row }) => <div>{format(new Date(row.original.date), 'dd/MM/yyyy')}</div>,
  },
  {
    accessorKey: 'time',
    header: 'Time',
    cell: ({ row }) => <div>{format(new Date(row.original.time), 'hh:mm a')}</div>,
  },
  {
    accessorKey: 'lotNo',
    header: 'Lot No',
    cell: ({ row }) => <div>{row.getValue('lotNo')}</div>,
  },
  {
    accessorKey: 'procuredBy',
    header: 'Procured By',
    cell: ({ row }) => <div>{row.getValue('procuredBy')}</div>,
  },
  {
    accessorKey: 'vehicleNo',
    header: 'Vehicle No',
    cell: ({ row }) => <div>{row.getValue('vehicleNo')}</div>,
  },
  {
    accessorKey: 'location',
    header: 'Location',
    cell: ({ row }) => (
      <div>
        {row.original.farmer.village}, {row.original.farmer.panchayath}, {row.original.farmer.mandal}
      </div>
    ),
  },
];

```

### apps\web\app\(dashboard)\procurements\context\procurement-cache-context.tsx:
```
'use client';

import React, { createContext, useContext, useState, useCallback } from 'react';
import { getProcurements, getProcurementPages } from '../lib/actions';
import { ProcurementWithRelations } from '../lib/types';
import { toast } from 'sonner';

interface ProcurementsCacheContextType {
  procurements: Record<string, ProcurementWithRelations[]>;
  totalPages: Record<string, number>;
  fetchProcurements: (page: number, query: string) => Promise<ProcurementWithRelations[]>;
  fetchTotalPages: (query: string) => Promise<number>;
  clearCache: () => void;
  prefetchPages: (startPage: number, endPage: number, query: string) => Promise<void>;
  refreshCurrentPage: (page: number, query: string) => Promise<ProcurementWithRelations[]>;
}

const ProcurementsCacheContext = createContext<ProcurementsCacheContextType | undefined>(undefined);

export function ProcurementsCacheProvider({ children }: { children: React.ReactNode }) {
  const [procurements, setProcurements] = useState<Record<string, ProcurementWithRelations[]>>({});
  const [totalPages, setTotalPages] = useState<Record<string, number>>({});

  const createKey = useCallback((page: number, query: string) => `${query}:${page}`, []);

  const fetchProcurements = useCallback(
    async (page: number, query: string): Promise<ProcurementWithRelations[]> => {
      const key = createKey(page, query);

      if (procurements[key]) {
        console.log(`Using cached data for page ${page}, query "${query}"`);
        return procurements[key];
      }

      console.log(`Fetching page ${page}, query "${query}" from server`);
      try {
        const data = (await getProcurements({ page, query })) as ProcurementWithRelations[];
        setProcurements(prev => ({
          ...prev,
          [key]: data,
        }));
        return data;
      } catch (error) {
        toast.error('Failed to fetch procurements data from server.');
        throw error;
      }
    },
    [procurements, createKey]
  );

  const fetchTotalPages = useCallback(
    async (query: string): Promise<number> => {
      if (totalPages[query] !== undefined) {
        return totalPages[query];
      }

      try {
        const pages = await getProcurementPages(query);
        setTotalPages(prev => ({
          ...prev,
          [query]: pages,
        }));
        return pages;
      } catch (error) {
        toast.error('Failed to fetch pagination data.');
        throw error;
      }
    },
    [totalPages]
  );

  const prefetchPages = useCallback(
    async (startPage: number, endPage: number, query: string) => {
      console.log(`Prefetching pages ${startPage}-${endPage} for query "${query}"`);

      for (let page = startPage; page <= endPage; page++) {
        const key = createKey(page, query);

        if (procurements[key]) continue;

        try {
          const data = (await getProcurements({
            page,
            query,
          })) as ProcurementWithRelations[];
          setProcurements(prev => ({
            ...prev,
            [key]: data,
          }));
        } catch (error) {
          console.error(`Error prefetching page ${page}:`, error);
          toast.error(`Failed to prefetch data for page ${page}.`);
        }
      }
    },
    [procurements, createKey]
  );

  const refreshCurrentPage = useCallback(
    async (page: number, query: string): Promise<ProcurementWithRelations[]> => {
      const key = createKey(page, query);

      console.log(`Force refreshing page ${page}, query "${query}" from server`);
      try {
        const data = (await getProcurements({
          page,
          query,
        })) as ProcurementWithRelations[];
        setProcurements(prev => ({
          ...prev,
          [key]: data,
        }));
        fetchTotalPages(query);
        return data;
      } catch (error) {
        console.error(`Error refreshing page ${page}:`, error);
        toast.error(`Failed to refresh data for page ${page}.`);
        throw error;
      }
    },
    [createKey, fetchTotalPages]
  );

  const clearCache = useCallback(() => {
    setProcurements({});
    setTotalPages({});
    toast.success('Cache cleared successfully.');
  }, []);

  const value = {
    procurements,
    totalPages,
    fetchProcurements,
    fetchTotalPages,
    clearCache,
    prefetchPages,
    refreshCurrentPage,
  };

  return <ProcurementsCacheContext.Provider value={value}>{children}</ProcurementsCacheContext.Provider>;
}

export function useProcurementsCache() {
  const context = useContext(ProcurementsCacheContext);

  if (context === undefined) {
    throw new Error('useProcurementsCache must be used within a ProcurementsCacheProvider');
  }

  return context;
}

```

### apps\web\app\(dashboard)\staff\page.tsx:
```
import { Metadata } from 'next';
import { StaffDashboard } from './components/staff-dashboard';
import { AuthProvider } from '@/app/providers/auth-provider';

export const metadata: Metadata = {
  title: 'Staff Management',
  description: 'Manage your staff members',
};

export default function StaffManagementPage() {
  return (
    <AuthProvider>
      <div className="container mx-auto py-6">
        {/* <h1 className="text-2xl font-bold mb-6">Staff Management</h1> */}
        <StaffDashboard />
      </div>
    </AuthProvider>
  );
}

```

### apps\web\app\(dashboard)\staff\components\staff-dashboard.tsx:
```
'use client';

import { useState } from 'react';
import { StaffTable } from './staff-table';
import { AddStaffDialog } from './add-staff-dialog';
import { Button } from '@workspace/ui/components/button';
import { UserPlus } from 'lucide-react';
// import { useAuth } from '@/app/providers/auth-provider';

export function StaffDashboard() {
  const [isAddStaffOpen, setIsAddStaffOpen] = useState(false);
  // const { user } = useAuth();
  return (
    <div className="bg-white rounded-lg shadow">
      <div className="p-6 flex justify-between items-center border-b">
        <h2 className="text-xl font-semibold">Staff Members</h2>
        <Button onClick={() => setIsAddStaffOpen(true)}>
          <UserPlus className="mr-2 h-4 w-4" />
          Add Staff
        </Button>
      </div>

      <StaffTable />

      <AddStaffDialog open={isAddStaffOpen} onOpenChange={setIsAddStaffOpen} />
    </div>
  );
}

```

### apps\web\app\(dashboard)\staff\components\edit-staff-dialog.tsx:
```
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import axios from 'axios';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from '@workspace/ui/components/form';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
  isEnabled: boolean;
}

const formSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters').optional().or(z.literal('')),
});

type FormValues = z.infer<typeof formSchema>;

interface EditStaffDialogProps {
  user: User;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onUserUpdated: () => void;
}

export function EditStaffDialog({ user, open, onOpenChange, onUserUpdated }: EditStaffDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: user.name,
      email: user.email,
      password: '',
    },
  });

  const onSubmit = async (data: FormValues) => {
    const updateData = {
      name: data.name,
      email: data.email,
      ...(data.password ? { password: data.password } : {}),
    };

    setIsSubmitting(true);
    try {
      await axios.put(`http://localhost:5000/api/users/${user.id}`, updateData);
      toast.success("Staff member's details updated successfully");
      onUserUpdated();
      onOpenChange(false);
    } catch (error: any) {
      toast.error("Failed to update staff member's details", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit Staff Member</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name</FormLabel>
                  <FormControl>
                    <Input {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Password</FormLabel>
                  <FormControl>
                    <Input type="password" placeholder="Leave blank to keep current password" {...field} />
                  </FormControl>
                  <FormDescription>Only enter a value if you want to change the password</FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="mt-6">
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Saving...' : 'Save Changes'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\staff\components\staff-table.tsx:
```
'use client';

import { useState, useEffect } from 'react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@workspace/ui/components/table';
import { Button } from '@workspace/ui/components/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@workspace/ui/components/dropdown-menu';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@workspace/ui/components/alert-dialog';
import { Badge } from '@workspace/ui/components/badge';
import { Switch } from '@workspace/ui/components/switch';
import { Input } from '@workspace/ui/components/input';
import { EditStaffDialog } from './edit-staff-dialog';
import { MoreHorizontal, Edit, Trash2, Search, UserCircle, Calendar, Mail, RefreshCw } from 'lucide-react';
import axios from 'axios';
import { formatDate, getTimeSince } from '../lib/utils';
import { toast } from 'sonner';
import { useAuth } from '@/app/providers/auth-provider';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'ADMIN' | 'STAFF';
  isEnabled: boolean;
  isActive: boolean;
  lastLoginAt: string | null;
  createdAt: string;
}

export function StaffTable() {
  const [users, setUsers] = useState<User[]>([]);
  const [filteredUsers, setFilteredUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [userToDelete, setUserToDelete] = useState<User | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);

  const { user } = useAuth();
  const axiosConfig = {
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredUsers(users);
    } else {
      const query = searchQuery.toLowerCase();
      setFilteredUsers(
        users.filter(
          user =>
            user.name.toLowerCase().includes(query) ||
            user.email.toLowerCase().includes(query) ||
            user.role.toLowerCase().includes(query)
        )
      );
    }
  }, [searchQuery, users]);

  const fetchUsers = async () => {
    setIsLoading(true);
    try {
      const response = await axios.get('http://localhost:5000/api/users', axiosConfig);
      setUsers(response.data.users);
      setFilteredUsers(response.data.users);
    } catch (error) {
      toast.error('Failed to fetch staff members');
    } finally {
      setIsLoading(false);
    }
  };

  const refreshUsers = async () => {
    setIsRefreshing(true);
    await fetchUsers();
    setIsRefreshing(false);
  };

  const handleEditUser = (user: User) => {
    setEditingUser(user);
    setIsEditDialogOpen(true);
  };

  const handleDeleteUser = (user: User) => {
    setUserToDelete(user);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteUser = async () => {
    if (!userToDelete) return;
    try {
      await axios.delete(`http://localhost:5000/api/users/${userToDelete.id}`, axiosConfig);
      toast.success('Staff member deleted successfully');
      fetchUsers();
    } catch (error: any) {
      toast('Failed to delete staff member');
    } finally {
      setIsDeleteDialogOpen(false);
      setUserToDelete(null);
    }
  };

  const toggleUserStatus = async (user: User) => {
    setUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: !u.isEnabled } : u)));
    setFilteredUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: !u.isEnabled } : u)));
    try {
      await axios.patch(`http://localhost:5000/api/users/${user.id}/toggle-status`, {}, axiosConfig);
      toast.success('Staff member status updated successfully');
    } catch (error: any) {
      setUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: user.isEnabled } : u)));
      setFilteredUsers(prev => prev.map(u => (u.id === user.id ? { ...u, isEnabled: user.isEnabled } : u)));
      toast.error('Failed to update staff member status');
    }
  };

  return (
    <div className="space-y-4">
      <div className="p-4 border-b flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div className="relative w-full sm:w-64">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
          <Input
            placeholder="Search staff members..."
            value={searchQuery}
            onChange={e => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
        <Button variant="outline" size="sm" onClick={refreshUsers} disabled={isRefreshing}>
          <RefreshCw className={`h-4 w-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      <div className="relative overflow-x-auto rounded-md">
        <Table className="border">
          <TableHeader className="bg-muted">
            <TableRow className="hover:bg-transparent">
              <TableHead className="w-[250px]">Staff Member</TableHead>
              <TableHead>Role</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Last Login</TableHead>
              <TableHead>Created</TableHead>
              <TableHead className="w-[100px] text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              Array.from({ length: 3 }).map((_, index) => (
                <TableRow key={`skeleton-${index}`} className="animate-pulse">
                  <TableCell>
                    <div className="flex items-center space-x-3">
                      <div className="h-10 w-10 rounded-full bg-gray-200"></div>
                      <div className="space-y-1">
                        <div className="h-4 w-24 bg-gray-200 rounded"></div>
                        <div className="h-3 w-32 bg-gray-200 rounded"></div>
                      </div>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="h-6 w-16 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-6 w-16 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-4 w-20 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-4 w-20 bg-gray-200 rounded"></div>
                  </TableCell>
                  <TableCell>
                    <div className="h-8 w-8 bg-gray-200 rounded float-right"></div>
                  </TableCell>
                </TableRow>
              ))
            ) : filteredUsers.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-8">
                  {searchQuery ? 'No staff members match your search' : 'No staff members found'}
                </TableCell>
              </TableRow>
            ) : (
              filteredUsers.map(user => (
                <TableRow key={user.id} className="hover:bg-gray-50">
                  <TableCell>
                    <div className="flex items-center space-x-3">
                      <div className="h-10 w-10 rounded-full bg-primary/10 flex items-center justify-center">
                        <UserCircle className="h-6 w-6 text-primary" />
                      </div>
                      <div>
                        <div className="font-medium">{user.name}</div>
                        <div className="text-sm text-muted-foreground flex items-center">
                          <Mail className="h-3 w-3 mr-1" />
                          {user.email}
                        </div>
                      </div>
                    </div>
                  </TableCell>
                  <TableCell>
                    <Badge
                      variant={user.role === 'ADMIN' ? 'default' : 'outline'}
                      className={user.role === 'ADMIN' ? 'bg-primary text-primary-foreground' : ''}
                    >
                      {user.role}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <div className="flex items-center space-x-2">
                      <Switch
                        checked={user.isEnabled}
                        disabled={user.role === 'ADMIN'}
                        onCheckedChange={() => toggleUserStatus(user)}
                      />
                      <span className={user.isEnabled ? 'text-green-600' : 'text-red-600'}>
                        {user.isEnabled ? 'Enabled' : 'Disabled'}
                      </span>
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="flex flex-col">
                      <span>{formatDate(user.lastLoginAt)}</span>
                      {user.lastLoginAt && (
                        <span className="text-xs text-muted-foreground flex items-center">
                          <Calendar className="h-3 w-3 mr-1" />
                          {getTimeSince(user.lastLoginAt)}
                        </span>
                      )}
                    </div>
                  </TableCell>
                  <TableCell>{formatDate(user.createdAt)}</TableCell>
                  <TableCell className="text-right">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" className="h-8 w-8 p-0">
                          <span className="sr-only">Open menu</span>
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuLabel>Actions</DropdownMenuLabel>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem onClick={() => handleEditUser(user)}>
                          <Edit className="mr-2 h-4 w-4" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleDeleteUser(user)}
                          disabled={user.role === 'ADMIN'}
                          className={user.role === 'ADMIN' ? 'opacity-50' : 'text-red-600'}
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {editingUser && (
        <EditStaffDialog
          user={editingUser}
          open={isEditDialogOpen}
          onOpenChange={setIsEditDialogOpen}
          onUserUpdated={fetchUsers}
        />
      )}

      <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action will permanently delete the staff member account for{' '}
              <span className="font-semibold">{userToDelete?.name}</span>. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={confirmDeleteUser} className="bg-red-600 hover:bg-red-700 text-white">
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

### apps\web\app\(dashboard)\staff\components\add-staff-dialog.tsx:
```
// app/staff/components/add-staff-dialog.tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import axios from 'axios';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@workspace/ui/components/dialog';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@workspace/ui/components/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@workspace/ui/components/select';
import { Input } from '@workspace/ui/components/input';
import { Button } from '@workspace/ui/components/button';
import { toast } from 'sonner';

// Form schema for validation
const formSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  role: z.enum(['ADMIN', 'STAFF']),
});

type FormValues = z.infer<typeof formSchema>;

interface AddStaffDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AddStaffDialog({ open, onOpenChange }: AddStaffDialogProps) {
  const axiosConfig = {
    withCredentials: true,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      email: '',
      password: '',
      role: 'STAFF',
    },
  });

  const onSubmit = async (data: FormValues) => {
    setIsSubmitting(true);
    try {
      await axios.post('http://localhost:5000/api/auth/register', data, axiosConfig);
      toast.success('Staff member added successfully');
      form.reset();
      onOpenChange(false);
    } catch (error: any) {
      toast.error('Failed to add staff member', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Add New Staff Member</DialogTitle>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name</FormLabel>
                  <FormControl>
                    <Input placeholder="John Doe" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" placeholder="john.doe@example.com" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Password</FormLabel>
                  <FormControl>
                    <Input type="password" placeholder="••••••••" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="role"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Role</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a role" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="STAFF">Staff</SelectItem>
                      <SelectItem value="ADMIN">Admin</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="mt-6">
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Adding...' : 'Add Staff Member'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

```

### apps\web\app\(dashboard)\staff\lib\utils.ts:
```
export function formatDate(dateString: string | null): string {
  if (!dateString) return 'Never';

  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
  });
}

export function getTimeSince(dateString: string | null): string {
  if (!dateString) return 'Never logged in';

  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();

  const seconds = Math.floor(diffMs / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
  if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  return 'Just now';
}

```

### apps\web\app\stores\procurement-form.ts:
```
import { create } from 'zustand';
import type { UseFormReturn } from 'react-hook-form';
import type { ProcurementWithRelations } from '@/app/(dashboard)/procurements/lib/types';
import { z } from 'zod';
import { toast } from 'sonner';

const basicInfoSchemaForStore = z.object({
  farmerId: z.number({ required_error: 'Farmer is required' }),
  crop: z.string().min(1, 'Crop is required'),
  procuredForm: z.string().min(1, 'Procured form is required'),
  speciality: z.string().min(1, 'Speciality is required'),
  quantity: z
    .number({ required_error: 'Quantity is required', invalid_type_error: 'Quantity must be a number' })
    .positive('Quantity must be a positive number'),
});
const detailsSchemaForStore = z.object({
  date: z.date({ required_error: 'Date is required' }),
  time: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (expected HH:mm:ss)'),
  lotNo: z
    .number({ required_error: 'Lot number is required', invalid_type_error: 'Lot number must be a number' })
    .int()
    .min(1)
    .max(3, 'Only 1, 2, 3 Lot Numbers are allowed'),
  procuredBy: z.string().min(1, 'Procured by is required'),
  vehicleNo: z.string().min(1, 'Vehicle number is required').optional(),
});

export const procurementFullFormSchema = basicInfoSchemaForStore.merge(detailsSchemaForStore);
export type ProcurementFullFormValues = z.infer<typeof procurementFullFormSchema>;

// EXPORT TabType
export type TabType = 'basic' | 'details' | 'review';

interface ProcurementFormState {
  activeTab: TabType;
  setActiveTab: (tab: TabType) => void;
  goToNextTab: () => void;
  goToPreviousTab: () => void;
  form: UseFormReturn<ProcurementFullFormValues, any> | null;
  setForm: (form: UseFormReturn<ProcurementFullFormValues, any> | null) => void;
  isSubmitting: boolean;
  setIsSubmitting: (isSubmitting: boolean) => void;
  initialData: ProcurementWithRelations | null;
  mode: 'add' | 'edit';
  initializeForm: (initialData: ProcurementWithRelations | null | undefined, mode: 'add' | 'edit') => void;
}

export const useProcurementFormStore = create<ProcurementFormState>((set, get) => ({
  activeTab: 'basic',
  setActiveTab: tab => set({ activeTab: tab }),
  goToNextTab: async () => {
    const { activeTab, form } = get();
    if (form) {
      let fieldsToValidate: (keyof ProcurementFullFormValues)[] = [];
      if (activeTab === 'basic') {
        fieldsToValidate = ['farmerId', 'crop', 'procuredForm', 'speciality', 'quantity'];
      } else if (activeTab === 'details') {
        fieldsToValidate = ['date', 'time', 'lotNo', 'procuredBy', 'vehicleNo'];
      }

      if (fieldsToValidate.length > 0) {
        const isValid = await form.trigger(fieldsToValidate);
        if (!isValid) {
          toast.error('Please correct the errors on the current tab before proceeding.');
          return;
        }
      }
    }

    if (activeTab === 'basic') set({ activeTab: 'details' });
    else if (activeTab === 'details') set({ activeTab: 'review' });
  },
  goToPreviousTab: () => {
    const { activeTab } = get();
    if (activeTab === 'review') set({ activeTab: 'details' });
    else if (activeTab === 'details') set({ activeTab: 'basic' });
  },
  form: null,
  setForm: form => set({ form }),
  isSubmitting: false,
  setIsSubmitting: isSubmitting => set({ isSubmitting }),
  initialData: null,
  mode: 'add',
  initializeForm: (initialData, mode) => {
    set({
      initialData: initialData || null,
      mode,
      activeTab: 'basic',
      isSubmitting: false,
    });
  },
}));

```

### apps\web\app\stores\farmer-form.ts:
```
import { create } from 'zustand';
import { useForm } from 'react-hook-form';
import { differenceInYears } from 'date-fns';

type FormType = ReturnType<typeof useForm>;

export interface LocationData {
  lat: number;
  lng: number;
  accuracy: number;
  altitude: number | null;
  altitudeAccuracy: number | null;
  timestamp: number;
}

interface FarmerFormState {
  form: FormType | null;
  activeTab: string;
  isSubmitting: boolean;
  tabs: string[];
  setForm: (form: FormType | null) => void;
  setActiveTab: (tab: string) => void;
  addField: () => void;
  removeField: (index: number) => void;
  setIsSubmitting: (value: boolean) => void;
  goToNextTab: () => void;
  goToPreviousTab: () => void;
  resetForm: () => void;
  updateFieldLocation: (index: number, location: LocationData) => void;
  calculateAge: (birthDate: string) => void;
  notifyFormSuccess: () => void;
}

export const useFarmerFormStore = create<FarmerFormState>((set, get) => ({
  form: null,
  activeTab: 'personal',
  isSubmitting: false,
  tabs: ['personal', 'address', 'bank', 'documents', 'fields', 'review'],

  setForm: form => {
    console.log('Form set in store:', form ? 'Form object exists' : 'Form is null');
    set({ form });
  },
  setActiveTab: tab => set({ activeTab: tab }),

  addField: () => {
    const { form } = get();
    if (!form) return;

    const fields = form.getValues('fields') || [];
    form.setValue('fields', [
      ...fields,
      {
        areaHa: 0,
        yieldEstimate: 0,
        location: {
          lat: 0,
          lng: 0,
          accuracy: 0,
          altitude: null,
          altitudeAccuracy: null,
          timestamp: Date.now(),
        },
        landDocumentUrl: '',
      },
    ]);
  },

  removeField: index => {
    const { form } = get();
    if (!form) return;

    const fields = form.getValues('fields') || [];
    form.setValue(
      'fields',
      fields.filter((_: any, i: number) => i !== index)
    );
  },

  setIsSubmitting: value => set({ isSubmitting: value }),

  goToNextTab: () => {
    const { activeTab, tabs } = get();
    const currentIndex = tabs.indexOf(activeTab);
    if (currentIndex < tabs.length - 1) {
      set({ activeTab: tabs[currentIndex + 1] });
    }
  },

  goToPreviousTab: () => {
    const { activeTab, tabs } = get();
    const currentIndex = tabs.indexOf(activeTab);
    if (currentIndex > 0) {
      set({ activeTab: tabs[currentIndex - 1] });
    }
  },

  resetForm: () => {
    const { form } = get();
    if (form) {
      form.reset();
    }
    set({ activeTab: 'personal', isSubmitting: false });
  },

  updateFieldLocation: (index, location) => {
    const { form } = get();
    if (!form) return;

    form.setValue(`fields.${index}.location`, location);
  },

  calculateAge: birthDate => {
    const { form } = get();
    if (!form || !birthDate) return;

    const age = differenceInYears(new Date(), new Date(birthDate));
    form.setValue('farmer.age', age);
  },

  notifyFormSuccess: () => {
    if (typeof window !== 'undefined') {
      const dataChangedEvent = new CustomEvent('farmerDataChanged');
      document.dispatchEvent(dataChangedEvent);
      console.log('Form submission success event dispatched');
    }
  },
}));

```

### apps\web\app\stores\processing-batch-form.ts:
```
import { create } from 'zustand';
import type { UseFormReturn } from 'react-hook-form';
import type { Procurement as BaseProcurement, CreateProcessingBatchInput } from '@chaya/shared'; // Renamed to BaseProcurement
import { toast } from 'sonner';

// Define the procurement type as it's stored in this Zustand store
export interface ProcurementWithFarmerForStore extends BaseProcurement {
  farmer: { name: string; village?: string }; // village is optional if not always present/needed
}

type ProcessingBatchFormStep = 'selectCriteria' | 'selectProcurements' | 'firstStageDetails' | 'review';

interface ProcessingBatchFormState {
  activeStep: ProcessingBatchFormStep;
  setActiveStep: (step: ProcessingBatchFormStep) => void;
  goToNextStep: () => void;
  goToPreviousTab: () => void;

  initialCrop: string | null;
  initialLotNo: number | null;

  lockedCrop: string | null;
  lockedLotNo: number | null;
  lockedProcuredForm: string | null;
  filterCriteriaLocked: boolean;

  availableProcurements: ProcurementWithFarmerForStore[]; // USE THE NEW TYPE HERE
  selectedProcurementIds: number[];
  firstStageDetails: Partial<CreateProcessingBatchInput['firstStageDetails']>;

  setInitialCriteria: (criteria: { crop?: string | null; lotNo?: number | null }) => void;
  setAvailableProcurements: (procurements: ProcurementWithFarmerForStore[]) => void; // EXPECT THE NEW TYPE
  toggleSelectedProcurement: (procurement: ProcurementWithFarmerForStore) => void; // EXPECT THE NEW TYPE
  setFirstStageDetails: (details: Partial<CreateProcessingBatchInput['firstStageDetails']>) => void;

  clearLockedFilters: () => void;

  form: UseFormReturn<any> | null;
  setForm: (form: UseFormReturn<any> | null) => void;

  isSubmitting: boolean;
  setIsSubmitting: (isSubmitting: boolean) => void;

  resetForm: () => void;
}

const initialFirstStageDetailsState: Partial<CreateProcessingBatchInput['firstStageDetails']> = {
  processMethod: 'wet',
  dateOfProcessing: new Date(),
  doneBy: '',
};

const initialCoreState = {
  activeStep: 'selectCriteria' as ProcessingBatchFormStep,
  initialCrop: null,
  initialLotNo: null,
  lockedCrop: null,
  lockedLotNo: null,
  lockedProcuredForm: null,
  filterCriteriaLocked: false,
  availableProcurements: [],
  selectedProcurementIds: [],
  firstStageDetails: { ...initialFirstStageDetailsState },
  form: null,
  isSubmitting: false,
};

export const useProcessingBatchFormStore = create<ProcessingBatchFormState>((set, get) => ({
  ...initialCoreState,
  setActiveStep: step => set({ activeStep: step }),
  goToNextStep: () => {
    const { activeStep } = get();
    if (activeStep === 'selectCriteria') set({ activeStep: 'selectProcurements' });
    else if (activeStep === 'selectProcurements') set({ activeStep: 'firstStageDetails' });
    else if (activeStep === 'firstStageDetails') set({ activeStep: 'review' });
  },
  goToPreviousTab: () => {
    const { activeStep } = get();
    if (activeStep === 'review') set({ activeStep: 'firstStageDetails' });
    else if (activeStep === 'firstStageDetails') {
      set({ activeStep: 'selectProcurements' });
    } else if (activeStep === 'selectProcurements') {
      set({
        activeStep: 'selectCriteria',
        filterCriteriaLocked: false,
        lockedCrop: null,
        lockedLotNo: null,
        lockedProcuredForm: null,
        selectedProcurementIds: [],
      });
    }
  },

  setInitialCriteria: criteria =>
    set({
      initialCrop: criteria.crop || null,
      initialLotNo: criteria.lotNo || null,
      lockedCrop: criteria.crop || null,
      lockedLotNo: criteria.lotNo || null,
      lockedProcuredForm: null,
      filterCriteriaLocked: !!(criteria.crop && criteria.lotNo),
      selectedProcurementIds: [],
      availableProcurements: [],
    }),

  setAvailableProcurements: procurements => set({ availableProcurements: procurements }),

  toggleSelectedProcurement: procurement => {
    // procurement is ProcurementWithFarmerForStore
    set(state => {
      const isSelected = state.selectedProcurementIds.includes(procurement.id);
      let newSelectedIds = [...state.selectedProcurementIds];
      let newLockedCrop = state.lockedCrop;
      let newLockedLotNo = state.lockedLotNo;
      let newLockedProcuredForm = state.lockedProcuredForm;
      let newFilterCriteriaLocked = state.filterCriteriaLocked;

      if (isSelected) {
        newSelectedIds = newSelectedIds.filter(pid => pid !== procurement.id);
        if (newSelectedIds.length === 0) {
          newFilterCriteriaLocked = !!(state.initialCrop && state.initialLotNo);
          newLockedCrop = state.initialCrop;
          newLockedLotNo = state.initialLotNo;
          newLockedProcuredForm = null;
        }
      } else {
        // procurement.procuredForm is available because type is ProcurementWithFarmerForStore
        if (!state.filterCriteriaLocked || state.selectedProcurementIds.length === 0) {
          newLockedCrop = state.initialCrop || procurement.crop;
          newLockedLotNo = state.initialLotNo || procurement.lotNo;
          newLockedProcuredForm = procurement.procuredForm;
          newFilterCriteriaLocked = true;
          newSelectedIds.push(procurement.id);
        } else {
          if (
            procurement.crop === newLockedCrop &&
            procurement.lotNo === newLockedLotNo &&
            procurement.procuredForm === newLockedProcuredForm
          ) {
            newSelectedIds.push(procurement.id);
          } else {
            toast.error(
              'This procurement does not match the established batch criteria (Crop, Lot No, Procured Form).'
            );
          }
        }
      }
      return {
        selectedProcurementIds: newSelectedIds,
        lockedCrop: newLockedCrop,
        lockedLotNo: newLockedLotNo,
        lockedProcuredForm: newLockedProcuredForm,
        filterCriteriaLocked: newFilterCriteriaLocked,
      };
    });
  },

  setFirstStageDetails: details =>
    set(state => ({
      firstStageDetails: { ...state.firstStageDetails, ...details },
    })),

  clearLockedFilters: () =>
    set({
      lockedCrop: null,
      lockedLotNo: null,
      lockedProcuredForm: null,
      filterCriteriaLocked: false,
    }),

  setForm: form => set({ form }),
  setIsSubmitting: isSubmitting => set({ isSubmitting }),
  resetForm: () => set({ ...initialCoreState, firstStageDetails: { ...initialFirstStageDetailsState } }),
}));

```

### apps\web\utils\uploadthing.ts:
```
import { generateUploadButton, generateUploadDropzone, generateReactHelpers } from '@uploadthing/react';
import type { OurFileRouter } from '@/app/api/uploadthing/core';

// Explicit type annotations for each export
export const UploadButton: ReturnType<typeof generateUploadButton<OurFileRouter>> =
  generateUploadButton<OurFileRouter>();

export const UploadDropzone: ReturnType<typeof generateUploadDropzone<OurFileRouter>> =
  generateUploadDropzone<OurFileRouter>();

// Generate helpers, but do NOT export the object itself
const uploadHelpers: ReturnType<typeof generateReactHelpers<OurFileRouter>> = generateReactHelpers<OurFileRouter>();

export const useUploadThing: typeof uploadHelpers.useUploadThing = uploadHelpers.useUploadThing;
export const uploadFiles: typeof uploadHelpers.uploadFiles = uploadHelpers.uploadFiles;

```

### apps\api\index.ts:
```
console.log('Hello via Bun!');

```

### apps\api\src\index.ts:
```
import Fastify from 'fastify';
import cors from '@fastify/cors';
import jwt from '@fastify/jwt';
import cookie from '@fastify/cookie';

import authRoutes from './routes/auth';
import userRoutes from './routes/users';
import farmerRoutes from './routes/farmer';
import fieldRoutes from './routes/fields';
import procurementRoutes from './routes/procurement';
import processingBatchRoutes from './routes/processingBatch';
import processingStageRoutes from './routes/processingStage';
import salesRoutes from './routes/sales';
import helloWorldRoutes from './routes/helloWorld';

const fastify = Fastify({
  logger: {
    level: 'debug',
    transport: {
      target: 'pino-pretty',
      options: {
        colorize: true,
        translateTime: 'SYS:standard',
        ignore: 'pid,hostname',
      },
    },
  },
});

async function registerPlugins() {
  await fastify.register(cors, {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  });

  await fastify.register(jwt, {
    secret: process.env.JWT_SECRET || 'your-secret-key-change-in-production',
  });

  await fastify.register(cookie, {
    secret: process.env.COOKIE_SECRET || 'cookie-secret-change-in-production',
    hook: 'onRequest',
  });
}

async function registerRoutes() {
  fastify.register(authRoutes, { prefix: '/api/auth' });
  fastify.register(userRoutes, { prefix: '/api/users' });
  fastify.register(farmerRoutes, { prefix: '/api/farmers' });
  fastify.register(fieldRoutes, { prefix: '/api/fields' });
  fastify.register(procurementRoutes, { prefix: '/api/procurements' });
  fastify.register(processingBatchRoutes, { prefix: '/api/processing-batches' });
  fastify.register(processingStageRoutes, { prefix: '/api/processing-stages' });
  fastify.register(salesRoutes, { prefix: '/api/sales' });

  fastify.register(helloWorldRoutes, { prefix: '/api' });
}

async function start() {
  try {
    await registerPlugins();
    await registerRoutes();

    const port = process.env.PORT ? parseInt(process.env.PORT) : 5000;
    const host = process.env.HOST || '0.0.0.0';

    await fastify.listen({ port, host });
    console.log(`Server is running on ${host}:${port}`);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
}

start();

```

### apps\api\src\helper\index.ts:
```
import { prisma } from '@chaya/shared';
import { v4 as uuidv4 } from 'uuid';

export async function generateSurveyNumber(): Promise<string> {
  let isUnique = false;
  let surveyNumber = '';

  while (!isUnique) {
    const letters = Array.from({ length: 4 }, () => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
    const numbers = String(Math.floor(Math.random() * 10000000)).padStart(7, '0');
    surveyNumber = `${letters}${numbers}`;
    const exists = await prisma.farmer.findUnique({
      where: { surveyNumber },
    });
    if (!exists) isUnique = true;
  }
  return surveyNumber;
}

export function generateProcurementNumber(crop: string, date: Date, lotNo: number): string {
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = date.toISOString().split('T')[0].replace(/-/g, '');
  const lotCode = lotNo.toString();

  const randomSuffix = Math.random().toString(36).substring(2, 5).toUpperCase();
  const base = `${cropCode}${dateCode}${lotCode}${randomSuffix}`;
  const procurementNum = base.padEnd(14, '0');

  return procurementNum;
}

export async function generateProcessingBatchCode(
  crop: string,
  lotNo: number,
  dateOfProcessing: Date
): Promise<string> {
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = dateOfProcessing.toISOString().split('T')[0].replace(/-/g, '');
  const lotStr = lotNo.toString();

  let isUnique = false;
  let uniqueSuffix = '';
  let processingBatchCode = '';

  while (!isUnique) {
    uniqueSuffix = uuidv4().substring(0, 8).toUpperCase();
    processingBatchCode = `PBC-${cropCode}-${lotStr}-${dateCode}-${uniqueSuffix}`;

    const exists = await prisma.processingBatch.findUnique({
      where: { batchCode: processingBatchCode },
    });
    if (!exists) isUnique = true;
  }
  return processingBatchCode;
}

```

### apps\api\src\routes\auth.ts:
```
import type { FastifyInstance } from 'fastify';
import { hashPassword, verifyPassword } from '../lib/password';
import { prisma } from '@chaya/shared';
import { loginSchema, registerSchema } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest, type JWTPayload } from '../middlewares/auth'; // Use JWTPayload from here
import type { FastifyRequest, FastifyReply } from 'fastify';

// Interface JwtPayload (local) is removed, using JWTPayload from middlewares

async function authRoutes(fastify: FastifyInstance) {
  fastify.post('/login', async (request, reply) => {
    try {
      const { email, password } = loginSchema.parse(request.body);

      const user = await prisma.user.findUnique({
        where: { email },
      });

      if (!user) {
        return reply.status(401).send({ error: 'Invalid email or password' });
      }

      if (!user.isEnabled) {
        return reply.status(403).send({
          error: 'Your account has been disabled. Please contact an administrator.',
        });
      }

      const isPasswordValid = await verifyPassword(password, user.password);
      if (!isPasswordValid) {
        return reply.status(401).send({ error: 'Invalid email or password' });
      }

      const token = fastify.jwt.sign(
        {
          id: user.id,
          role: user.role,
        } as Omit<JWTPayload, 'iat' | 'exp'>, // Sign with core fields, iat/exp added by jwt.sign
        {
          expiresIn: '7d',
        }
      );

      await prisma.user.update({
        where: { id: user.id },
        data: {
          lastLoginAt: new Date(),
          isActive: true,
        },
      });

      reply.setCookie('token', token, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge in milliseconds
      });

      return {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      console.error('Login error:', error);
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.post('/logout', async (request, reply) => {
    try {
      if (request.cookies.token) {
        try {
          const decoded = fastify.jwt.verify<JWTPayload>(request.cookies.token);

          await prisma.user.update({
            where: { id: decoded.id },
            data: { isActive: false },
          });
        } catch (error) {
          // Token might be invalid or expired, clear cookie anyway
          console.warn('Token verification error on logout:', error);
        }
      }

      reply.clearCookie('token', {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
      });

      return { success: true };
    } catch (error) {
      console.error('Logout error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.post('/register', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    // const authRequest = request as AuthenticatedRequest; // Not needed here directly as verifyAdmin handles user existence
    try {
      const userData = registerSchema.parse(request.body);

      const existingUser = await prisma.user.findUnique({
        where: { email: userData.email },
      });

      if (existingUser) {
        return reply.status(400).send({ error: 'Email already in use' });
      }

      const hashedPassword = await hashPassword(userData.password);

      const newUser = await prisma.user.create({
        data: {
          name: userData.name,
          email: userData.email,
          password: hashedPassword,
          role: userData.role,
        },
      });

      return {
        user: {
          id: newUser.id,
          name: newUser.name,
          email: newUser.email,
          role: newUser.role,
        },
      };
    } catch (error) {
      console.error('Registration error:', error);
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.get('/me', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authRequest = request as AuthenticatedRequest;
    try {
      const user = await prisma.user.findUnique({
        where: { id: authRequest.user.id },
        select: {
          // Select only necessary fields
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true, // Good to check isEnabled on /me as well
        },
      });

      if (!user || !user.isEnabled) {
        // If user somehow got disabled after token issuance but before expiry
        reply.clearCookie('token', {
          path: '/',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax',
        });
        return reply.status(401).send({ error: 'User not found or disabled' });
      }

      return {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
      };
    } catch (error) {
      console.error('Get user error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default authRoutes;

```

### apps\api\src\routes\farmer.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createFarmerSchema, updateFarmerSchema, farmerQuerySchema } from '@chaya/shared';
import { Prisma } from '@chaya/shared';
import { generateSurveyNumber } from '../helper';
import Redis from 'ioredis';

const redis = new Redis();

function getFarmersCacheKey(query: any) {
  return `farmers:list:${JSON.stringify(query)}`;
}

async function invalidateFarmersCache(id?: string) {
  const keys = await redis.keys('farmers:list:*');
  if (keys.length) await redis.del(...keys);
}

async function farmerRoutes(fastify: FastifyInstance) {
  fastify.get('/', { preHandler: authenticate }, async (request, reply) => {
    const query = farmerQuerySchema.parse(request.query);
    const cacheKey = getFarmersCacheKey(query);
    const cached = await redis.get(cacheKey);
    if (cached) return JSON.parse(cached);

    const page = query.page || 1;
    const limit = query.limit || 10;
    const skip = (page - 1) * limit;

    const where: Prisma.FarmerWhereInput = {
      isActive: query.isActive,
    };

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { surveyNumber: { contains: query.search, mode: 'insensitive' } },
        { aadharNumber: { contains: query.search, mode: 'insensitive' } },
        { contactNumber: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    if (query.state) where.state = query.state;
    if (query.district) where.district = query.district;
    if (query.gender) where.gender = query.gender;

    const [farmers, totalCount] = await Promise.all([
      prisma.farmer.findMany({
        where,
        include: {
          documents: true,
          bankDetails: true,
          fields: true,
          createdBy: {
            select: {
              id: true,
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      prisma.farmer.count({ where }),
    ]);

    const result = {
      farmers,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
      },
    };

    await redis.set(cacheKey, JSON.stringify(result), 'EX', 3600);
    return result;
  });

  fastify.get('/:id', { preHandler: authenticate }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const cacheKey = `farmers:${id}`;
    const cached = await redis.get(cacheKey);
    if (cached) return { farmer: JSON.parse(cached) };

    const farmer = await prisma.farmer.findUnique({
      where: { id: parseInt(id) },
      include: {
        documents: true,
        bankDetails: true,
        fields: true,
        createdBy: {
          select: {
            id: true,
            name: true,
          },
        },
        updatedBy: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!farmer) {
      return reply.status(404).send({ error: 'Farmer not found' });
    }

    await redis.set(cacheKey, JSON.stringify(farmer), 'EX', 3600);
    return { farmer };
  });

  fastify.post('/', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;
      const { farmer, bankDetails, documents, fields } = createFarmerSchema.parse(request.body);

      const existingFarmer = await prisma.farmer.findFirst({
        where: {
          OR: [{ surveyNumber: farmer.surveyNumber }, { aadharNumber: farmer.aadharNumber }],
        },
      });

      if (existingFarmer) {
        return reply.status(400).send({
          error: 'A farmer with this survey number or Aadhar number already exists',
        });
      }
      const surveyNumber = await generateSurveyNumber();
      const newFarmer = await prisma.farmer.create({
        data: {
          ...farmer,
          surveyNumber,
          createdById: authRequest.user.id,
          updatedById: authRequest.user.id,
          bankDetails: {
            create: bankDetails,
          },
          documents: {
            create: documents,
          },
          fields: {
            create: fields || [],
          },
        },
        include: {
          bankDetails: true,
          documents: true,
          fields: true,
        },
      });

      await invalidateFarmersCache();
      return { farmer: newFarmer };
    } catch (error) {
      if ((error as any).code === 'P2002') {
        return reply.status(400).send({ error: 'Unique constraint violation' });
      }
      return reply.status(400).send({ error: 'Invalid request data' });
    }
  });

  fastify.put('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;
      const { id } = request.params as { id: string };
      const updateData = updateFarmerSchema.parse(request.body);

      const existingFarmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
        include: {
          bankDetails: true,
          documents: true,
          fields: true,
        },
      });

      if (!existingFarmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const updatedFarmer = await prisma.$transaction(async tx => {
        const farmer = await tx.farmer.update({
          where: { id: parseInt(id) },
          data: {
            ...updateData.farmer,
            updatedById: authRequest.user.id,
          },
        });

        if (updateData.bankDetails && existingFarmer.bankDetails) {
          await tx.bankDetails.update({
            where: { farmerId: farmer.id },
            data: updateData.bankDetails,
          });
        } else if (updateData.bankDetails && !existingFarmer.bankDetails) {
          if (
            !updateData.bankDetails.ifscCode ||
            !updateData.bankDetails.bankName ||
            !updateData.bankDetails.branchName ||
            !updateData.bankDetails.accountNumber ||
            !updateData.bankDetails.address ||
            !updateData.bankDetails.bankCode
          ) {
            throw new Error('All bank details fields are required when creating new bank details');
          }
          await tx.bankDetails.create({
            data: {
              ifscCode: updateData.bankDetails.ifscCode,
              bankName: updateData.bankDetails.bankName,
              branchName: updateData.bankDetails.branchName,
              accountNumber: updateData.bankDetails.accountNumber,
              address: updateData.bankDetails.address,
              bankCode: updateData.bankDetails.bankCode,
              farmerId: farmer.id,
            },
          });
        }

        if (updateData.documents && existingFarmer.documents) {
          await tx.farmerDocuments.update({
            where: { farmerId: farmer.id },
            data: updateData.documents,
          });
        } else if (updateData.documents && !existingFarmer.documents) {
          if (
            !updateData.documents.profilePicUrl ||
            !updateData.documents.aadharDocUrl ||
            !updateData.documents.bankDocUrl
          ) {
            throw new Error('All document URLs are required when creating new documents');
          }
          await tx.farmerDocuments.create({
            data: {
              profilePicUrl: updateData.documents.profilePicUrl,
              aadharDocUrl: updateData.documents.aadharDocUrl,
              bankDocUrl: updateData.documents.bankDocUrl,
              farmerId: farmer.id,
            },
          });
        }

        if (updateData.fields?.length) {
          const invalidFields = updateData.fields.filter(
            field => !field.areaHa || !field.yieldEstimate || !field.location || !field.landDocumentUrl
          );
          if (invalidFields.length > 0) {
            throw new Error('All field properties are required when creating new fields');
          }
          await tx.field.deleteMany({
            where: { farmerId: farmer.id },
          });
          await tx.field.createMany({
            data: updateData.fields.map(field => ({
              areaHa: field.areaHa!,
              yieldEstimate: field.yieldEstimate!,
              location: field.location!,
              landDocumentUrl: field.landDocumentUrl!,
              farmerId: farmer.id,
            })),
          });
        }

        return tx.farmer.findUnique({
          where: { id: farmer.id },
          include: {
            bankDetails: true,
            documents: true,
            fields: true,
          },
        });
      });

      await invalidateFarmersCache(id);
      return { farmer: updatedFarmer };
    } catch (error) {
      if (error instanceof Error && error.message.includes('required')) {
        return reply.status(400).send({ error: error.message });
      }
      return reply.status(400).send({ error: 'Invalid request data' });
    }
  });

  fastify.patch('/:id/toggle-status', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const authRequest = request as AuthenticatedRequest;

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const updatedFarmer = await prisma.farmer.update({
        where: { id: parseInt(id) },
        data: {
          isActive: !farmer.isActive,
          updatedById: authRequest.user.id,
        },
        include: {
          bankDetails: true,
          documents: true,
        },
      });

      await invalidateFarmersCache(id);
      return { farmer: updatedFarmer };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(id) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      await prisma.farmer.delete({
        where: { id: parseInt(id) },
      });

      await invalidateFarmersCache(id);
      return { success: true };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/export', { preHandler: authenticate }, async (request, reply) => {
    try {
      const query = farmerQuerySchema.parse(request.query);

      const where: Prisma.FarmerWhereInput = {
        isActive: query.isActive,
      };

      if (query.search) {
        where.OR = [
          { name: { contains: query.search, mode: 'insensitive' } },
          { surveyNumber: { contains: query.search, mode: 'insensitive' } },
          { aadharNumber: { contains: query.search, mode: 'insensitive' } },
          { contactNumber: { contains: query.search, mode: 'insensitive' } },
        ];
      }

      if (query.state) where.state = query.state;
      if (query.district) where.district = query.district;
      if (query.gender) where.gender = query.gender;

      const limit = query.limit || 1000;

      const farmers = await prisma.farmer.findMany({
        where,
        include: {
          bankDetails: true,
        },
        orderBy: { name: 'asc' },
        take: limit,
      });

      const csvData = farmers.map(farmer => ({
        ID: farmer.id,
        SurveyNumber: farmer.surveyNumber,
        Name: farmer.name,
        Gender: farmer.gender,
        Community: farmer.community,
        AadharNumber: farmer.aadharNumber,
        State: farmer.state,
        District: farmer.district,
        Mandal: farmer.mandal,
        Village: farmer.village,
        Panchayath: farmer.panchayath,
        DateOfBirth: farmer.dateOfBirth.toISOString().split('T')[0],
        Age: farmer.age,
        ContactNumber: farmer.contactNumber,
        BankName: farmer.bankDetails?.bankName || '',
        BranchName: farmer.bankDetails?.branchName || '',
        AccountNumber: farmer.bankDetails?.accountNumber || '',
        IFSC: farmer.bankDetails?.ifscCode || '',
      }));

      const headers = Object.keys(csvData[0] || {}).join(',');

      const rows = csvData.map(row => {
        return Object.values(row)
          .map(value => {
            if (typeof value === 'string') {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          })
          .join(',');
      });

      const csv = [headers, ...rows].join('\n');

      reply.header('Content-Type', 'text/csv');
      reply.header('Content-Disposition', 'attachment; filename=farmers.csv');

      return csv;
    } catch (error) {
      return reply.status(400).send({ error: 'Invalid query parameters' });
    }
  });
}

export default farmerRoutes;

```

### apps\api\src\routes\processingBatch.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma, ProcessingStageStatus as PrismaProcessingStageStatus } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createProcessingBatchSchema, processingBatchQuerySchema } from '@chaya/shared';
import { generateProcessingBatchCode } from '../helper';
import Redis from 'ioredis';

const redis = new Redis();

async function invalidateProcessingCache(batchId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*');
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) keysToDelete.push(`processing-batch:${batchId}`);
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

type ExtendedProcessingStageStatus = PrismaProcessingStageStatus | 'SOLD_OUT' | 'NO_STAGES';

async function processingBatchRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const { crop, lotNo, procurementIds, firstStageDetails } = createProcessingBatchSchema.parse(request.body);
      const userId = authUser.id;

      if (!procurementIds || procurementIds.length === 0) {
        return reply.status(400).send({ error: 'At least one procurement ID must be provided.' });
      }

      const procurements = await prisma.procurement.findMany({
        where: {
          id: { in: procurementIds },
          crop: { equals: crop, mode: 'insensitive' },
          lotNo: lotNo,
          processingBatchId: null,
        },
      });

      if (procurements.length !== procurementIds.length) {
        return reply
          .status(400)
          .send({ error: 'One or more procurement IDs are invalid, do not match crop/lot, or are already batched.' });
      }

      const initialBatchQuantity = procurements.reduce((sum, p) => sum + p.quantity, 0);
      if (initialBatchQuantity <= 0) {
        return reply.status(400).send({ error: 'Total quantity for the batch must be positive.' });
      }

      const dateForBatchCode = new Date(firstStageDetails.dateOfProcessing);
      if (isNaN(dateForBatchCode.getTime())) {
        return reply.status(400).send({ error: 'Invalid dateOfProcessing for batch code generation.' });
      }
      const uniqueProcessingBatchCode = await generateProcessingBatchCode(crop, lotNo, dateForBatchCode);

      const result = await prisma.$transaction(
        async tx => {
          const newBatch = await tx.processingBatch.create({
            data: {
              batchCode: uniqueProcessingBatchCode,
              crop,
              lotNo,
              initialBatchQuantity,
              createdById: userId,
              procurements: { connect: procurementIds.map(id => ({ id })) },
            },
          });

          const p1DateOfProcessing = new Date(firstStageDetails.dateOfProcessing);
          if (isNaN(p1DateOfProcessing.getTime())) {
            throw new Error('Invalid dateOfProcessing for P1 stage.');
          }

          await tx.processingStage.create({
            data: {
              processingBatchId: newBatch.id,
              processingCount: 1,
              processMethod: firstStageDetails.processMethod,
              dateOfProcessing: p1DateOfProcessing,
              doneBy: firstStageDetails.doneBy,
              initialQuantity: initialBatchQuantity,
              status: 'IN_PROGRESS',
              createdById: userId,
            },
          });

          return tx.processingBatch.findUnique({
            where: { id: newBatch.id },
            include: { processingStages: { orderBy: { processingCount: 'asc' }, take: 1 } },
          });
        },
        {
          maxWait: 10000,
          timeout: 10000,
        }
      );

      await invalidateProcessingCache();
      return reply.status(201).send({ batch: result });
    } catch (error: any) {
      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2028') {
        console.error('Transaction timeout error:', error);
        return reply.status(500).send({ error: 'Server operation timed out, please try again.' });
      }
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Create processing batch error:', error);
      return reply.status(500).send({ error: 'Server error creating processing batch' });
    }
  });

  fastify.get('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const query = processingBatchQuerySchema.parse(request.query);
    const cacheKey = `processing-batches:list:${JSON.stringify(query)}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) return JSON.parse(cached);

      const page = query.page || 1;
      const limit = query.limit || 10;
      const skip = (page - 1) * limit;

      let where: Prisma.ProcessingBatchWhereInput = {};
      if (query.search) {
        where.OR = [
          { batchCode: { contains: query.search, mode: 'insensitive' } },
          { crop: { contains: query.search, mode: 'insensitive' } },
        ];
      }

      // Fetch all candidate batches based on simple filters first
      const allCandidateBatchesFromDb = await prisma.processingBatch.findMany({
        where, // Apply initial where like search
        include: {
          processingStages: {
            orderBy: { processingCount: 'desc' },
            include: {
              dryingEntries: { orderBy: { day: 'desc' }, take: 1 },
              sales: { select: { quantitySold: true } }, // Eager load sales for each stage
            },
          },
          sales: { select: { quantitySold: true } }, // Overall sales for the batch
        },
        orderBy: { createdAt: 'desc' },
        // No skip/take here yet, apply after status filtering
      });

      const transformedBatches = allCandidateBatchesFromDb.map(batch => {
        const latestStage = batch.processingStages[0]; // Already sorted desc
        let netAvailableFromLatestStage: number = 0;
        let statusForLatestStage: ExtendedProcessingStageStatus = 'NO_STAGES';

        if (latestStage) {
          statusForLatestStage = latestStage.status; // Initial status

          if (latestStage.status === PrismaProcessingStageStatus.IN_PROGRESS) {
            netAvailableFromLatestStage = latestStage.dryingEntries[0]?.currentQuantity ?? latestStage.initialQuantity;
          } else if (latestStage.status === PrismaProcessingStageStatus.FINISHED) {
            const soldFromThisStage = latestStage.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
            netAvailableFromLatestStage = (latestStage.quantityAfterProcess ?? 0) - soldFromThisStage;
            if (netAvailableFromLatestStage <= 0) {
              statusForLatestStage = 'SOLD_OUT';
            }
          } else if (latestStage.status === PrismaProcessingStageStatus.CANCELLED) {
            netAvailableFromLatestStage = 0;
          }
        } else {
          // If NO_STAGES, technically nothing processed is available from a stage.
          // initialBatchQuantity is raw.
          netAvailableFromLatestStage = 0;
        }

        const totalQuantitySoldFromBatchOverall = batch.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);

        return {
          id: batch.id,
          batchCode: batch.batchCode,
          crop: batch.crop,
          lotNo: batch.lotNo,
          initialBatchQuantity: batch.initialBatchQuantity,
          createdAt: batch.createdAt,
          latestStageSummary: latestStage
            ? {
                id: latestStage.id,
                processingCount: latestStage.processingCount,
                status: statusForLatestStage, // Use the derived status
                processMethod: latestStage.processMethod,
                dateOfProcessing: latestStage.dateOfProcessing,
                doneBy: latestStage.doneBy,
                initialQuantity: latestStage.initialQuantity,
                quantityAfterProcess: latestStage.quantityAfterProcess, // This is the stage's yield
                lastDryingQuantity: latestStage.dryingEntries[0]?.currentQuantity ?? null,
              }
            : null,
          totalQuantitySoldFromBatch: totalQuantitySoldFromBatchOverall,
          netAvailableQuantity: netAvailableFromLatestStage, // This is key: net from the LATEST stage
        };
      });

      // Now filter by query.status if it exists
      const statusFilteredBatches = query.status
        ? transformedBatches.filter(b => b.latestStageSummary?.status === query.status)
        : transformedBatches;

      const finalTotalCount = statusFilteredBatches.length;
      const paginatedBatches = statusFilteredBatches.slice(skip, skip + limit);

      const result = {
        processingBatches: paginatedBatches,
        pagination: { page, limit, totalCount: finalTotalCount, totalPages: Math.ceil(finalTotalCount / limit) },
      };
      await redis.set(cacheKey, JSON.stringify(result), 'EX', 3600); // Cache for 1 hour
      return result;
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid query parameters', details: error.issues });
      console.error('Get processing batches error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:batchId', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { batchId } = request.params as { batchId: string };
    console.log(batchId);
    const id = parseInt(batchId);
    if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Batch ID' });

    const cacheKey = `processing-batch:${id}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        try {
          const parsedCached = JSON.parse(cached);
          // Recalculate latestStageSummary.status for cache, as sales might have happened
          const latestStageForCached = parsedCached.processingStages
            ?.slice()
            .sort((a: any, b: any) => b.processingCount - a.processingCount)[0];
          let effectiveStatusCached: ExtendedProcessingStageStatus = latestStageForCached
            ? latestStageForCached.status
            : 'NO_STAGES';
          let netAvailableFromLatestStageCached = 0;

          if (latestStageForCached) {
            if (latestStageForCached.status === PrismaProcessingStageStatus.IN_PROGRESS) {
              netAvailableFromLatestStageCached =
                latestStageForCached.dryingEntries?.slice().sort((a: any, b: any) => b.day - a.day)[0]
                  ?.currentQuantity ?? latestStageForCached.initialQuantity;
            } else if (latestStageForCached.status === PrismaProcessingStageStatus.FINISHED) {
              const salesFromThisStageCached =
                latestStageForCached.sales?.reduce((sum: number, sale: any) => sum + sale.quantitySold, 0) || 0;
              netAvailableFromLatestStageCached =
                (latestStageForCached.quantityAfterProcess || 0) - salesFromThisStageCached;
              if (netAvailableFromLatestStageCached <= 0) effectiveStatusCached = 'SOLD_OUT';
            } else if (latestStageForCached.status === PrismaProcessingStageStatus.CANCELLED) {
              netAvailableFromLatestStageCached = 0;
            }
            parsedCached.netAvailableQuantity = netAvailableFromLatestStageCached; // Overall "available" is what's from latest stage
            if (parsedCached.latestStageSummary) {
              parsedCached.latestStageSummary.status = effectiveStatusCached;
            } else if (latestStageForCached) {
              // Reconstruct if old cache didn't have latestStageSummary
              parsedCached.latestStageSummary = {
                id: latestStageForCached.id,
                processingCount: latestStageForCached.processingCount,
                status: effectiveStatusCached,
                processMethod: latestStageForCached.processMethod,
                dateOfProcessing: latestStageForCached.dateOfProcessing,
                doneBy: latestStageForCached.doneBy,
                initialQuantity: latestStageForCached.initialQuantity,
                quantityAfterProcess: latestStageForCached.quantityAfterProcess,
                lastDryingQuantity:
                  latestStageForCached.dryingEntries?.slice().sort((a: any, b: any) => b.day - a.day)[0]
                    ?.currentQuantity ?? null,
              };
            }
          } else {
            parsedCached.netAvailableQuantity = 0; // No stages, so 0 available from stages
          }
          // totalQuantitySoldFromBatch is fine as is (sum of all sales from batch)
          return parsedCached;
        } catch (e) {
          console.warn('Error parsing or re-evaluating cache for batch detail, fetching fresh.', e);
          // Fall through to fetch fresh if cache is malformed or re-evaluation fails
        }
      }

      const batchFromDb = await prisma.processingBatch.findUnique({
        where: { id },
        include: {
          procurements: { include: { farmer: { select: { name: true, village: true } } } },
          processingStages: {
            include: {
              dryingEntries: { orderBy: { day: 'asc' } },
              sales: { select: { id: true, quantitySold: true, dateOfSale: true } }, // Eager load sales for each stage
            },
            orderBy: { processingCount: 'asc' },
          },
          sales: {
            // Overall sales for the batch
            orderBy: { dateOfSale: 'desc' },
            include: { processingStage: { select: { processingCount: true } } },
          },
          createdBy: { select: { id: true, name: true } },
        },
      });

      if (!batchFromDb) return reply.status(404).send({ error: 'Processing batch not found' });

      // Sort stages in descending order of processingCount to easily get the latest
      const sortedStages = [...batchFromDb.processingStages].sort((a, b) => b.processingCount - a.processingCount);
      const latestStageData = sortedStages[0];

      let netAvailableFromLatestStageQty: number = 0;
      let effectiveStatusForLatestStage: ExtendedProcessingStageStatus = 'NO_STAGES';
      let latestStageSummaryData = null;

      if (latestStageData) {
        effectiveStatusForLatestStage = latestStageData.status;
        if (latestStageData.status === PrismaProcessingStageStatus.IN_PROGRESS) {
          const latestDrying = latestStageData.dryingEntries.sort((a, b) => b.day - a.day)[0];
          netAvailableFromLatestStageQty = latestDrying?.currentQuantity ?? latestStageData.initialQuantity;
        } else if (latestStageData.status === PrismaProcessingStageStatus.FINISHED) {
          const salesFromThisStage = latestStageData.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
          netAvailableFromLatestStageQty = (latestStageData.quantityAfterProcess ?? 0) - salesFromThisStage;
          if (netAvailableFromLatestStageQty <= 0) {
            effectiveStatusForLatestStage = 'SOLD_OUT';
          }
        } else if (latestStageData.status === PrismaProcessingStageStatus.CANCELLED) {
          netAvailableFromLatestStageQty = 0;
        }

        latestStageSummaryData = {
          id: latestStageData.id,
          processingCount: latestStageData.processingCount,
          status: effectiveStatusForLatestStage,
          processMethod: latestStageData.processMethod,
          dateOfProcessing: latestStageData.dateOfProcessing,
          doneBy: latestStageData.doneBy,
          initialQuantity: latestStageData.initialQuantity,
          quantityAfterProcess: latestStageData.quantityAfterProcess,
          lastDryingQuantity: latestStageData.dryingEntries.sort((a, b) => b.day - a.day)[0]?.currentQuantity ?? null,
        };
      } else {
        netAvailableFromLatestStageQty = 0; // No stages, nothing available from stages
      }

      const totalQuantitySoldFromBatchOverall = batchFromDb.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);

      const batchWithDetails = {
        ...batchFromDb,
        totalQuantitySoldFromBatch: totalQuantitySoldFromBatchOverall,
        netAvailableQuantity: netAvailableFromLatestStageQty, // Key change: This reflects what's available from latest stage
        latestStageSummary: latestStageSummaryData,
      };

      await redis.set(cacheKey, JSON.stringify(batchWithDetails), 'EX', 3600);
      return batchWithDetails;
    } catch (error) {
      console.error(`Error fetching batch ${id}:`, error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:batchId', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { batchId } = request.params as { batchId: string };
    const id = parseInt(batchId);
    if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Batch ID' });

    try {
      const batch = await prisma.processingBatch.findUnique({ where: { id } });
      if (!batch) return reply.status(404).send({ error: 'Processing batch not found.' });

      await prisma.$transaction(async tx => {
        await tx.procurement.updateMany({
          where: { processingBatchId: id },
          data: { processingBatchId: null },
        });
        await tx.processingBatch.delete({ where: { id } });
      });

      await invalidateProcessingCache(id);
      return { success: true, message: `Processing batch ${batch.batchCode} deleted.` };
    } catch (error) {
      console.error(`Error deleting batch ${id}:`, error);
      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
        // This might occur if the batch was already deleted by another request.
        return reply.status(404).send({ error: 'Processing batch not found or already deleted.' });
      }
      return reply.status(500).send({ error: 'Server error deleting batch.' });
    }
  });

  return fastify;
}

export default processingBatchRoutes;

```

### apps\api\src\routes\sales.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma } from '@chaya/shared';
import { authenticate, verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { createSaleSchema } from '@chaya/shared';
import Redis from 'ioredis';

const redis = new Redis();

async function invalidateSalesCache(batchId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*');
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) keysToDelete.push(`processing-batch:${batchId}`);
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

async function salesRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const userId = authUser.id;
      const parsedSaleData = createSaleSchema.parse(request.body);
      const { processingBatchId, processingStageId, quantitySold, dateOfSale } = parsedSaleData;

      const stage = await prisma.processingStage.findUnique({
        where: { id: processingStageId },
        include: { processingBatch: true },
      });

      if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
      if (stage.processingBatchId !== processingBatchId) {
        return reply.status(400).send({ error: 'Stage does not belong to the specified batch.' });
      }
      if (stage.status !== 'FINISHED') {
        return reply.status(400).send({ error: 'Sales can only be recorded from FINISHED processing stages.' });
      }

      const salesFromThisStage = await prisma.sale.aggregate({
        _sum: { quantitySold: true },
        where: { processingStageId: stage.id },
      });
      const alreadySoldFromStage = salesFromThisStage._sum.quantitySold || 0;
      const availableFromStage = (stage.quantityAfterProcess || 0) - alreadySoldFromStage;

      if (availableFromStage < quantitySold) {
        return reply.status(400).send({
          error: `Insufficient quantity available from stage P${stage.processingCount}. Available: ${availableFromStage.toFixed(2)} kg.`,
        });
      }

      const newSale = await prisma.sale.create({
        data: {
          processingBatchId,
          processingStageId,
          quantitySold,
          dateOfSale,
          createdById: userId,
        },
      });

      await invalidateSalesCache(processingBatchId);
      return reply.status(201).send(newSale);
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Record sale error:', error);
      return reply.status(500).send({ error: 'Server error recording sale' });
    }
  });

  // GET route remains the same
  fastify.get('/', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const { processingBatchId, processingStageId } = request.query as {
      processingBatchId?: string;
      processingStageId?: string;
    };
    const where: Prisma.SaleWhereInput = {};
    if (processingBatchId) where.processingBatchId = parseInt(processingBatchId);
    if (processingStageId) where.processingStageId = parseInt(processingStageId);

    const sales = await prisma.sale.findMany({
      where,
      include: {
        processingBatch: { select: { batchCode: true, crop: true } },
        processingStage: { select: { processingCount: true } },
        createdBy: { select: { name: true } },
      },
      orderBy: { dateOfSale: 'desc' },
    });
    return sales;
  });
}

export default salesRoutes;

```

### apps\api\src\routes\procurement.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin } from '../middlewares/auth';
import { createProcurementSchema, updateProcurementSchema, procurementQuerySchema } from '@chaya/shared';
import { generateProcurementNumber } from '../helper';
import { Prisma } from '@prisma/client';
import { format } from 'date-fns';

async function procurementRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { farmerId, crop, procuredForm, speciality, quantity, date, time, lotNo, procuredBy, vehicleNo } =
        createProcurementSchema.parse(request.body);

      const combinedDateTime = new Date(`${date.toISOString().split('T')[0]}T${time}`);
      if (isNaN(combinedDateTime.getTime())) {
        return reply.status(400).send({ error: 'Invalid date or time combination' });
      }

      const procurementNumber = generateProcurementNumber(crop, date, lotNo);

      const existingProcurement = await prisma.procurement.findUnique({
        where: { procurementNumber },
      });

      if (existingProcurement) {
        return reply.status(400).send({
          error: 'Procurement number already exists. This might indicate a duplicate entry or a hash collision (rare).',
        });
      }

      const farmerExists = await prisma.farmer.findUnique({ where: { id: farmerId } });
      if (!farmerExists) {
        return reply.status(404).send({ error: 'Farmer not found.' });
      }

      const procurement = await prisma.procurement.create({
        data: {
          farmerId,
          crop,
          procuredForm,
          speciality,
          quantity,
          procurementNumber,
          date,
          time: combinedDateTime,
          lotNo,
          procuredBy,
          vehicleNo,
        },
      });

      return { procurement };
    } catch (error: any) {
      if (error.issues) {
        return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      }
      console.error('Create procurement error:', error);
      return reply.status(500).send({ error: 'Server error creating procurement' });
    }
  });

  fastify.get('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const {
        page,
        limit,
        search,
        farmerId,
        crop,
        lotNo: queryLotNo,
        isBatched,
      } = procurementQuerySchema.parse(request.query);
      const skip = (page - 1) * limit;
      const where: Prisma.ProcurementWhereInput = {};

      if (search) {
        where.OR = [
          { procurementNumber: { contains: search, mode: 'insensitive' } },
          { crop: { contains: search, mode: 'insensitive' } },
          { procuredBy: { contains: search, mode: 'insensitive' } },
          { farmer: { name: { contains: search, mode: 'insensitive' } } },
        ];
      }
      if (farmerId) where.farmerId = farmerId;
      if (crop) where.crop = { contains: crop, mode: 'insensitive' };
      if (queryLotNo) where.lotNo = queryLotNo;

      if (typeof isBatched === 'boolean') {
        where.processingBatchId = isBatched ? { not: null } : { equals: null };
      }

      const [procurements, totalCount] = await Promise.all([
        prisma.procurement.findMany({
          where,
          include: {
            farmer: { select: { id: true, name: true, village: true, panchayath: true, mandal: true } },
            processingBatch: { select: { id: true, batchCode: true } },
          },
          orderBy: { createdAt: 'desc' },
          skip,
          take: limit,
        }),
        prisma.procurement.count({ where }),
      ]);

      return {
        procurements,
        pagination: { page, limit, totalCount, totalPages: Math.ceil(totalCount / limit) },
      };
    } catch (error: any) {
      if (error.issues) {
        return reply.status(400).send({ error: 'Invalid query parameters', details: error.issues });
      }
      console.error('Get procurements error:', error);
      return reply.status(500).send({ error: 'Server error fetching procurements' });
    }
  });

  fastify.get('/unbatched', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { crop, lotNo } = request.query as { crop?: string; lotNo?: string }; // Removed procuredForm as it's not used here

      const whereClause: Prisma.ProcurementWhereInput = {
        processingBatchId: null,
      };

      if (crop) {
        whereClause.crop = { equals: crop, mode: 'insensitive' };
      }
      if (lotNo) {
        const parsedLotNo = parseInt(lotNo, 10);
        if (!isNaN(parsedLotNo)) {
          whereClause.lotNo = parsedLotNo;
        }
      }

      const unbatchedProcurements = await prisma.procurement.findMany({
        where: whereClause,
        include: { farmer: { select: { name: true, village: true } } },
        orderBy: [{ date: 'asc' }, { id: 'asc' }],
        take: 500,
      });
      return { procurements: unbatchedProcurements };
    } catch (error) {
      console.error('Error fetching unbatched procurements:', error);
      // Log the actual Prisma error if it's a Prisma error
      if (
        error instanceof Prisma.PrismaClientKnownRequestError ||
        error instanceof Prisma.PrismaClientValidationError
      ) {
        console.error('Prisma Error Meta:', (error as any).meta);
      }
      return reply.status(500).send({ error: 'Failed to fetch unbatched procurements' });
    }
  });

  fastify.get('/:id', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const procurement = await prisma.procurement.findUnique({
        where: { id: procurementId },
        include: {
          farmer: { select: { name: true, village: true, panchayath: true, mandal: true } },
          processingBatch: { select: { id: true, batchCode: true } },
        },
      });

      if (!procurement) return reply.status(404).send({ error: 'Procurement not found' });
      return { procurement };
    } catch (error) {
      console.error('Get procurement error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.put('/:id', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const data = updateProcurementSchema.parse({ ...(request.body as object), id: procurementId });

      const existingProcurement = await prisma.procurement.findUnique({ where: { id: procurementId } });
      if (!existingProcurement) return reply.status(404).send({ error: 'Procurement not found' });
      if (existingProcurement.processingBatchId) {
        return reply.status(400).send({ error: 'Cannot edit procurement already assigned to a processing batch.' });
      }

      let combinedDateTime;
      const newDate = data.date ? data.date : existingProcurement.date;
      const newTimeStr = data.time ? data.time : format(existingProcurement.time, 'HH:mm:ss');

      combinedDateTime = new Date(`${format(newDate, 'yyyy-MM-dd')}T${newTimeStr}`);

      if (isNaN(combinedDateTime.getTime())) {
        return reply.status(400).send({ error: 'Invalid date or time combination resulted' });
      }

      const updatedProcurement = await prisma.procurement.update({
        where: { id: procurementId },
        data: {
          farmerId: data.farmerId,
          crop: data.crop,
          procuredForm: data.procuredForm,
          speciality: data.speciality,
          quantity: data.quantity,
          date: data.date,
          time: combinedDateTime,
          lotNo: data.lotNo,
          procuredBy: data.procuredBy,
          vehicleNo: data.vehicleNo,
        },
      });
      return { procurement: updatedProcurement };
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Update procurement error:', error);
      return reply.status(500).send({ error: 'Server error updating procurement' });
    }
  });

  fastify.delete('/:id', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { id } = request.params as { id: string };
      const procurementId = parseInt(id);
      if (isNaN(procurementId)) return reply.status(400).send({ error: 'Invalid ID format.' });

      const procurement = await prisma.procurement.findUnique({ where: { id: procurementId } });
      if (!procurement) return reply.status(404).send({ error: 'Procurement not found' });
      if (procurement.processingBatchId) {
        return reply.status(400).send({
          error: 'Cannot delete procurement already assigned to a processing batch. Remove from batch first.',
        });
      }

      await prisma.procurement.delete({ where: { id: procurementId } });
      return { success: true };
    } catch (error) {
      console.error('Delete procurement error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/bulk', { preHandler: [verifyAdmin] }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const { ids } = request.body as { ids?: number[] };
      if (!Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({ error: 'Invalid or empty list of IDs' });
      }
      const validIds = ids.filter(id => typeof id === 'number' && !isNaN(id));
      if (validIds.length !== ids.length) {
        return reply.status(400).send({ error: 'All IDs must be numbers.' });
      }

      const batchedProcurements = await prisma.procurement.count({
        where: { id: { in: validIds }, processingBatchId: { not: null } },
      });
      if (batchedProcurements > 0) {
        return reply
          .status(400)
          .send({ error: 'One or more selected procurements are part of a batch and cannot be deleted.' });
      }

      const { count } = await prisma.procurement.deleteMany({ where: { id: { in: validIds } } });
      return { success: true, message: `${count} procurements deleted.` };
    } catch (error) {
      console.error('Bulk delete procurements error:', error);
      return reply.status(500).send({ error: 'Server error during bulk delete' });
    }
  });
}

export default procurementRoutes;

```

### apps\api\src\routes\users.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { verifyAdmin, type AuthenticatedRequest } from '../middlewares/auth';
import { updateUserSchema } from '@chaya/shared';
import { hashPassword } from '../lib/password';
import Redis from 'ioredis';

const redis = new Redis();

async function userRoutes(fastify: FastifyInstance) {
  fastify.get('/', { preHandler: verifyAdmin }, async (request, reply) => {
    const cacheKey = 'users:all';
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        return { users: JSON.parse(cached) };
      }
      const users = await prisma.user.findMany({
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          createdAt: true,
        },
        orderBy: { createdAt: 'desc' },
      });
      await redis.set(cacheKey, JSON.stringify(users), 'EX', 3600);
      return { users };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const cacheKey = `users:${id}`;
    try {
      const cached = await redis.get(cacheKey);
      if (cached) {
        return { user: JSON.parse(cached) };
      }
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          createdAt: true,
        },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      await redis.set(cacheKey, JSON.stringify(user), 'EX', 3600);
      return { user };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.put('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const userData = updateUserSchema.parse(request.body);
      const existingUser = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!existingUser) {
        return reply.status(404).send({ error: 'User not found' });
      }
      const updateData: any = {};
      if (userData.name) updateData.name = userData.name;
      if (userData.email) updateData.email = userData.email;
      if (userData.isEnabled !== undefined) updateData.isEnabled = userData.isEnabled;
      if (userData.password) {
        updateData.password = await hashPassword(userData.password);
      }
      const updatedUser = await prisma.user.update({
        where: { id: parseInt(id) },
        data: updateData,
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
          isActive: true,
          lastLoginAt: true,
          updatedAt: true,
        },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { user: updatedUser };
    } catch (error) {
      return reply.status(400).send({ error: 'Invalid request' });
    }
  });

  fastify.patch('/:id/toggle-status', { preHandler: verifyAdmin }, async (request, reply) => {
    const authRequest = request as AuthenticatedRequest;
    try {
      const { id } = authRequest.params as { id: string };
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      const updatedUser = await prisma.user.update({
        where: { id: parseInt(id) },
        data: { isEnabled: !user.isEnabled },
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isEnabled: true,
        },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { user: updatedUser };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
      });
      if (!user) {
        return reply.status(404).send({ error: 'User not found' });
      }
      if (user.role === 'ADMIN') {
        return reply.status(403).send({ error: 'Cannot delete admin users' });
      }
      await prisma.user.delete({
        where: { id: parseInt(id) },
      });
      await redis.del(`users:${id}`);
      await redis.del('users:all');
      return { success: true };
    } catch (error) {
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default userRoutes;

```

### apps\api\src\routes\fields.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';
import { authenticate, verifyAdmin } from '../middlewares/auth';
import type { AuthenticatedRequest } from '../middlewares/auth';

import { fieldSchema } from '@chaya/shared';

async function fieldRoutes(fastify: FastifyInstance) {
  fastify.get('/farmer/:farmerId', { preHandler: authenticate }, async (request, reply) => {
    try {
      const { farmerId } = request.params as { farmerId: string };

      const fields = await prisma.field.findMany({
        where: { farmerId: parseInt(farmerId) },
        orderBy: { createdAt: 'desc' },
      });

      return { fields };
    } catch (error) {
      console.error('Get fields error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.get('/:id', { preHandler: authenticate }, async (request, reply) => {
    try {
      const { id } = request.params as { id: string };

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      return { field };
    } catch (error) {
      console.error('Get field error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });

  fastify.post('/farmer/:farmerId', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { farmerId } = request.params as { farmerId: string };
      const fieldData = fieldSchema.parse(request.body);

      const farmer = await prisma.farmer.findUnique({
        where: { id: parseInt(farmerId) },
      });

      if (!farmer) {
        return reply.status(404).send({ error: 'Farmer not found' });
      }

      const field = await prisma.field.create({
        data: {
          ...fieldData,
          farmerId: parseInt(farmerId),
        },
      });

      await prisma.farmer.update({
        where: { id: parseInt(farmerId) },
        data: { updatedById: authRequest.user.id },
      });

      return { field };
    } catch (error) {
      console.error('Create field error:', error);
      return reply.status(400).send({ error: 'Invalid field data' });
    }
  });

  fastify.put('/:id', { preHandler: authenticate }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { id } = request.params as { id: string };
      const fieldData = fieldSchema.parse(request.body);

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      if (authRequest.user.role !== 'ADMIN') {
        const farmer = await prisma.farmer.findUnique({
          where: { id: field.farmerId },
        });

        if (farmer?.createdById !== authRequest.user.id) {
          return reply.status(403).send({ error: 'Not authorized to update this field' });
        }
      }

      const updatedField = await prisma.field.update({
        where: { id: parseInt(id) },
        data: fieldData,
      });

      await prisma.farmer.update({
        where: { id: field.farmerId },
        data: { updatedById: authRequest.user.id },
      });

      return { field: updatedField };
    } catch (error) {
      console.error('Update field error:', error);
      return reply.status(400).send({ error: 'Invalid field data' });
    }
  });

  fastify.delete('/:id', { preHandler: verifyAdmin }, async (request, reply) => {
    try {
      const authRequest = request as AuthenticatedRequest;

      const { id } = request.params as { id: string };

      const field = await prisma.field.findUnique({
        where: { id: parseInt(id) },
      });

      if (!field) {
        return reply.status(404).send({ error: 'Field not found' });
      }

      await prisma.field.delete({
        where: { id: parseInt(id) },
      });

      await prisma.farmer.update({
        where: { id: field.farmerId },
        data: { updatedById: authRequest.user.id },
      });

      return { success: true };
    } catch (error) {
      console.error('Delete field error:', error);
      return reply.status(500).send({ error: 'Server error' });
    }
  });
}

export default fieldRoutes;

```

### apps\api\src\routes\helloWorld.ts:
```
import type { FastifyInstance } from 'fastify';
import { prisma } from '@chaya/shared';

const createPing = async () => {
  const ping = await prisma.ping.create({
    data: {},
  });
  console.log('Created Ping:', ping);
  return ping;
};

async function helloWorldRoutes(fastify: FastifyInstance) {
  fastify.get('/hello', async (request, reply) => {
    const ping = await createPing();
    return { hello: 'world', ping };
  });
}

export default helloWorldRoutes;

```

### apps\api\src\routes\processingStage.ts:
```
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import { prisma, Prisma, ProcessingStageStatus } from '@chaya/shared';
import { authenticate, type AuthenticatedRequest } from '../middlewares/auth';
import { createProcessingStageSchema, finalizeProcessingStageSchema, createDryingEntrySchema } from '@chaya/shared';
import Redis from 'ioredis';

const redis = new Redis();

async function invalidateStageRelatedCache(batchId?: number | string, stageId?: number | string) {
  const keysToDelete: string[] = [];
  const listKeys = await redis.keys('processing-batches:list:*'); // Invalidate general list
  if (listKeys.length) keysToDelete.push(...listKeys);
  if (batchId) {
    keysToDelete.push(`processing-batch:${batchId}`); // Invalidate specific batch detail
  }
  // No specific stage cache assumed, but if added, invalidate here.
  if (keysToDelete.length) await redis.del(...keysToDelete);
}

async function processingStageRoutes(fastify: FastifyInstance) {
  fastify.post('/', { preHandler: [authenticate] }, async (request: FastifyRequest, reply: FastifyReply) => {
    const authUser = (request as AuthenticatedRequest).user;
    try {
      const userId = authUser.id;
      const { processingBatchId, previousStageId, processMethod, dateOfProcessing, doneBy } =
        createProcessingStageSchema.parse(request.body);

      const batch = await prisma.processingBatch.findUnique({
        where: { id: processingBatchId },
        include: {
          processingStages: {
            orderBy: { processingCount: 'desc' },
            take: 1,
            // Crucially, include sales for the previous stage to calculate net yield
            include: { sales: { select: { quantitySold: true } } },
          },
        },
      });

      if (!batch) return reply.status(404).send({ error: 'Processing batch not found.' });

      const latestStageFromBatch = batch.processingStages[0]; // This is the actual previous stage
      if (!latestStageFromBatch)
        return reply.status(400).send({ error: 'No initial stage found for this batch. Cannot start a new stage.' });

      // Validate payload's previousStageId against actual latest stage
      if (previousStageId !== latestStageFromBatch.id) {
        return reply.status(400).send({
          error: 'Mismatch: previousStageId from payload does not match the actual latest stage of the batch.',
        });
      }

      if (latestStageFromBatch.status !== ProcessingStageStatus.FINISHED) {
        return reply.status(400).send({ error: 'The latest processing stage must be FINISHED to start a new one.' });
      }

      if (latestStageFromBatch.quantityAfterProcess === null || latestStageFromBatch.quantityAfterProcess <= 0) {
        return reply.status(400).send({ error: 'Previous stage has no output quantity (yield) to process further.' });
      }

      // Calculate quantity sold specifically from this latestStage (the previous stage)
      const soldFromLatestStage = latestStageFromBatch.sales.reduce((sum, sale) => sum + sale.quantitySold, 0);
      const netYieldFromPreviousStage = (latestStageFromBatch.quantityAfterProcess || 0) - soldFromLatestStage;

      if (netYieldFromPreviousStage <= 0) {
        return reply.status(400).send({
          error: `Previous stage (P${latestStageFromBatch.processingCount}) has no remaining quantity after sales to start a new stage. Available: ${netYieldFromPreviousStage.toFixed(2)}kg.`,
        });
      }

      const newStage = await prisma.processingStage.create({
        data: {
          processingBatchId,
          processingCount: latestStageFromBatch.processingCount + 1,
          processMethod,
          dateOfProcessing, // Already a Date object from Zod transform
          doneBy,
          initialQuantity: netYieldFromPreviousStage, // Use net yield from previous
          status: ProcessingStageStatus.IN_PROGRESS,
          createdById: userId,
        },
      });

      await invalidateStageRelatedCache(processingBatchId, newStage.id.toString());
      return reply.status(201).send(newStage);
    } catch (error: any) {
      if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
      console.error('Create processing stage error:', error);
      return reply.status(500).send({ error: 'Server error creating processing stage' });
    }
  });

  fastify.put(
    '/:stageId/finalize',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        const { dateOfCompletion, quantityAfterProcess } = finalizeProcessingStageSchema.parse(request.body);

        const stage = await prisma.processingStage.findUnique({ where: { id } });
        if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
        if (stage.status === ProcessingStageStatus.FINISHED || stage.status === ProcessingStageStatus.CANCELLED)
          return reply.status(400).send({ error: `Stage is already ${stage.status.toLowerCase()}.` });
        if (stage.status !== ProcessingStageStatus.IN_PROGRESS) {
          return reply.status(400).send({ error: 'Stage must be IN_PROGRESS to be finalized.' });
        }

        // Validate quantityAfterProcess against latest drying entry or initial quantity if no drying.
        // This is more of a soft validation / warning territory than a hard block for flexibility.
        // const latestDryingEntry = await prisma.drying.findFirst({
        //   where: { processingStageId: id },
        //   orderBy: { day: 'desc' },
        // });
        // const referenceQuantity = latestDryingEntry?.currentQuantity ?? stage.initialQuantity;
        // if (quantityAfterProcess > referenceQuantity) {
        //    console.warn(`Finalize quantity ${quantityAfterProcess}kg exceeds reference quantity ${referenceQuantity}kg for stage ${id}.`);
        // }

        const updatedStage = await prisma.processingStage.update({
          where: { id },
          data: {
            dateOfCompletion,
            quantityAfterProcess,
            status: ProcessingStageStatus.FINISHED,
          },
        });

        await invalidateStageRelatedCache(updatedStage.processingBatchId, updatedStage.id.toString());
        return updatedStage;
      } catch (error: any) {
        if (error.issues) return reply.status(400).send({ error: 'Invalid request data', details: error.issues });
        console.error('Finalize stage error:', error);
        return reply.status(500).send({ error: 'Server error finalizing stage' });
      }
    }
  );

  fastify.post(
    '/:stageId/drying',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        // The `processingStageId` will be set by the schema using `id` from params
        const data = createDryingEntrySchema.parse({ ...(request.body as object), processingStageId: id });

        const stage = await prisma.processingStage.findUnique({ where: { id } });
        if (!stage) return reply.status(404).send({ error: 'Processing stage not found.' });
        if (stage.status !== ProcessingStageStatus.IN_PROGRESS) {
          return reply.status(400).send({ error: 'Can only add drying data to IN_PROGRESS stages.' });
        }

        const existingDryingForDay = await prisma.drying.findFirst({
          where: { processingStageId: id, day: data.day },
        });
        if (existingDryingForDay) {
          return reply.status(400).send({ error: `Drying data for day ${data.day} already exists for this stage.` });
        }

        // if (data.currentQuantity > stage.initialQuantity) {
        // Potentially too strict if initial quantity was an estimate.
        // console.warn(`Drying current quantity ${data.currentQuantity} exceeds stage initial quantity ${stage.initialQuantity}`);
        // }

        const newDryingEntry = await prisma.drying.create({ data });

        // No need to invalidate full batch detail from here for drying,
        // but list summary *might* change if it shows latest drying Qty.
        // The `refreshCurrentPageSummary` in frontend often handles this need,
        // or more specific cache updates if drying affects summary directly.
        // For simplicity and correctness, invalidating related caches is safer.
        await invalidateStageRelatedCache(stage.processingBatchId, stage.id.toString());
        return reply.status(201).send(newDryingEntry);
      } catch (error: any) {
        if (error.issues)
          return reply.status(400).send({ error: 'Invalid request data for drying entry', details: error.issues });
        console.error('Add drying data error:', error);
        return reply.status(500).send({ error: 'Server error adding drying data' });
      }
    }
  );

  fastify.get(
    '/:stageId/drying',
    { preHandler: [authenticate] },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const { stageId } = request.params as { stageId: string };
        const id = parseInt(stageId);
        if (isNaN(id)) return reply.status(400).send({ error: 'Invalid Stage ID' });

        const dryingEntries = await prisma.drying.findMany({
          where: { processingStageId: id },
          orderBy: { day: 'asc' },
        });
        return { dryingEntries };
      } catch (error) {
        console.error('Get drying data error:', error);
        return reply.status(500).send({ error: 'Server error fetching drying data' });
      }
    }
  );
}
export default processingStageRoutes;

```

### apps\api\src\middlewares\auth.ts:
```
import type { FastifyRequest, FastifyReply } from 'fastify';
import { prisma } from '@chaya/shared';

export interface JWTPayload {
  id: number;
  role: 'ADMIN' | 'STAFF';
  iat: number;
  exp: number;
}

export async function authenticate(request: FastifyRequest, reply: FastifyReply) {
  try {
    const token = request.cookies.token;
    if (!token) {
      console.log('No token found in cookies');
      reply.status(401).send({ error: 'Authentication required' });
      return false;
    }
    const decoded = request.server.jwt.verify<JWTPayload>(token);
    const user = await prisma.user.findUnique({
      where: { id: decoded.id, isEnabled: true },
    });
    if (!user) {
      console.log('User not found or disabled');
      reply.status(401).send({ error: 'User not found or disabled' });
      return false;
    }
    (request as any).user = decoded;
    return true;
  } catch (error) {
    console.error('Authentication error:', error);
    reply.status(401).send({ error: 'Invalid or expired token' });
    return false;
  }
}

export async function verifyAdmin(request: FastifyRequest, reply: FastifyReply) {
  const isAuthenticated = await authenticate(request, reply);
  if (!isAuthenticated) return false;

  const user = (request as any).user as JWTPayload;
  if (!user || user.role !== 'ADMIN') {
    console.log('User is not an admin. Role:', user?.role);
    reply.status(403).send({ error: 'Admin access required' });
    return false;
  }
  return true;
}

export interface AuthenticatedRequest extends FastifyRequest {
  user: JWTPayload;
}

```

### apps\api\src\lib\password.ts:
```
import { hash, compare } from 'bcryptjs';

// Hash a password
export async function hashPassword(password: string): Promise<string> {
  return hash(password, 12);
}

// Verify a password against a hash
export async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
  return compare(password, hashedPassword);
}

```

### packages\ui\eslint.config.js:
```
import { config } from '@workspace/eslint-config/react-internal';

/** @type {import("eslint").Linter.Config} */
export default config;

```

### packages\shared\prisma\seed.ts:
```
import { PrismaClient, Role, Gender, Relationship, ProcessingStageStatus } from '@prisma/client';
import { hashPassword } from '../../../apps/api/src/lib/password.js';

const prisma = new PrismaClient();

// Crop and ProcuredForm definitions matching your new requirements
const CROP_PROCURED_FORMS = {
  Turmeric: ['Fresh Finger', 'Fresh Bulb', 'Dried Finger', 'Dried Bulb'],
  Coffee: ['Fruit', 'Dry Cherry', 'Parchment'],
  Ginger: ['Fresh', 'Dried'],
  Pepper: ['Green Pepper', 'Black Pepper'],
  Wheat: ['Raw Grain', 'Cleaned Grain'], // Added Wheat for existing seed logic
} as const;

type SeedCropType = keyof typeof CROP_PROCURED_FORMS;

function generateProcurementNumberForSeed(
  crop: string,
  date: Date | undefined,
  lotNo: number,
  counter: number
): string {
  if (!date) {
    console.warn('Date is undefined for generateProcurementNumberForSeed. Using current date as fallback.');
    date = new Date();
  }
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = date.toISOString().split('T')[0]?.replace(/-/g, '') || 'NODATE';
  const lotCode = lotNo.toString();
  const counterStr = counter.toString().padStart(3, '0');

  return `${cropCode}${dateCode}${lotCode}${counterStr}`.padEnd(16, 'X'); // Increased length slightly
}

function generateProcessingBatchCodeForSeed(
  crop: string,
  lotNo: number,
  dateOfProcessing: Date | undefined,
  counter: number
): string {
  if (!dateOfProcessing) {
    console.warn(
      'DateOfProcessing is undefined for generateProcessingBatchCodeForSeed. Using current date as fallback.'
    );
    dateOfProcessing = new Date();
  }
  const cropCode = crop.slice(0, 3).toUpperCase();
  const dateCode = dateOfProcessing.toISOString().split('T')[0]?.replace(/-/g, '') || 'NODATEPBC';
  const lotStr = lotNo.toString();
  // Using a more random suffix to improve uniqueness for seed data
  const suffix =
    (Math.random().toString(36).substring(2, 7) + Math.random().toString(36).substring(2, 7)).toUpperCase() +
    counter.toString();
  return `PBC-${cropCode}-${lotStr}-${dateCode}-${suffix}`;
}

async function main() {
  console.log(`Start seeding ...`);

  const adminPassword = await hashPassword('Admin@123');
  const staffPassword = await hashPassword('Staff@123');

  const adminUser = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: { password: adminPassword },
    create: {
      email: 'admin@example.com',
      name: 'Admin User',
      password: adminPassword,
      role: Role.ADMIN,
      isEnabled: true,
    },
  });

  const staffUser = await prisma.user.upsert({
    where: { email: 'staff@example.com' },
    update: { password: staffPassword },
    create: {
      email: 'staff@example.com',
      name: 'Staff User',
      password: staffPassword,
      role: Role.STAFF,
      isEnabled: true,
    },
  });
  console.log(`Created users: ${adminUser.name}, ${staffUser.name}`);

  const farmer1 = await prisma.farmer.upsert({
    where: { surveyNumber: 'FARMSEED001' },
    update: {},
    create: {
      surveyNumber: 'FARMSEED001',
      name: 'Seeder Farmer One',
      relationship: Relationship.SELF,
      gender: Gender.MALE,
      community: 'General',
      aadharNumber: '111122223333',
      state: 'State A',
      district: 'District X',
      mandal: 'Mandal P',
      village: 'Village Alpha',
      panchayath: 'Alpha GP',
      dateOfBirth: new Date('1975-05-10'),
      age: 49,
      contactNumber: '9000000001',
      createdById: adminUser.id,
      updatedById: adminUser.id,
      bankDetails: {
        create: {
          ifscCode: 'IFSC001',
          bankName: 'Seed Bank',
          branchName: 'Main',
          accountNumber: 'ACC001',
          address: 'Bank Address',
          bankCode: 'SB01',
        },
      },
      documents: {
        create: {
          profilePicUrl: 'https://placehold.co/400',
          aadharDocUrl: 'https://placehold.co/doc.pdf',
          bankDocUrl: 'https://placehold.co/doc.pdf',
        },
      },
    },
  });
  const farmer2 = await prisma.farmer.upsert({
    where: { surveyNumber: 'FARMSEED002' },
    update: {},
    create: {
      surveyNumber: 'FARMSEED002',
      name: 'Seeder Farmer Two',
      relationship: Relationship.SELF,
      gender: Gender.FEMALE,
      community: 'OBC',
      aadharNumber: '444455556666',
      state: 'State B',
      district: 'District Y',
      mandal: 'Mandal Q',
      village: 'Village Beta',
      panchayath: 'Beta GP',
      dateOfBirth: new Date('1980-11-20'),
      age: 43,
      contactNumber: '9000000002',
      createdById: staffUser.id,
      updatedById: staffUser.id,
      bankDetails: {
        create: {
          ifscCode: 'IFSC002',
          bankName: 'Agri Bank',
          branchName: 'Rural',
          accountNumber: 'ACC002',
          address: 'Agri Address',
          bankCode: 'AG01',
        },
      },
      documents: {
        create: {
          profilePicUrl: 'https://placehold.co/400',
          aadharDocUrl: 'https://placehold.co/doc.pdf',
          bankDocUrl: 'https://placehold.co/doc.pdf',
        },
      },
    },
  });
  console.log(`Created farmers: ${farmer1.name}, ${farmer2.name}`);

  const procurementBaseDate = new Date();
  procurementBaseDate.setDate(procurementBaseDate.getDate() - 10); // 10 days ago

  // Procurements for Turmeric - Lot 1
  const procTurmeric1F1L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[0], // Fresh Finger
      speciality: 'Organic',
      quantity: 120.5,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(9, 0, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
      vehicleNo: 'TS01AA1111',
    },
  });
  const procTurmeric2F2L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer2.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[0], // Fresh Finger
      speciality: 'Standard',
      quantity: 80.0,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 2),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(9, 30, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
    },
  });
  const procTurmeric3F1L1DF = await prisma.procurement.create({
    // Different ProcuredForm
    data: {
      farmerId: farmer1.id,
      crop: 'Turmeric',
      procuredForm: CROP_PROCURED_FORMS.Turmeric[2], // Dried Finger
      speciality: 'Organic',
      quantity: 50.0,
      procurementNumber: generateProcurementNumberForSeed('Turmeric', procurementBaseDate, 1, 3),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(10, 0, 0, 0)),
      lotNo: 1,
      procuredBy: staffUser.name,
    },
  });

  // Procurements for Coffee - Lot 1
  const procCoffee1F1L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Coffee',
      procuredForm: CROP_PROCURED_FORMS.Coffee[1], // Dry Cherry
      speciality: 'Fair Trade',
      quantity: 250.0,
      procurementNumber: generateProcurementNumberForSeed('Coffee', procurementBaseDate, 1, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(11, 0, 0, 0)),
      lotNo: 1,
      procuredBy: adminUser.name,
      vehicleNo: 'KA02BB2222',
    },
  });
  const procCoffee2F2L1 = await prisma.procurement.create({
    data: {
      farmerId: farmer2.id,
      crop: 'Coffee',
      procuredForm: CROP_PROCURED_FORMS.Coffee[1], // Dry Cherry
      speciality: 'Standard',
      quantity: 180.5,
      procurementNumber: generateProcurementNumberForSeed('Coffee', procurementBaseDate, 1, 2),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(11, 30, 0, 0)),
      lotNo: 1,
      procuredBy: adminUser.name,
    },
  });

  // Procurements for Ginger - Lot 2 (Farmer 1)
  const procGinger1F1L2 = await prisma.procurement.create({
    data: {
      farmerId: farmer1.id,
      crop: 'Ginger',
      procuredForm: CROP_PROCURED_FORMS.Ginger[0], // Fresh
      speciality: 'Organic',
      quantity: 75.5,
      procurementNumber: generateProcurementNumberForSeed('Ginger', procurementBaseDate, 2, 1),
      date: procurementBaseDate,
      time: new Date(new Date(procurementBaseDate).setHours(14, 0, 0, 0)),
      lotNo: 2,
      procuredBy: staffUser.name,
    },
  });

  console.log(`Created various procurements.`);

  // --- Processing Batch example for Turmeric, Lot 1, Fresh Finger ---
  const turmericBatchInitialQty = procTurmeric1F1L1.quantity + procTurmeric2F2L1.quantity;
  const turmericP1Date = new Date();
  turmericP1Date.setDate(turmericP1Date.getDate() - 7); // 7 days ago

  const turmericBatchCode = generateProcessingBatchCodeForSeed('Turmeric', 1, turmericP1Date, 1);
  const turmericProcessingBatch = await prisma.processingBatch.create({
    data: {
      batchCode: turmericBatchCode,
      crop: 'Turmeric',
      lotNo: 1, // Matching the selected procurements' lotNo
      initialBatchQuantity: turmericBatchInitialQty,
      createdById: adminUser.id,
      procurements: {
        connect: [{ id: procTurmeric1F1L1.id }, { id: procTurmeric2F2L1.id }], // Only Fresh Finger from Lot 1
      },
      processingStages: {
        create: {
          processingCount: 1,
          processMethod: 'dry', // Turmeric often dried
          initialQuantity: turmericBatchInitialQty,
          dateOfProcessing: turmericP1Date,
          doneBy: 'Turmeric P1 Seed Team',
          status: ProcessingStageStatus.IN_PROGRESS,
          createdById: adminUser.id,
        },
      },
    },
    include: { processingStages: { orderBy: { processingCount: 'asc' } } },
  });

  if (!turmericProcessingBatch.processingStages || turmericProcessingBatch.processingStages.length === 0) {
    console.error(`Failed to create P1 stage for Turmeric batch ${turmericProcessingBatch.batchCode}.`);
  } else {
    const p1Turmeric = turmericProcessingBatch.processingStages[0];
    if (!p1Turmeric || typeof p1Turmeric.id === 'undefined') {
      console.error(`P1 Turmeric stage object is invalid for batch ${turmericProcessingBatch.batchCode}.`);
    } else {
      console.log(`Created Turmeric batch: ${turmericProcessingBatch.batchCode} with P1: ${p1Turmeric.id}`);

      let currentDryingQty = p1Turmeric.initialQuantity;
      for (let i = 1; i <= 2; i++) {
        // 2 days of drying
        currentDryingQty -= Math.random() * 5 + 1; // Turmeric loses more weight
        await prisma.drying.create({
          data: {
            processingStageId: p1Turmeric.id,
            day: i,
            temperature: 35 + Math.random() * 5,
            humidity: 40 + Math.random() * 10,
            pH: 6.0 + Math.random() * 0.5,
            moisturePercentage: 50 - i * 10,
            currentQuantity: parseFloat(currentDryingQty.toFixed(2)),
          },
        });
      }
      console.log(`Added drying entries for Turmeric P1.`);

      const p1TurmericFinalYield = parseFloat(currentDryingQty.toFixed(2)) - (Math.random() * 2 + 0.5);
      const finalizedP1Turmeric = await prisma.processingStage.update({
        where: { id: p1Turmeric.id },
        data: {
          status: ProcessingStageStatus.FINISHED,
          dateOfCompletion: new Date(new Date(turmericP1Date).setDate(turmericP1Date.getDate() + 2)),
          quantityAfterProcess: parseFloat(p1TurmericFinalYield.toFixed(2)),
        },
      });
      console.log(`Finalized Turmeric P1. Yield: ${finalizedP1Turmeric.quantityAfterProcess}kg`);

      if (finalizedP1Turmeric.quantityAfterProcess && finalizedP1Turmeric.quantityAfterProcess > 10) {
        await prisma.sale.create({
          data: {
            processingBatchId: turmericProcessingBatch.id,
            processingStageId: finalizedP1Turmeric.id,
            quantitySold: 10,
            dateOfSale: new Date(),
            createdById: staffUser.id,
          },
        });
        console.log(`Sold 10kg from Turmeric P1.`);
      }
    }
  }

  console.log(`Seeding finished.`);
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async e => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });

```

### packages\shared\src\index.ts:
```
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

export * from '@prisma/client';

export * from './schemas/auth';
export * from './schemas/farmer';
export * from './schemas/users';
export * from './schemas/procurement';
export * from './schemas/processingBatch';
export * from './schemas/processingStage';
export * from './schemas/sale';

```

### packages\shared\src\schemas\auth.ts:
```
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
});

export const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
});

export type LoginInput = z.infer<typeof loginSchema>;
export type RegisterInput = z.infer<typeof registerSchema>;

```

### packages\shared\src\schemas\farmer.ts:
```
import { z } from 'zod';

export const farmerSchema = z.object({
  id: z.number().optional(),
  surveyNumber: z.string().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  relationship: z.enum(['SELF', 'SPOUSE', 'CHILD', 'OTHER']),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']),
  community: z.string().min(1, 'Community is required'),
  aadharNumber: z.string().min(12, 'Valid Aadhar number required').max(12),
  state: z.string().min(1, 'State is required'),
  district: z.string().min(1, 'District is required'),
  mandal: z.string().min(1, 'Mandal is required'),
  village: z.string().min(1, 'Village is required'),
  panchayath: z.string().min(1, 'Panchayath is required'),
  dateOfBirth: z.string().transform(str => new Date(str)),
  age: z.number().int().min(18, 'Farmer must be at least 18 years old'),
  contactNumber: z.string().min(10, 'Valid contact number required'),
  isActive: z.boolean().default(true),
});

export const bankDetailsSchema = z.object({
  ifscCode: z.string().min(1, 'IFSC code is required'),
  bankName: z.string().min(1, 'Bank name is required'),
  branchName: z.string().min(1, 'Branch name is required'),
  accountNumber: z.string().min(1, 'Account number is required'),
  address: z.string().min(1, 'Bank address is required'),
  bankCode: z.string().min(1, 'Bank code is required'),
});

export const farmerDocumentsSchema = z.object({
  profilePicUrl: z.string().url('Valid profile picture URL required'),
  aadharDocUrl: z.string().url('Valid Aadhar document URL required'),
  bankDocUrl: z.string().url('Valid bank document URL required'),
});

export const fieldSchema = z.object({
  areaHa: z.number().positive('Area must be a positive number'),
  yieldEstimate: z.number().positive('Yield estimate must be a positive number'),
  location: z.object({
    lat: z.number(),
    lng: z.number(),
    accuracy: z.number(),
    altitude: z.number().nullable(),
    altitudeAccuracy: z.number().nullable(),
    timestamp: z.number(),
  }),
  landDocumentUrl: z.string().url('Valid land document URL required'),
});

export const createFarmerSchema = z.object({
  farmer: farmerSchema,
  bankDetails: bankDetailsSchema,
  documents: farmerDocumentsSchema,
  fields: z.array(fieldSchema).optional(),
});

export const updateFarmerSchema = z.object({
  farmer: farmerSchema.partial(),
  bankDetails: bankDetailsSchema.partial().optional(),
  documents: farmerDocumentsSchema.partial().optional(),
  fields: z.array(fieldSchema.partial()).optional(),
});

export const farmerQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  state: z.string().optional(),
  district: z.string().optional(),
  gender: z.enum(['MALE', 'FEMALE', 'OTHER']).optional(),
  isActive: z.preprocess(val => {
    if (typeof val === 'string') {
      if (val.toLowerCase() === 'true') return true;
      if (val.toLowerCase() === 'false') return false;
    }
    return val;
  }, z.boolean().optional().default(true)),
});

export type FarmerInput = z.infer<typeof farmerSchema>;
export type BankDetailsInput = z.infer<typeof bankDetailsSchema>;
export type FarmerDocumentsInput = z.infer<typeof farmerDocumentsSchema>;
export type FieldInput = z.infer<typeof fieldSchema>;
export type CreateFarmerInput = z.infer<typeof createFarmerSchema>;
export type UpdateFarmerInput = z.infer<typeof updateFarmerSchema>;
export type FarmerQuery = z.infer<typeof farmerQuerySchema>;

```

### packages\shared\src\schemas\processingBatch.ts:
```
import { z } from 'zod';
import { ProcessingStageStatus } from '@prisma/client';

export const createProcessingBatchFirstStageSchema = z.object({
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible for P1 is required'),
});

export const createProcessingBatchSchema = z.object({
  crop: z.string().min(1, 'Crop is required'),
  lotNo: z.number().int().min(1, 'Lot number is required'),
  procurementIds: z.array(z.number().int()).min(1, 'At least one procurement must be selected'),
  firstStageDetails: createProcessingBatchFirstStageSchema,
});
export type CreateProcessingBatchInput = z.infer<typeof createProcessingBatchSchema>;

const queryStatusEnumValues: [string, ...string[]] = [
  ProcessingStageStatus.IN_PROGRESS,
  ProcessingStageStatus.FINISHED,
  ProcessingStageStatus.CANCELLED,
  'SOLD_OUT',
];

export const processingBatchQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  status: z.enum(queryStatusEnumValues).optional(),
});
export type ProcessingBatchQuery = z.infer<typeof processingBatchQuerySchema>;

```

### packages\shared\src\schemas\procurement.ts:
```
import { z } from 'zod';

export const createProcurementSchema = z.object({
  farmerId: z.number(),
  crop: z.string().min(1, 'Crop is required'),
  procuredForm: z.string().min(1, 'Procured form is required'),
  speciality: z.string().min(1, 'Speciality is required'),
  quantity: z.number().positive('Quantity must be a positive number'),
  date: z.string().transform(str => new Date(str)), // This should be the procurement date
  time: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (expected HH:mm:ss)'), // Procurement time
  lotNo: z.number().int().min(1, 'Lot number must be a positive integer'), // Max removed, can be any int now.
  procuredBy: z.string().min(1, 'Procured by is required'),
  vehicleNo: z.string().min(1, 'Vehicle number is required').optional(),
});

export type CreateProcurementInput = z.infer<typeof createProcurementSchema>;

export const updateProcurementSchema = createProcurementSchema.partial().extend({
  id: z.number(),
});
export type UpdateProcurementInput = z.infer<typeof updateProcurementSchema>;

export const procurementQuerySchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
  search: z.string().optional(),
  farmerId: z.string().transform(Number).optional(),
  crop: z.string().optional(),
  lotNo: z.string().transform(Number).optional(),
  isBatched: z.boolean().optional(), // To filter procurements already in a batch or not
});

export type ProcurementQuery = z.infer<typeof procurementQuerySchema>;

```

### packages\shared\src\schemas\users.ts:
```
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number().optional(),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  role: z.enum(['ADMIN', 'STAFF']).default('STAFF'),
  isEnabled: z.boolean().default(true),
  isActive: z.boolean().default(false),
  lastLoginAt: z.date().nullable().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export const updateUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters').optional(),
  email: z.string().email('Invalid email address').optional(),
  isEnabled: z.boolean().optional(),
  password: z.string().min(6, 'Password must be at least 6 characters').optional(),
});

export type ZodUser = z.infer<typeof userSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;

```

### packages\shared\src\schemas\processingStage.ts:
```
import { z } from 'zod';

export const createProcessingStageSchema = z.object({
  processingBatchId: z.number().int(),
  previousStageId: z.number().int().optional(),
  processMethod: z.enum(['wet', 'dry'], { required_error: 'Process method is required' }),
  dateOfProcessing: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  doneBy: z.string().min(1, 'Person responsible is required'),
});
export type CreateProcessingStageInput = z.infer<typeof createProcessingStageSchema>;

export const finalizeProcessingStageSchema = z.object({
  dateOfCompletion: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
  quantityAfterProcess: z.coerce
    .number({
      required_error: 'Final quantity is required',
      invalid_type_error: 'Final quantity must be a number',
    })
    .positive('Final quantity must be a positive number'),
});
export type FinalizeProcessingStageInput = z.infer<typeof finalizeProcessingStageSchema>;

export const createDryingEntrySchema = z.object({
  processingStageId: z.number().int(),
  day: z.number().int().positive('Day must be a positive integer'),
  temperature: z.number({ required_error: 'Temperature is required' }),
  humidity: z.number().min(0).max(100, 'Humidity must be between 0 and 100'),
  pH: z.number().min(0).max(14, 'pH must be between 0 and 14'),
  moisturePercentage: z.number().min(0).max(100, 'Moisture % must be between 0 and 100'),
  currentQuantity: z.coerce
    .number({
      required_error: 'Current quantity is required',
      invalid_type_error: 'Current quantity must be a number',
    })
    .positive('Current quantity after drying must be positive'),
});
export type CreateDryingEntryInput = z.infer<typeof createDryingEntrySchema>;

```

### packages\shared\src\schemas\sale.ts:
```
import { z } from 'zod';

export const createSaleFormSchema = z.object({
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSaleInput: z.date({
    required_error: 'Date of Sale is required',
    invalid_type_error: "That's not a valid date!",
  }),
  timeOfSaleInput: z.string().regex(/^\d{2}:\d{2}:\d{2}$/, 'Invalid time format (HH:mm:ss)'),
});
export type CreateSaleFormValues = z.infer<typeof createSaleFormSchema>;

export const createSaleSchema = z.object({
  processingBatchId: z.number().int(),
  processingStageId: z.number().int(),
  quantitySold: z.coerce
    .number({
      required_error: 'Quantity sold is required',
      invalid_type_error: 'Quantity sold must be a number',
    })
    .positive('Quantity sold must be positive'),
  dateOfSale: z
    .string()
    .datetime({ message: 'Invalid datetime string. Must be UTC.' })
    .transform(str => new Date(str)),
});
export type CreateSaleInput = z.infer<typeof createSaleSchema>;

```

### turbo.json:
```
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "tui",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["$TURBO_DEFAULT$", ".env*"],
      "outputs": [".next/**", "!.next/cache/**"],
      "env": ["DATABASE_URL", "JWT_SECRET", "UPLOADTHING_TOKEN", "FRONTEND_URL", "PORT", "HOST", "NODE_ENV"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "check-types": {
      "dependsOn": ["^check-types"]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "env": ["DATABASE_URL", "JWT_SECRET", "UPLOADTHING_TOKEN", "FRONTEND_URL", "PORT", "HOST", "NODE_ENV"]
    },
    "db:generate": {
      "cache": false,
      "outputs": ["node_modules/.prisma/**"]
    }
  },
  "globalDependencies": [".env"]
}
```

### tsconfig.json:
```
{
  "extends": "@workspace/typescript-config/base.json",
  "pipeline": {
    "format": {
      "cache": false
    },
    "format:check": {
      "cache": false
    }
  }
}
```

### package.json:
```
{
  "name": "shadcn-ui-monorepo",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "build": "turbo build",
    "dev": "turbo dev",
    "lint": "turbo lint",
    "server": "pnpm --filter web start & pnpm --filter api start",
    "start": "concurrently -k -n web,api -c blue,green \"pnpm --filter web start\" \"pnpm --filter api start\"",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,css,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,ts,tsx,json,css,md}\""
  },
  "devDependencies": {
    "@eslint/js": "^9.24.0",
    "@workspace/eslint-config": "workspace:*",
    "@workspace/typescript-config": "workspace:*",
    "concurrently": "^9.1.2",
    "eslint-config-prettier": "^9.1.0",
    "prettier": "^3.5.3",
    "turbo": "^2.5.0",
    "typescript": "5.8.3"
  },
  "packageManager": "pnpm@10.6.3",
  "engines": {
    "node": ">=20"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0"
  }
}
```

### .eslintrc.js:
```
// This configuration only applies to the package manager root.
/** @type {import("eslint").Linter.Config} */
module.exports = {
  ignorePatterns: ['apps/**', 'packages/**'],
  extends: ['@workspace/eslint-config/library.js'],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: true,
  },
};
```

### packages/eslint-config/base.js:
```
import js from '@eslint/js';
import eslintConfigPrettier from 'eslint-config-prettier';
import onlyWarn from 'eslint-plugin-only-warn';
import turboPlugin from 'eslint-plugin-turbo';
import tseslint from 'typescript-eslint';

/**
 * A shared ESLint configuration for the repository.
 *
 * @type {import("eslint").Linter.Config}
 * */
export const config = [
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  {
    plugins: {
      turbo: turboPlugin,
    },
    rules: {
      'turbo/no-undeclared-env-vars': 'warn',
    },
  },
  {
    plugins: {
      onlyWarn,
    },
  },
  {
    ignores: ['dist/**'],
  },
];
```

### packages/eslint-config/next.js
```
import js from '@eslint/js';
import pluginNext from '@next/eslint-plugin-next';
import eslintConfigPrettier from 'eslint-config-prettier';
import pluginReact from 'eslint-plugin-react';
import pluginReactHooks from 'eslint-plugin-react-hooks';
import globals from 'globals';
import tseslint from 'typescript-eslint';

import { config as baseConfig } from './base.js';

/**
 * A custom ESLint configuration for libraries that use Next.js.
 *
 * @type {import("eslint").Linter.Config}
 * */
export const nextJsConfig = [
  ...baseConfig,
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  {
    ...pluginReact.configs.flat.recommended,
    languageOptions: {
      ...pluginReact.configs.flat.recommended.languageOptions,
      globals: {
        ...globals.serviceworker,
      },
    },
  },
  {
    plugins: {
      '@next/next': pluginNext,
    },
    rules: {
      ...pluginNext.configs.recommended.rules,
      ...pluginNext.configs['core-web-vitals'].rules,
    },
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
    },
    settings: { react: { version: 'detect' } },
    rules: {
      ...pluginReactHooks.configs.recommended.rules,
      // React scope no longer necessary with new JSX transform.
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
    },
  },
];
```

### packages/eslint-config/react-internal.js:
```
import js from '@eslint/js';
import eslintConfigPrettier from 'eslint-config-prettier';
import pluginReact from 'eslint-plugin-react';
import pluginReactHooks from 'eslint-plugin-react-hooks';
import globals from 'globals';
import tseslint from 'typescript-eslint';

import { config as baseConfig } from './base.js';

/**
 * A custom ESLint configuration for libraries that use React.
 *
 * @type {import("eslint").Linter.Config} */
export const config = [
  ...baseConfig,
  js.configs.recommended,
  eslintConfigPrettier,
  ...tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
  {
    languageOptions: {
      ...pluginReact.configs.flat.recommended.languageOptions,
      globals: {
        ...globals.serviceworker,
        ...globals.browser,
      },
    },
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
    },
    settings: { react: { version: 'detect' } },
    rules: {
      ...pluginReactHooks.configs.recommended.rules,
      // React scope no longer necessary with new JSX transform.
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off',
    },
  },
];
```

### packages/shared/tsconfig.json:
```
{
  "compilerOptions": {
    "outDir": "dist", // Output directory for compiled files
    "rootDir": "src", // Root directory for source files
    "declaration": true, // Generate .d.ts files for type declarations
    "declarationMap": true, // Generate .d.ts.map files for debugging
    "module": "ESNext", // Use ESNext module system
    "moduleResolution": "Node", // Resolve modules like Node.js
    "target": "ESNext", // Target modern JavaScript
    "strict": true, // Enable strict type checking
    "esModuleInterop": true, // Enable interoperability between CommonJS and ES modules
    "skipLibCheck": true // Skip type checking of declaration files
  },
  "include": ["src"], // Include all files in the src folder
  "exclude": ["node_modules", "dist"] // Exclude node_modules and dist folders
}
```

### packages/shared/tsconfig.tsbuildinfo:
```
{"root":["./src/index.ts","./src/schemas/auth.ts","./src/schemas/farmer.ts","./src/schemas/processing.ts","./src/schemas/procurement.ts","./src/schemas/users.ts"],"version":"5.8.3"}
```

### packages/typescript-config/base.json:
```
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "incremental": false,
    "isolatedModules": true,
    "lib": ["es2022", "DOM", "DOM.Iterable"],
    "module": "NodeNext",
    "moduleDetection": "force",
    "moduleResolution": "NodeNext",
    "noUncheckedIndexedAccess": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "ES2022"
  }
}
```

### packages/typescript-config/nextjs.json:
```
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Next.js",
  "extends": "./base.json",
  "compilerOptions": {
    "plugins": [{ "name": "next" }],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "allowJs": true,
    "jsx": "preserve",
    "noEmit": true
  }
}
```

### packages/typescript-config/react-library.json:
```
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./base.json",
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}
```

### packages/ui/eslint.config.js:
```
import { config } from '@workspace/eslint-config/react-internal';

/** @type {import("eslint").Linter.Config} */
export default config;
```

### packages/ui/tsconfig.json:
```
{
  "extends": "@workspace/typescript-config/react-library.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@workspace/ui/*": ["./src/*"]
    }
  },
  "include": ["."],
  "exclude": ["node_modules", "dist"]
}
```

### packages/ui/tsconfig.lint.json:
```
{
  "extends": "@workspace/typescript-config/react-library.json",
  "compilerOptions": {
    "outDir": "dist"
  },
  "include": ["src", "turbo"],
  "exclude": ["node_modules", "dist"]
}
```

### apps/api/tsconfig.json:
```
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
```

### apps/web/eslint.config.js:
```
import { defineConfig } from 'eslint-define-config';

export const nextJsConfig = defineConfig({
  extends: ['next/core-web-vitals', 'turbo', 'prettier'],
  plugins: ['prettier'],
  rules: {
    'prettier/prettier': 'error',
  },
});
```

### apps/web/tsconfig.json:
```
{
  "extends": "@workspace/typescript-config/nextjs.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@workspace/ui/*": ["../../packages/ui/src/*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "next.config.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### package.json:
```
{
  "name": "shadcn-ui-monorepo",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "build": "turbo build",
    "dev": "turbo dev",
    "lint": "turbo lint",
    "server": "pnpm --filter web start & pnpm --filter api start",
    "start": "concurrently -k -n web,api -c blue,green \"pnpm --filter web start\" \"pnpm --filter api start\"",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,css,md}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,ts,tsx,json,css,md}\""
  },
  "devDependencies": {
    "@eslint/js": "^9.24.0",
    "@workspace/eslint-config": "workspace:*",
    "@workspace/typescript-config": "workspace:*",
    "concurrently": "^9.1.2",
    "eslint-config-prettier": "^9.1.0",
    "prettier": "^3.5.3",
    "turbo": "^2.5.0",
    "typescript": "5.8.3"
  },
  "packageManager": "pnpm@10.6.3",
  "engines": {
    "node": ">=20"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0"
  }
}
```

### apps/api/package.json:
```
{
  "name": "api",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "nodemon --exec bun src/index.ts",
    "build": "bun build src/index.ts --outdir dist --target node",
    "start": "bun run src/index.ts",
    "lint": "eslint .",
    "check-types": "tsc --noEmit"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/bun": "latest",
    "@types/node": "^20.10.4",
    "typescript": "^5.3.3"
  },
  "peerDependencies": {
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "@chaya/shared": "workspace:*",
    "@fastify/cookie": "^11.0.2",
    "@fastify/cors": "^11.0.0",
    "@fastify/jwt": "^9.0.4",
    "bcryptjs": "^2.4.3",
    "date-fns": "^4.1.0",
    "fastify": "^5.2.1",
    "ioredis": "^5.6.1",
    "nodemon": "^3.1.9",
    "pino-pretty": "^13.0.0",
    "uploadthing": "^7.6.0",
    "uuid": "^11.1.0"
  }
}
```

### apps/web/package.json:
```
{
  "name": "web",
  "version": "0.0.1",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "run-b": "next build && next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@chaya/shared": "workspace:*",
    "@hookform/resolvers": "^4.1.3",
    "@tanstack/react-table": "^8.21.2",
    "@uploadthing/react": "^7.3.0",
    "@workspace/ui": "workspace:*",
    "axios": "^1.8.3",
    "browser-image-compression": "^2.0.2",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.7.5",
    "lucide-react": "^0.475.0",
    "next": "^15.2.0",
    "next-themes": "^0.4.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "recharts": "^2.15.1",
    "sonner": "^2.0.1",
    "uploadthing": "^7.6.0",
    "use-debounce": "^10.0.4",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@types/date-fns": "^2.6.3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@workspace/eslint-config": "workspace:^",
    "@workspace/typescript-config": "workspace:*",
    "typescript": "^5.8.3"
  }
}
```

### packages/ui/package.json:
```
{
  "name": "@workspace/ui",
  "version": "0.0.0",
  "type": "module",
  "private": true,
  "scripts": {
    "lint": "eslint . --max-warnings 0"
  },
  "dependencies": {
    "@hookform/resolvers": "^4.1.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.6",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.6",
    "@radix-ui/react-radio-group": "^1.3.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.1.8",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.475.0",
    "next-themes": "^0.4.4",
    "react": "^19.0.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.54.2",
    "recharts": "^2.15.1",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.1",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.8",
    "@turbo/gen": "^2.4.2",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@workspace/eslint-config": "workspace:*",
    "@workspace/typescript-config": "workspace:*",
    "tailwindcss": "^4.0.8",
    "typescript": "^5.7.3"
  },
  "exports": {
    "./globals.css": "./src/styles/globals.css",
    "./postcss.config": "./postcss.config.mjs",
    "./lib/*": "./src/lib/*.ts",
    "./components/*": "./src/components/*.tsx",
    "./hooks/*": "./src/hooks/*.ts"
  }
}
```

### packages/shared/package.json:
```
{
  "name": "@chaya/shared",
  "version": "0.0.1",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "scripts": {
    "build": "tsc --build",
    "dev": "tsc --watch",
    "lint": "eslint . --ext .ts,.tsx",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "bun ./prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0",
    "@types/bcryptjs": "^2.4.6",
    "bcryptjs": "^2.4.3",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.6.0",
    "@types/bcrypt": "^5.0.2",
    "prisma": "^6.6.0",
    "typescript": "^5.3.3"
  }
}
```

### packages/typescript-config/package.json:
```
{
  "name": "@workspace/typescript-config",
  "version": "0.0.0",
  "private": true,
  "license": "PROPRIETARY",
  "publishConfig": {
    "access": "public"
  }
}
```

### apps/web/next.config.mjs:
```
/** @type {import('next').NextConfig} */
const nextConfig = {
	transpilePackages: ['@workspace/ui'],
	env: {
		UPLOADTHING_TOKEN: 'reatokenterekotsogkljsoiedjoesnes=',
		UPLOADTHING_SECRET: process.env.UPLOADTHING_SECRET,
		UPLOADTHING_APP_ID: process.env.UPLOADTHING_APP_ID,
	},
};

export default nextConfig;
```