generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // url      = "postgresql://chayadb_owner:npg_tL9O7cgEKGaJ@ep-delicate-dream-a5pwfo3o-pooler.us-east-2.aws.neon.tech/chayadb?sslmode=require"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum Relationship {
  SELF
  SPOUSE
  CHILD
  OTHER
}

enum Role {
  ADMIN
  STAFF
}

enum ProcessingStageStatus {
  IN_PROGRESS
  FINISHED
  CANCELLED // Added for completeness
}

model Ping {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id             Int               @id @default(autoincrement())
  email          String            @unique
  password       String
  name           String
  role           Role              @default(STAFF)
  isActive       Boolean           @default(true)
  isEnabled      Boolean           @default(true)
  lastLoginAt    DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  farmersCreated Farmer[]          @relation("CreatedByUser")
  farmersUpdated Farmer[]          @relation("UpdatedByUser")
  batchesCreated ProcessingBatch[] @relation("BatchCreatedByUser")
  stagesCreated  ProcessingStage[] @relation("StageCreatedByUser")
  salesCreated   Sale[]            @relation("SaleCreatedByUser")

  @@map("users")
}

model Farmer {
  id                 Int               @id @default(autoincrement())
  surveyNumber       String            @unique
  name               String
  relationship       Relationship
  gender             Gender
  community          String
  aadharNumber       String            @unique
  state              String
  district           String
  mandal             String
  village            String
  panchayath         String
  dateOfBirth        DateTime
  age                Int
  contactNumber      String
  isActive           Boolean           @default(true)
  createdById        Int
  updatedById        Int
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  bankDetails        BankDetails?
  documents          FarmerDocuments?
  createdBy          User              @relation("CreatedByUser", fields: [createdById], references: [id])
  updatedBy          User              @relation("UpdatedByUser", fields: [updatedById], references: [id])
  fields             Field[]
  procurements       Procurement[]
  processingBatches  ProcessingBatch[] @relation("FarmerToProcessingBatch") // If a batch can be tied to a primary farmer

  @@map("farmers")
}

model FarmerDocuments {
  id            Int      @id @default(autoincrement())
  profilePicUrl String
  aadharDocUrl  String
  bankDocUrl    String
  farmerId      Int      @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  farmer        Farmer   @relation(fields: [farmerId], references: [id], onDelete: Cascade)

  @@map("farmer_documents")
}

model BankDetails {
  id            Int      @id @default(autoincrement())
  ifscCode      String
  bankName      String
  branchName    String
  accountNumber String
  address       String
  bankCode      String
  farmerId      Int      @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  farmer        Farmer   @relation(fields: [farmerId], references: [id], onDelete: Cascade)

  @@map("bank_details")
}

model Field {
  id              Int      @id @default(autoincrement())
  areaHa          Float
  yieldEstimate   Float
  location        Json
  landDocumentUrl String
  farmerId        Int
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  farmer          Farmer   @relation(fields: [farmerId], references: [id], onDelete: Cascade)

  @@map("fields")
}

model Procurement {
  id                 Int        @id @default(autoincrement())
  farmerId           Int
  crop               String
  procuredForm       String
  speciality         String
  quantity           Float
  batchCode          String     @unique // Original procurement batch code
  date               DateTime
  time               DateTime // Combined date and time of procurement
  lotNo              Int
  procuredBy         String
  vehicleNo          String? // Made optional as per some frontend indications
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  farmer             Farmer     @relation(fields: [farmerId], references: [id], onDelete: Cascade)
  processingBatchId  Int?
  processingBatch    ProcessingBatch? @relation(fields: [processingBatchId], references: [id], onDelete: SetNull) // Procurements are part of a processing batch

  @@map("procurements")
}

model ProcessingBatch {
  id                    Int               @id @default(autoincrement())
  batchCode             String            @unique // e.g., PBC-CROP-LOT-YYYYMMDD-UNIQUEID
  crop                  String
  lotNo                 Int
  initialBatchQuantity  Float // Sum of quantities from procurements
  createdById           Int
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  procurements          Procurement[]     // Procurements included in this batch
  processingStages      ProcessingStage[] @relation("BatchToStages")
  sales                 Sale[]            @relation("BatchToSales")
  createdBy             User              @relation("BatchCreatedByUser", fields: [createdById], references: [id])
  // Optionally, if a batch is associated with a primary farmer for reporting
  farmerId              Int?
  farmer                Farmer?           @relation("FarmerToProcessingBatch", fields: [farmerId], references: [id])


  @@map("processing_batches")
}

model ProcessingStage {
  id                    Int                   @id @default(autoincrement())
  processingBatchId     Int
  processingCount       Int                   @default(1) // P1, P2, etc.
  processMethod         String                // "wet", "dry"
  initialQuantity       Float                 // Quantity at the start of this stage
  quantityAfterProcess  Float?                // Quantity at the end of this stage (final yield of this stage)
  dateOfProcessing      DateTime              // Start date of this stage
  dateOfCompletion      DateTime?             // End date of this stage
  doneBy                String                // Person/team responsible
  status                ProcessingStageStatus @default(IN_PROGRESS)
  createdById           Int
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  processingBatch       ProcessingBatch       @relation("BatchToStages", fields: [processingBatchId], references: [id], onDelete: Cascade)
  dryingEntries         Drying[]
  sales                 Sale[]                @relation("StageToSales") // Sales made from the output of this specific stage
  createdBy             User                  @relation("StageCreatedByUser", fields: [createdById], references: [id])

  @@map("processing_stages")
}

model Drying {
  id                  Int             @id @default(autoincrement())
  processingStageId   Int
  day                 Int             // Drying day number for this stage
  temperature         Float           // Celsius
  humidity            Float           // Percentage
  pH                  Float
  moisturePercentage  Float           // Moisture content percentage
  currentQuantity     Float           // Weight of crop after this day's drying
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  processingStage     ProcessingStage @relation(fields: [processingStageId], references: [id], onDelete: Cascade)

  @@map("drying_entries")
}

model Sale {
  id                  Int             @id @default(autoincrement())
  processingBatchId   Int
  processingStageId   Int             // The specific stage whose output was sold
  quantitySold        Float
  dateOfSale          DateTime
  createdById         Int
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  processingBatch     ProcessingBatch @relation("BatchToSales", fields: [processingBatchId], references: [id], onDelete: Cascade)
  processingStage     ProcessingStage @relation("StageToSales", fields: [processingStageId], references: [id], onDelete:Restrict) // Don't cascade delete stage if sales exist
  createdBy           User            @relation("SaleCreatedByUser", fields: [createdById], references: [id])

  @@map("sales")
}
